<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Ilosyi.github.io</id>
    <title>losyi的博客</title>
    <updated>2024-09-21T17:16:16.099Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Ilosyi.github.io"/>
    <link rel="self" href="https://Ilosyi.github.io/atom.xml"/>
    <logo>https://Ilosyi.github.io/images/avatar.png</logo>
    <icon>https://Ilosyi.github.io/favicon.ico</icon>
    <rights>All rights reserved 2024, losyi的博客</rights>
    <entry>
        <title type="html"><![CDATA[华科习概优学院线上作业练习]]></title>
        <id>https://Ilosyi.github.io/post/hua-ke-xi-gai-you-xue-yuan-xian-shang-zuo-ye-lian-xi/</id>
        <link href="https://Ilosyi.github.io/post/hua-ke-xi-gai-you-xue-yuan-xian-shang-zuo-ye-lian-xi/">
        </link>
        <updated>2024-09-21T16:56:46.000Z</updated>
        <content type="html"><![CDATA[<h2 id="第一讲-导论">第一讲 导论</h2>
<ol>
<li>经过长期努力，中国特色社会主义进入新时代，这是我国发展新的( )<br>
<strong>D 历史方位</strong></li>
<li>( )是实现中华民族伟大复兴的根本保证<br>
<strong>D 党的领导</strong></li>
<li>世界未有之大变局正在加速演变。( )仍然是时代主题，但是不稳定不确定性更加突出<br>
<strong>C 和平与发展</strong></li>
<li>党的十八大以来，我们党的全部理论和实践探索都是围绕( )这个主题来展开、深化和拓展的<br>
<strong>D 坚持和发展中国特色社会主义</strong></li>
<li>中国特色社会主义的战略布局是( )。<br>
<strong>C 四个全面</strong></li>
</ol>
<h2 id="第二讲-新时代坚持和发展中国特色社会主义总任务">第二讲 新时代坚持和发展中国特色社会主义总任务</h2>
<ol>
<li><strong>D 实现中华民族伟大复兴</strong></li>
<li><strong>C 2021年7月1日</strong></li>
<li><strong>D 如期全面建成小康社会</strong></li>
<li>摆脱贫困一直是困扰全球发展和治理的突出难题，我国提前( )实现联合国2030年可持续发展议程减贫目标<br>
<strong>A 10年</strong></li>
<li><strong>D 从2035年到本世纪中叶</strong></li>
<li><strong>A 各族人民大团结的力量</strong></li>
<li><strong>B 人民的梦</strong></li>
<li>中华民族伟大复兴的中国梦是( )相统一的梦<br>
<strong>A 国家情怀、民族情怀、人民情怀</strong></li>
<li><strong>C 个人前途命运</strong></li>
<li><strong>D 中国特色社会主义道路</strong></li>
</ol>
<h2 id="第三讲-坚持党的全面领导">第三讲 坚持党的全面领导</h2>
<ol>
<li>A 十八大</li>
<li>B 坚持和加强党的领导</li>
<li>D</li>
<li>C</li>
<li>C 十九届四中全会</li>
</ol>
<h2 id="第四讲-坚持以人民为中心">第四讲 坚持以人民为中心</h2>
<ol>
<li>A 群众路线</li>
<li>B 人民立场</li>
<li>D 最高利益</li>
<li>B 为人民服务</li>
<li>B 人民利益</li>
</ol>
<h2 id="第五讲-全面深化改革开放">第五讲 全面深化改革开放</h2>
<ol>
<li>D 制度执行力和治理能力</li>
<li>B 党的十八届三中全会</li>
<li>B 全面深化改革</li>
<li>A 2035年</li>
<li>C 马克思主义</li>
</ol>
<h2 id="第六讲-推动现代化发展">第六讲 推动现代化发展</h2>
<ol>
<li>C</li>
<li>A</li>
<li>A</li>
<li>D</li>
<li>B 新发展格局</li>
</ol>
<h2 id="第七讲-社会主义现代化建设的教育科技人才战略">第七讲 社会主义现代化建设的教育科技人才战略</h2>
<ol>
<li>A 教育</li>
<li>A 科技</li>
<li>B 教育</li>
<li>D 人才</li>
<li>D 创新</li>
</ol>
<h2 id="第八讲-全过程人民民主">第八讲 全过程人民民主</h2>
<ol>
<li><strong>B 人民当家作主</strong></li>
<li><strong>A 人民</strong></li>
<li><strong>A 人民民主</strong></li>
<li><strong>B 2019年11月</strong></li>
<li>D</li>
</ol>
<h2 id="第九讲-全面依法治国">第九讲 全面依法治国</h2>
<ol>
<li><strong>B 全面依法治国</strong></li>
<li>A</li>
<li>C</li>
<li>B</li>
<li>A 法治</li>
</ol>
<h2 id="第十讲-建设社会主义文化强国">第十讲 建设社会主义文化强国</h2>
<ol>
<li>C</li>
<li>B 核心价值观</li>
<li>B 文化自信</li>
<li>D</li>
<li>A</li>
</ol>
<h2 id="第十一讲-以保障和改善民生为重点加强社会建设">第十一讲 以保障和改善民生为重点加强社会建设</h2>
<ol>
<li><strong>D 按劳分配</strong></li>
<li><strong>C 就业</strong></li>
<li><strong>B 体制创新</strong></li>
<li><strong>D 城乡社区</strong></li>
<li><strong>A 国家治理体系和治理能力现代化</strong></li>
</ol>
<h2 id="第十二讲-建设社会主义生态文明">第十二讲 建设社会主义生态文明</h2>
<ol>
<li>B<br>
2.** D 2035年**</li>
<li><strong>B 共生关系</strong></li>
<li>&quot;两山论”的突出贡献是( )<br>
<strong>A 马克思主义生产力观的新成果</strong></li>
<li>建设生态文明是关系人民福祉、关乎( )的千年大计<br>
<strong>C 中华民族永续发展</strong></li>
</ol>
<h2 id="第十三讲-全面贯彻总体国家安全观">第十三讲 全面贯彻总体国家安全观</h2>
<ol>
<li><strong>A 人民安全</strong></li>
<li><strong>D 国家安全</strong></li>
<li><strong>D “美人之美，美美与共”</strong></li>
<li>A 人民利益</li>
<li>C 底线思维</li>
</ol>
<h2 id="第十四讲-建设巩固国防和强大人民军队">第十四讲 建设巩固国防和强大人民军队</h2>
<ol>
<li>把()作为唯一的根本的标准，是有效履行我军根本职能的内在要求，也是提高军队建设质量效益的客观需要。<br>
<strong>C 战斗力</strong></li>
<li>B 国家利益至上</li>
<li>C</li>
<li>C 军事人才</li>
<li>C</li>
</ol>
<h2 id="第十五讲-坚持一国两制和推进祖国完全统一">第十五讲 坚持“一国两制”和推进祖国完全统一</h2>
<ol>
<li>D</li>
<li>A</li>
<li>B</li>
<li>B</li>
<li>C</li>
</ol>
<h2 id="第十六讲-推动构建人类命运共同体">第十六讲 推动构建人类命运共同体</h2>
<ol>
<li>B</li>
<li>D</li>
<li>B</li>
<li>B</li>
<li>A</li>
</ol>
<h2 id="第十七讲-全面从严治党">第十七讲 全面从严治党</h2>
<ol>
<li>B</li>
<li>C</li>
<li>A</li>
<li>B</li>
<li>坚持党要管党、全面从严治党的方针的关键是( )<br>
<strong>B 严</strong></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2024秋华中科技大学数据结构课设：基于SAT(DPLL算法)的对角线数独游戏求解程序]]></title>
        <id>https://Ilosyi.github.io/post/2024-qiu-hua-zhong-ke-ji-da-xue-shu-ju-jie-gou-ke-she-ji-yu-satdpll-suan-fa-de-dui-jiao-xian-shu-du-you-xi-qiu-jie-cheng-xu/</id>
        <link href="https://Ilosyi.github.io/post/2024-qiu-hua-zhong-ke-ji-da-xue-shu-ju-jie-gou-ke-she-ji-yu-satdpll-suan-fa-de-dui-jiao-xian-shu-du-you-xi-qiu-jie-cheng-xu/">
        </link>
        <updated>2024-09-15T16:11:28.000Z</updated>
        <content type="html"><![CDATA[<p><font color=Crimson><strong>待更新</strong></font><br><br>
<font color=Crimson><strong>完整源码将在结课后传到</strong></font><br><br>
<a href="https://github.com/Ilosyi/HUSTCS2024-SAT-DPLL-XSudoku">HUSTCS2024-SAT-DPLL-XSudoku<br>
</a><br>
<ul class="markdownIt-TOC">
<li><a href="#1-%E4%BB%80%E4%B9%88%E6%98%AFsat%E9%97%AE%E9%A2%98">1 什么是SAT问题？</a>
<ul>
<li><a href="#11-sat%E9%97%AE%E9%A2%98%E7%AE%80%E4%BB%8B">1.1 SAT问题简介</a></li>
<li><a href="#12-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E7%BD%AE">1.2 数据结构设置</a>
<ul>
<li><a href="#121-vector%E7%B1%BB">1.2.1 vector类</a></li>
</ul>
</li>
<li><a href="#122-literal%E7%B1%BB">1.2.2 Literal类</a></li>
<li><a href="#123-clause%E7%B1%BB">1.2.3 Clause类</a></li>
<li><a href="#124-cnf%E7%B1%BB">1.2.4 CNF类</a></li>
</ul>
</li>
<li><a href="#2-%E4%BB%80%E4%B9%88%E6%98%AFdpll%E7%AE%97%E6%B3%95">2 什么是DPLL算法？</a>
<ul>
<li><a href="#21-%E5%8D%95%E5%AD%90%E5%8F%A5%E8%A7%84%E5%88%99">2.1 单子句规则</a></li>
<li><a href="#22-%E5%88%86%E8%A3%82%E7%AD%96%E7%95%A5">2.2 分裂策略</a>
<ul>
<li><a href="#221-%E5%88%86%E8%A3%82%E7%AD%96%E7%95%A5%E6%A6%82%E5%BF%B5">2.2.1 分裂策略概念</a></li>
<li><a href="#222-%E5%88%86%E8%A3%82%E4%BC%A0%E6%92%AD%E5%87%BD%E6%95%B0">2.2.2 分裂（传播）函数</a></li>
</ul>
</li>
<li><a href="#23-%E8%AF%BB%E5%8F%96cnf%E6%96%87%E4%BB%B6">2.3 读取cnf文件</a>
<ul>
<li><a href="#231-%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6">2.3.1 打开文件</a></li>
<li><a href="#232-%E8%AF%BB%E5%8F%96%E5%86%85%E5%AE%B9">2.3.2 读取内容</a>
<ul>
<li><a href="#2321-getline%E5%87%BD%E6%95%B0">2.3.2.1 getline函数</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84">函数语法结构：</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%98%E9%87%8F">函数的变量：</a></li>
</ul>
</li>
<li><a href="#2322-istringstream%E7%B1%BB">2.3.2.2 istringstream类</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#24-dpll%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">2.4 DPLL具体实现</a>
<ul>
<li><a href="#241-%E4%BC%A0%E6%92%AD%E5%87%BD%E6%95%B0">2.4.1 传播函数</a></li>
<li><a href="#242-%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5">2.4.2 选择策略</a>
<ul>
<li><a href="#2421-%E9%80%89%E6%8B%A9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%87%E5%AD%97">2.4.2.1 选择第一个文字</a></li>
<li><a href="#2422-%E9%9A%8F%E6%9C%BA%E9%80%89%E5%8F%96%E6%96%87%E5%AD%97">2.4.2.2 随机选取文字</a></li>
<li><a href="#2423-%E9%80%89%E6%8B%A9%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E6%96%87%E5%AD%97">2.4.2.3 选择出现最多的文字</a></li>
<li><a href="#2424-%E9%80%89%E6%8B%A9%E7%9F%AD%E5%AD%90%E5%8F%A5%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E6%96%87%E5%AD%97">2.4.2.4 选择短子句中出现最多的文字</a></li>
</ul>
</li>
<li><a href="#243-dpll%E5%87%BD%E6%95%B0">2.4.3 DPLL函数</a></li>
<li><a href="#244-%E6%89%93%E5%8D%B0%E8%B5%8B%E5%80%BC%E7%BB%93%E6%9E%9C%E5%B9%B6%E4%BF%9D%E5%AD%98%E8%87%B3%E5%90%8C%E5%90%8Dres%E6%96%87%E4%BB%B6">2.4.4 打印赋值结果并保存至同名.res文件</a>
<ul>
<li><a href="#2441-%E6%89%93%E5%8D%B0%E8%B5%8B%E5%80%BC%E7%BB%93%E6%9E%9C">2.4.4.1 打印赋值结果</a></li>
<li><a href="#2442-%E4%BF%9D%E5%AD%98%E5%88%B0res%E6%96%87%E4%BB%B6">2.4.4.2 保存到res文件</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-%E6%95%B0%E7%8B%AC%E6%B8%B8%E6%88%8F">3 数独游戏</a>
<ul>
<li><a href="#31-%E6%95%B0%E7%8B%AC%E6%B8%B8%E6%88%8F%E6%A0%BC%E5%B1%80%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E5%BD%92%E7%BA%A6">3.1 数独游戏格局的生成与归约</a></li>
<li><a href="#32-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%95%B0%E7%8B%AC%E6%A3%8B%E7%9B%98">3.2 自动生成数独棋盘</a>
<ul>
<li><a href="#321-%E7%94%9F%E6%88%90%E5%AE%8C%E6%95%B4%E6%95%B0%E7%8B%AC%E6%A3%8B%E7%9B%98">3.2.1 生成完整数独棋盘</a></li>
<li><a href="#322-%E6%8C%96%E6%B4%9E%E6%B3%95%E7%94%9F%E6%88%90%E6%B8%B8%E6%88%8F%E6%A3%8B%E7%9B%98">3.2.2 挖洞法生成游戏棋盘</a></li>
<li><a href="#33-%E8%BD%AC%E5%8C%96%E4%B8%BAsat%E9%97%AE%E9%A2%98">3.3 转化为SAT问题</a>
<ul>
<li><a href="#331-%E8%BD%AC%E5%8C%96%E6%96%B9%E6%A1%88">3.3.1 转化方案</a></li>
<li><a href="#332%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">3.3.2具体实现</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="1-什么是sat问题">1 什么是SAT问题？</h1>
<h2 id="11-sat问题简介">1.1 SAT问题简介</h2>
<p> SAT问题即命题逻辑公式的可满足性问题（satisfiability problem），是计算机科学与人工智能基本问题，是一个典型的NP完全问题，可广泛应用于许多实际问题如硬件设计、安全协议验证等，具有重要理论意义与应用价值。SAT问题也是程序设计与竞赛的经典问题。<br>
对于任一布尔变元x，x与其非“¬x”称为<strong>文字(literal)</strong>。对于多个布尔变元，若干个文字的或运算l1∨l2∨…∨lk称为<strong>子句(clause)</strong>。只含一个文字的子句称为<strong>单子句</strong>。不含任何文字的子句称为<strong>空子句</strong>，常用符号□表示。子句所含文字越多，越易满足，空子句不可满足。<br>
 SAT问题一般可描述为：给定布尔变元集合{x1, x2, ..., xn}以及相应的子句集合{c1, c2, ..., cm}，对于合取范式（CNF范式）：F = c1∧c2∧...∧cm，判定是<strong>否存在对每个布尔变元的一组真值赋值使F为真</strong>，当为真时（问题是可满足的，SAT），输出对应的变元赋值（一组解）结果。<br>
   简单来说，CNF范式包含若干字句，且需要<strong>每个字句都为真</strong>，而字句为真的条件是子句中<strong>存在为真的文字</strong>。<br>
 一个CNF SAT公式或算例的具体信息通常存储在一个cnf文件中，例如<br>
c    clause length = 3<br>
c<br>
p cnf 20 91<br>
4 -18 19 0<br>
3 18 -5 0<br>
-5 -8 -15 0<br>
在每个CNF文件的开始，由‘c’开头的是若干注释说明行；‘p’开头的行说明公式的总体信息，包括：范式为CNF；公式有20个布尔变元，由1到20的整数表示，91个子句。之后每行对应一个子句，0为结束标记。4表示第4号变元，且为正文字；-5则是5号变元对应对应的负文字，文字之间以空格分隔。注意，这里的数字仅代表布尔变元编号，而不是其值。<br>
 一个CNF公式也可以表示成子句集合的形式：S = {c1, c2, ..., cm}.<br>
例如，由三个布尔变元a, b, c所形成的一个CNF公式（¬a∨b）∧（¬b∨c）,可用集合表示为{¬a∨b, ¬b∨c}，该公式是满足的，a=0, b=0,c=1是其一组解。</p>
<h2 id="12-数据结构设置">1.2 数据结构设置</h2>
<p>不难想到，一个CNF范式可以由一个二维数组表示，二维数组的每一行表示一个字句，由于无法知道每个字句包含的文字数量，故采用vector容器<br>
然后lz写完后发现课设要求“数据结构不要使用C++现有的vector等类库”，那么首先先自己写（ai写）一个vector类吧</p>
<h3 id="121-vector类">1.2.1 vector类</h3>
<pre><code class="language-c++">#include &lt;algorithm&gt; // for std::copy
#include &lt;stdexcept&gt; // for std::out_of_range

template &lt;class T&gt;
class vector {
public:
    // 数据
    T* data;
    // 大小
    int Size;
    // 容量
    int capacity;

    // 构造函数
    vector();

    // 析构函数
    ~vector();
	//含参构造函数(初始化大小,元素)
	vector(int n, T t) ;
    // 拷贝构造函数
    vector(const vector&amp; v) ;

    // 赋值运算符
    vector&amp; operator=(const vector&amp; v);

    // 添加元素
    void push_back(T t);

    // 删除元素
	void pop_back(); // 删除最后一个元素
    
    // 返回大小
    int size() const;

    // 返回元素（非 const 版本）
    T&amp; operator[](int index);

    // 返回元素（const 版本）
    const T&amp; operator[](int index) const;

    //判断是否为空
	bool empty();

    //清空
	void clear();
    // 调整容量
    void resize(int new_capacity);
     // 迭代器类
 class iterator {
};
     // 常量迭代器类
    class const_iterator {
};
}
</code></pre>
<h2 id="122-literal类">1.2.2 Literal类</h2>
<p><s>其实这个类没什么必要</s>，但是为了整齐还是写了，<s>实际上成员函数都没什么用</s></p>
<pre><code class="language-c++">class Literal
{
public:
	//布尔变量
	int var;
	Literal();
	//构造函数
	Literal(int var);
	//析构函数
	~Literal();
	//是否是负文字
	bool isNegative();
	//返回绝对值
	int getAbs();
	//打印文字
	void print();
	//不等号重载
	bool operator!=(const Literal&amp; l)const;
	//等号重载
	bool operator==(const Literal&amp; l)const;
};
</code></pre>
<h2 id="123-clause类">1.2.3 Clause类</h2>
<p>字句由若干文字组成，根据后续DPLL算法的思想（单子句和分裂策略），设置了如下成员函数</p>
<pre><code class="language-c++">class Clause
{
public:
	//文字集合
	vector&lt;Literal&gt; literals;
	//构造函数
	Clause();
	//析构函数
	~Clause();
	//添加文字
	void addLiteral(Literal l);
	//删除所有特定文字
	void removeLiteral(const Literal&amp; l);
	//打印子句
	void print();
	//判断是否是单子句
	bool isUnit()const;

};
</code></pre>
<h2 id="124-cnf类">1.2.4 CNF类</h2>
<p>一个CNF公式可以表示成子句集合的形式,根据DPLL思想，设置如下成员函数</p>
<pre><code class="language-c++">class CNF
{
public:
	//子句集合
	vector&lt;Clause&gt; clauses;
	//构造函数
	CNF();
	//添加子句
	void addClause(Clause c);
	//移除所有包含单子句L的子句
	void removeClause(const Clause&amp; clause);
	//移除剩下所有子句中的~L
	void removeLiteral(const Literal&amp; L);
	bool isEmpty() const {
		return clauses.empty();
	}
	bool hasNext() const {
		// 如果列表中至少有一个子句，且不是空子句，则返回true
		return !clauses.empty() &amp;&amp; !clauses[0].literals.empty();
	}
	void print();
};
</code></pre>
<h1 id="2-什么是dpll算法">2 什么是DPLL算法？</h1>
<p>DPLL算法是基于树/二叉树的回溯搜索算法，主要使用两种基本处理策略：</p>
<h2 id="21-单子句规则">2.1 单子句规则</h2>
<p>单子句规则。如果子句集S中有一个单子句L,那么L一定取真值，于是可以从S中删除所有包含L的子句（包括单子句本身），得到子句集S1，如果它是空集，则S可满足。否则对S1中的每个子句，如果它包含文字¬L(因为它为假）,则从该子句中去掉这个文字，这样可得到子句集合S2。S可满足当且仅当S2可满足。单子句传播策略就是反复利用单子句规则化简S的过程。<br>
<font color=Blue><strong>即去掉包含L的字句，并去掉剩下子句中的¬L文字</strong></font><br>
故在DPLL函数中，可优先寻找单子句进行传播</p>
<pre><code class="language-c++"> while (true) {
        bool unitClauseFound = false;
        for (int i = 0; i &lt; cnf.clauses.size(); ++i) {
            const Clause&amp; clause = cnf.clauses[i];
            if (clause.isUnit()) {
                //如果是单子句，传播
                Literal unitLiteral = clause.literals[0];//取出单子句的文字
                if (!propagate(cnf, unitLiteral, assignments)) {
                    return false;//如果传播失败，返回false
                }
              
                unitClauseFound = true;

                break;
            }
        }
</code></pre>
<h2 id="22-分裂策略">2.2 分裂策略</h2>
<h3 id="221-分裂策略概念">2.2.1 分裂策略概念</h3>
<p>按<strong>某种策略</strong>选取一个文字L.如果L取真值，则根据单子句传播策略，可将S化成S2；若L取假值（即¬L成立）时，S可化成S1.<br>
交错使用上述两种策略可不断地对公式化简，并最终达到终止状态，其执行过程可表示为一棵二叉搜索树,如下图所示。<br>
<img src="https://img2024.cnblogs.com/blog/3507821/202409/3507821-20240907114939000-758044065.png#pic_center" alt="" width="200" height="300" loading="lazy"><br>
基于单子句传播与分裂策略的DPLL算法可以描述为一个如后所示的递归过程DPLL( S ), DPLL算法也可用非递归实现。</p>
<pre><code class="language-c++">DPLL( S) :
/* S为公式对应的子句集。若其满足，返回TURE；否则返回FALSE. */
{
while(S中存在单子句) {//单子句传播
在S中选一个单子句L；
依据单子句规则，利用L化简S；
if S = Φ return(TRUE);
else if (S中有空子句 ) return（FALSE）；
}//while
基于某种策略选取变元v；         //策略对DPLL性能影响很大
if DPLL（S ∪v ）return(TURE);  //在第一分支中搜索
return DPLL(S ∪¬v);//回溯到对v执行分支策略的初态进入另一分支
}
</code></pre>
<h3 id="222-分裂传播函数">2.2.2 分裂（传播）函数</h3>
<p>这里的assignments是用来记录赋值状态(由于课程要求将可满足时的结果保存到.res文件中），后续会谈到</p>
<pre><code class="language-c++">bool propagate(CNF&amp; cnf, const Literal&amp; literal,int *assignments) 
{
    //待更新
</code></pre>
<h2 id="23-读取cnf文件">2.3 读取cnf文件</h2>
<p>课设要求读取cnf算例文件，解析文件，基于一定的物理结构，建立公式的内部表示；并实现对解析正确性的验证功能，即遍历内部结构逐行输出与显示每个子句，与输入算例对比可人工判断解析功能的正确性。<br>
cnf文件的格式示例请见上文</p>
<h3 id="231-打开文件">2.3.1 打开文件</h3>
<p>这里用C++实现，同时，因为程序可能需要反复读入不同的cnf文件，这里对CNF进行清空操作</p>
<pre><code class="language-c++">  ifstream file(filename);
        std::string line;
``
		if (!file.is_open())//打开文件失败
        {
			cerr &lt;&lt; &quot;打开文件: &quot; &lt;&lt; filename &lt;&lt;&quot;失败&quot;&lt;&lt; endl;//输出错误信息
            return false;
        }
   //调试     else
   //     {
			//printf(&quot;File opened successfully\n&quot;);//打开文件成功
   //     }
        if (!cnf.isEmpty())//如果CNF不为空
        {
			cnf.clauses.clear();//清空CNF
        }
</code></pre>
<h3 id="232-读取内容">2.3.2 读取内容</h3>
<h4 id="2321-getline函数">2.3.2.1 getline函数</h4>
<pre><code>//定义
_EXPORT_STD template &lt;class _Elem, class _Traits, class _Alloc&gt;
basic_istream&lt;_Elem, _Traits&gt;&amp; getline(
    basic_istream&lt;_Elem, _Traits&gt;&amp; _Istr, basic_string&lt;_Elem, _Traits, _Alloc&gt;&amp; _Str) {
    // get characters into string, discard newline
    return _STD getline(_STD move(_Istr), _Str, _Istr.widen('\n'));
}
</code></pre>
<h5 id="函数语法结构">函数语法结构：</h5>
<p>在&lt; string &gt;中的getline函数有四种重载形式：</p>
<pre><code>1 istream&amp; getline (istream&amp;  is, string&amp; str, char delim);
2 istream&amp; getline (istream&amp;&amp; is, string&amp; str, char delim);
3 istream&amp; getline (istream&amp;  is, string&amp; str);
4 istream&amp; getline (istream&amp;&amp; is, string&amp; str);
</code></pre>
<h5 id="函数的变量">函数的变量：</h5>
<pre><code>is ：表示一个输入流，例如 cin。
str ：string类型的引用，用来存储输入流中的流信息。
delim ：char类型的变量，所设置的截断字符；在不自定义设置的情况下，遇到’\n’，则终止输入
</code></pre>
<p>该部分转载自CSDN博主Faith_xzc<a href="https://blog.csdn.net/weixin_44480968/article/details/104282535">原文链接</a></p>
<h4 id="2322-istringstream类">2.3.2.2 istringstream类</h4>
<p>注意包含头文件 #include <sstream></p>
<pre><code>//定义
_EXPORT_STD using istringstream = basic_istringstream&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt;&gt;;
</code></pre>
<p>istringstream 是 basic_istringstream 的一个特化版本，针对 char 类型的字符，使用标准的字符特征类和分配器类。这样可以确保 istringstream 适合处理标准的 char 类型的字符串。</p>
<p>在C++中，std::istringstream 是 std::basic_istringstream 的一个具体实例，用于从字符串中提取数据。基于流提取操作符 &gt;&gt;，它能够从 istringstream 对象中逐个提取数据并赋值给相应的变量。</p>
<p>因此，实现代码如下（这里仅展示读取第一行）,注意到首行的p cnf是我们不需要的数据，因此设置一个临时string format将它们读取掉</p>
<pre><code class="language-c++">	while (std::getline(file, line)) // 逐行读取文件
        {
			//cout &lt;&lt; line &lt;&lt; endl;
            istringstream iss(line);
			
            if (line[0] == 'c' || line.empty()) {
                continue; // 忽略注释和空行
            }

            if (line[0] == 'p') {
				string format;//读取掉p cnf
				iss &gt;&gt; format &gt;&gt; format &gt;&gt; NumVars &gt;&gt; NumClauses;//读取变量数和子句
                //调试 cout &lt;&lt; numVars &lt;&lt; &quot; &quot; &lt;&lt; numClauses &lt;&lt; endl; 
            }
            else{  
                     //  读取字句   
            }
}
</code></pre>
<p>配合getline函数，还可以实现多样的分割操作，详情请见<a href="https://www.cnblogs.com/flix/p/13594908.html">使用 istringstream 根据分隔符来分割字符串</a></p>
<h2 id="24-dpll具体实现">2.4 DPLL具体实现</h2>
<h3 id="241-传播函数">2.4.1 传播函数</h3>
<pre><code class="language-c++">/***********************************************
*函数名称：propagate
* 函数功能：根据给定的文字（literal）对 CNF 公式进行传播，更新 CNF 公式和赋值数组。
* 注释：- 遍历 CNF 公式中的所有子句。
        - 检查子句是否已被给定文字（literal）满足。
        - 如果子句已被满足，则忽略该子句。
        - 如果子句未被满足，删除子句中与给定文字相反的文字。
        - 如果删除文字后子句为空，则返回 False，表示冲突。
        - 如果子句非空，将其添加到新的 CNF 公式中。
        - 更新赋值数组以记录文字的赋值。
* 返回值：bool 类型，如果传播成功，则返回 True，若出现空子句，则返回 False。
************************************************/
bool propagate(CNF&amp; cnf, const Literal&amp; literal,int *assignments) {
    //待更新
}
</code></pre>
<h3 id="242-选择策略">2.4.2 选择策略</h3>
<p>以下列出的是一些简单的决策方法<br>
更多决策策略可见<a href="https://kns.cnki.net/kcms2/article/abstract?v=-4s28oSk47_7eHMwEzm3L8wfX3yKJX2gpjM6Khfd95jZpfW4bD_3CKKNHdkeABT0ZVjnYLuS17REiQgkvzDDCUBKDQVsH4td9hm_vbf0C3SRpDUC9GB02ov41G7vHwzswscE7JbcGax2MCRZB2LkRbqFr7bj1jgqH9FqN8p4ESXZmNtEQfxcywZze5IIfniJCFMdSXUX3TssrqypXTxnlGwMmKYZYXCt8noUgbAKI0UPykj-j7zDUA==&amp;uniplatform=NZKPT&amp;language=CHS">基于DPLL的SAT算法的研究及应用</a></p>
<h4 id="2421-选择第一个文字">2.4.2.1 选择第一个文字</h4>
<pre><code class="language-c++">   if (way == 2) 
   {
       if (!cnf.clauses.empty() &amp;&amp; !cnf.clauses[0].literals.empty()) //如果子句不为空
       {
           return cnf.clauses[0].literals[0];
       }
   }
</code></pre>
<h4 id="2422-随机选取文字">2.4.2.2 随机选取文字</h4>
<p>先随机找一个非空子句，再随机找一个文字<br>
虽然在大部分情况下效率低下，但也有小概率随机到有价值的决策变量（<s>其实就是想水一个策略出来</s>）</p>
<pre><code class="language-c++"> else if (way == 1)
 {
        
     // 找到一个非空子句
     int clauseIndex = rand() % cnf.clauses.size();
     while (cnf.clauses[clauseIndex].literals.empty()) {
         clauseIndex = rand() % cnf.clauses.size();
     }

     // 选择子句中的一个文字
     int literalIndex = rand() % cnf.clauses[clauseIndex].literals.size();
     return cnf.clauses[clauseIndex].literals[literalIndex];
 }
</code></pre>
<h4 id="2423-选择出现最多的文字">2.4.2.3 选择出现最多的文字</h4>
<h4 id="2424-选择短子句中出现最多的文字">2.4.2.4 选择短子句中出现最多的文字</h4>
<h3 id="243-dpll函数">2.4.3 DPLL函数</h3>
<pre><code class="language-c++">/***********************************************
*函数名称：DPLL
* 函数功能：使用 DPLL 算法对给定的 CNF 公式进行求解。
* 注释：- 不断查找单子句，并进行传播。
        - 如果找到单子句且传播成功，则继续处理。
        - 如果 CNF 公式为空，说明所有子句都满足，返回 True。
        - 否则，选择一个文字进行分支搜索。
        - 尝试给文字赋值为真或假，并递归地调用 DPLL 函数。
        - 如果任一分支成功，则返回 True；否则，返回 False。
* 返回值：bool 类型，如果 CNF 公式可满足，则返回 True，否则返回 False。
************************************************/
 bool DPLL(CNF&amp; cnf,int way, int* assignments) {
//待更新
}
</code></pre>
<h3 id="244-打印赋值结果并保存至同名res文件">2.4.4 打印赋值结果并保存至同名.res文件</h3>
<h4 id="2441-打印赋值结果">2.4.4.1 打印赋值结果</h4>
<p>从前面的代码可以看出，assignments[i]的值为1，表示布尔变元1为真，否则(assignments[i]的值为-1，当然你也可以设置为0，以bool的类型存储数据）其负文字为真</p>
<pre><code class="language-c++"> void printAssignments(const int* assignments) {
     for (int i = 1; i &lt;= numVars; ++i) {
         if (assignments[i] == 1) {
             std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;
         }
         else if (assignments[i] == -1) {
             std::cout &lt;&lt; -i &lt;&lt; &quot; &quot;;
         }
     }
     std::cout &lt;&lt; std::endl;
 }
</code></pre>
<h4 id="2442-保存到res文件">2.4.4.2 保存到res文件</h4>
<p><strong>输出文件规范</strong></p>
<p>---对每个算例的求解结果要求输出到一个与算例同名的文件（文件扩展名为.res），文件内容与格式要求如下：<br>
---s 求解结果//1表示满足，0表示不满足，-1表示在限定时间内未完成求解<br>
---v  -1 2 -3 … //满足时，每个变元的赋值序列，-1表示第一个变元1取假，2表示第二个变元取真，用空格分开，此处为示例。<br>
---t  17     //以毫秒为单位的DPLL执行时间，可增加分支规则执行次数信息</p>
<p>这里咱没有写超时（输出-1）的处理，有大佬愿意可以补充下~~</p>
<pre><code class="language-c++">void saveResultToFile(const std::string&amp; baseFilename, bool result, const int* assignments,double duration)
{
//待更新
}
</code></pre>
<h1 id="3-数独游戏">3 数独游戏</h1>
<h2 id="31-数独游戏格局的生成与归约">3.1 数独游戏格局的生成与归约</h2>
<p> 普通数独游戏要求在9×9的网格中每个单元（cell）填入1至9的一个数字，必须满足三种约束：每一行、每一列及9个3×3的盒子中的数字都不重复。<br>
 一个数独游戏初始时已经提供了一些提示数，要求在剩下的空格中填满数字。初始游戏格局要求只有唯一解（一般至少要有17个提示数），基于推理可以求解。如何生成一个有效的数独游戏格局？一种方案可以从互联网或数独文件读取不少于50个不同的初始合法格局（此生成设计计分评定为良）；另一种方案是设计一种算法自动生成（此生成设计计分评定为优），一般可采用从完整合法填充开始，基于挖洞法生成。<br>
 对角线数独游戏[12-13]是一种变型的数独，即在上述普通数独的基础上又增加了一类约束：<strong>对角线约束</strong>，如图2.4所示。对角线约束要求在两条对角线（撇对角线与捺对角线）上的数字也不能重复。<br>
<img src="https://img2024.cnblogs.com/blog/3507821/202409/3507821-20240909181340373-2049152185.png#pic_center" alt="" width="480" height="240" loading="lazy"></p>
<h2 id="32-自动生成数独棋盘">3.2 自动生成数独棋盘</h2>
<h3 id="321-生成完整数独棋盘">3.2.1 生成完整数独棋盘</h3>
<p>参考自<a href="https://blog.csdn.net/M1170780140/article/details/128053901">DPLL算法求解CNF-SAT与数独求解程序</a><br>
以及  <a href="https://blog.csdn.net/nibiewuxuanze/article/details/47679927">随机数独局面生成</a></p>
<p>采用了类似八皇后问题的<strong>递归回溯</strong>思想，即根据目前的状态，放置一个数，如果递归后返回false，则进行回溯。<br>
如果从空棋盘开始遍历，该算法会永远将第一行填成123456789，因此我们需要先随机生成第一行（当然你也可你考虑其它方案），<br>
再根据第一行的情况求解整个棋盘</p>
<h3 id="322-挖洞法生成游戏棋盘">3.2.2 挖洞法生成游戏棋盘</h3>
<p>以下内容来源于<s>ChatGPT-4o-mini</s></p>
<pre><code class="language-c++">int generateGameBoard(const vector&lt;int&gt;&amp; normalBoard, vector&lt;int&gt;&amp; gameBoard) {
	
    // 随机挖去的数字数量
    int numToRemove = 35 + rand() % 13;

    // 复制 normalBoard 到 gameBoard
    gameBoard = normalBoard;

    // 创建索引数组
    vector&lt;int&gt; indices(81,0);
    for (int i = 0; i &lt;81; ++i) {
        indices[i] = i;
    }
   
    // 打乱索引数组
    shuffleArray(indices);

    // 挖去数字
    for (int i = 0; i &lt; numToRemove; ++i) {
        gameBoard[indices[i]] = 0; // 0 表示空白
    }
    return numToRemove;
}
</code></pre>
<h3 id="33-转化为sat问题">3.3 转化为SAT问题</h3>
<h4 id="331-转化方案">3.3.1 转化方案</h4>
<p>本课程设计要求利用DPLL SAT求解算法对对角线数独游戏进行求解，因此首先必须理解如何将普通数独游戏转化（归约）为SAT问题，并把它表示为CNF公式的形式。这里要考虑三个问题：<br>
（1）如何定义问题的BOOL变元？<br>
（2）如何用CNF的子句集表示数独游戏的三种约束？<br>
（3）如何表示游戏格局中的提示数条件？下面分别给出一种方案供参考。<br>
变元可按语义编码为1～9之间数字构成的三位整数ijk，i, j, k∈{1,2,…,9}，其中i表示单元格的行号，j表示单元格的列号，k表示单元格&lt;i, j&gt;填入的数字为k。如163变元表示第1行6列填入3；负文字 -452表示第4行5列不填入2。这样编码共有729个变元。<br>
数独游戏的基本要求是：每个单元格只能填入1～9之间唯一一个数字，称之为“格约束”。以单元格&lt;1,1&gt;例，这可以表示为如下子句：</p>
<p>111 112 113 114 115 116 117 118 119 0 //单元格（1，1）必须填入1-9中的一个数<br>
-111 -112 0<br>
-111 -113 0<br>
……<br>
-118 -119 0//不能重复，这里共有（1+2+……+8)个子句<br>
121 122 123 124 …… ////单元格（1，2）必须填入1-9中的一个数</p>
<p>上述表示中，每个子句的末尾的0表示结束标记；第一个子句的含义是单元格&lt;1,1&gt;可填入至少一个数字；后面的子句集共同表示只能填入一个数字，子句-111 -112 0表示不能同时填1与2；其它类推。按这种方式需要对81个单元格进行类似表示，得到对应的子句集。<br>
行约束要求每行需要填入1～9中的每个数字，且每个数字只出现一次。以第1行为例可表示为（此处在每个子句后加入注释，说明子句的含义）：<br>
111 121 131 141 151 161 171 181 191 0     第1行含有1<br>
112 122 132 142 152 162 172 182 192 0     第1行含有2<br>
… …<br>
119 129 139 149 159 169 179 189 199 0     第1行含有9<br>
-111 -121 0             前两格不同时为1<br>
-111 -131 0             第1与第3格不同时为1<br>
… …<br>
-111 -191 0             第1与第9格不同时为1<br>
… …<br>
列约束仿照行约束易于表示为对应子句集，同学们可自行写出。<br>
对于3×3的盒子约束，以左上角的盒子为例进行说明，其子句集可表示如下：<br>
111 121 131 211 221 231 311 321 331 0   包含1<br>
112 122 132 212 222 232 312 322 332 0   包含2<br>
… …<br>
119 129 139 219 229 239 319 329 339 0   包含9<br>
-111 -211 0        11格与21格不同时为1<br>
-111 -311 0        11格与31格不同时为1<br>
-111 -121 0        11格与12格不同时为1<br>
… …<br>
最后，对于每个具体的数独游戏，已经填入了部分提示数，如图2.3中的左图，每个提示数可表示为一个单子句，如第2行3列填入5，对应单子句如下：<br>
235 0<br>
SAT公式CNF文件中，一般变元是从1进行连续编码的，可以将上述语义编码转换为自然顺序编码，公式为：ijn → (i-1)*81+(j-1)*9+n；当按自然编码对数独游戏对应的CNF公式求解后，可设计逆变换公式将解解析为对应的游戏填充方案，完成填充，或给游戏玩家给予每一步填充的正误提示。<br>
根据上面的分析，数独约束生成CNF子句集易于用<strong>多重循环</strong>结构实现。</p>
<h4 id="332具体实现">3.3.2具体实现</h4>
<p>建议直接~~<strong>打表</strong>~~<br>
行列的代码较易写出，以下仅列出对角线部分和九宫格部分的转化代码。<br>
通用的约束子句集请见<a href="https://github.com/HJNODM/DPLL-SAT-Solver">github</a>，注意删去数独上已有数产生的约束子句）<br>
本项目中将该通用部分放到了资源文件中，后续只需在后追加由数独棋盘上已有数产生的约束条件</p>
<pre><code class="language-c++">bool XSudokuToCnf(const vector&lt;int&gt;&amp; board, int empty)
{
//待更新
|
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[23级思修大题重点]]></title>
        <id>https://Ilosyi.github.io/post/23-ji-si-xiu-da-ti-chong-dian/</id>
        <link href="https://Ilosyi.github.io/post/23-ji-si-xiu-da-ti-chong-dian/">
        </link>
        <updated>2024-08-23T12:59:13.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E4%B8%BB%E8%A7%82%E9%A2%98%E9%83%A8%E5%88%86">主观题部分</a>
<ul>
<li><a href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%9C%A8%E5%AE%9E%E7%8E%B0%E4%B8%AD%E5%9B%BD%E6%A2%A6%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%B8%AD%E6%94%BE%E9%A3%9E%E9%9D%92%E6%98%A5%E6%A2%A6%E6%83%B3">第二章第三节 在实现中国梦的实践中放飞青春梦想</a>
<ul>
<li><a href="#1%E5%A6%82%E4%BD%95%E8%AE%A4%E8%AF%86%E7%90%86%E6%83%B3%E4%B8%8E%E7%8E%B0%E5%AE%9E%E7%9A%84%E8%BE%A9%E8%AF%81%E7%BB%9F%E4%B8%80%E5%85%B3%E7%B3%BB">1.如何认识理想与现实的辩证统一关系？</a></li>
<li><a href="#2%E5%BD%93%E4%BB%A3%E9%9D%92%E5%B9%B4%E5%BA%94%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%90%86%E6%83%B3">2.当代青年应如何实现理想？</a></li>
<li><a href="#3%E4%BB%8E%E4%B8%AA%E4%BA%BA%E7%90%86%E6%83%B3%E5%92%8C%E7%A4%BE%E4%BC%9A%E7%90%86%E6%83%B3%E8%BE%A9%E8%AF%81%E5%85%B3%E7%B3%BB%E7%9A%84%E8%A7%92%E5%BA%A6%E8%B0%88%E8%B0%88%E9%9D%92%E5%B9%B4%E4%B8%80%E4%BB%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%A0%91%E7%AB%8B%E5%85%B1%E5%90%8C%E5%92%8C%E8%BF%9C%E5%A4%A7%E7%90%86%E6%83%B3">3.从个人理想和社会理想辩证关系的角度，谈谈青年一代为什么要树立共同和远大理想。</a></li>
<li><a href="#4%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%BA%94%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%BA%E5%AE%9E%E7%8E%B0%E4%B8%AD%E5%9B%BD%E6%A2%A6%E6%B3%A8%E5%85%A5%E9%9D%92%E6%98%A5%E8%83%BD%E9%87%8F%E8%82%A9%E8%B4%9F%E8%B4%A3%E4%BB%BB%E6%94%BE%E9%A3%9E%E9%9D%92%E6%98%A5%E6%A2%A6%E6%83%B3%E7%AD%89">4.大学生应如何做为实现中国梦注入青春能量（肩负责任，放飞青春梦想等）</a></li>
<li><a href="#1%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E6%98%AF%E5%BD%93%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%9A%84%E6%98%BE%E8%91%97%E7%89%B9%E5%BE%81">1.改革开放是当代中国的显著特征</a></li>
<li><a href="#2%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%94%B9%E9%9D%A9%E5%88%9B%E6%96%B0">2.新时代下，为什么要改革创新？</a></li>
<li><a href="#3%E6%96%B0%E6%97%B6%E4%BB%A3%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%BA%94%E5%A6%82%E4%BD%95%E5%BC%98%E6%89%AC%E6%94%B9%E9%9D%A9%E5%88%9B%E6%96%B0%E7%B2%BE%E7%A5%9E%E5%81%9A%E6%94%B9%E9%9D%A9%E5%88%9B%E6%96%B0%E7%94%9F%E5%8A%9B%E5%86%9B%E9%87%8D%E7%82%B9">3.新时代大学生应如何弘扬改革创新精神，做改革创新生力军？（<em>重点</em>）</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%AC%E4%BA%8C%E8%8A%82-%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC%E8%A7%82%E7%9A%84%E6%98%BE%E8%91%97%E7%89%B9%E5%BE%81">第四章第二节 社会主义核心价值观的显著特征</a>
<ul>
<li><a href="#1%E5%8F%8D%E6%98%A0%E4%BA%BA%E7%B1%BB%E7%A4%BE%E4%BC%9A%E5%8F%91%E5%B1%95%E8%BF%9B%E6%AD%A5%E7%9A%84%E4%BB%B7%E5%80%BC%E7%90%86%E5%BF%B5%E5%85%88%E8%BF%9B%E6%80%A7">1.反映人类社会发展进步的价值理念（先进性）</a></li>
<li><a href="#2%E5%BD%B0%E6%98%BE%E4%BA%BA%E6%B0%91%E8%87%B3%E4%B8%8A%E7%9A%84%E4%BB%B7%E5%80%BC%E7%AB%8B%E5%9C%BA%E4%BA%BA%E6%B0%91%E6%80%A7">2.彰显人民至上的价值立场（人民性）</a></li>
<li><a href="#3%E5%9B%A0%E7%9C%9F%E5%AE%9E%E5%8F%AF%E4%BF%A1%E8%80%8C%E5%85%B7%E6%9C%89%E5%BC%BA%E5%A4%A7%E7%9A%84%E9%81%93%E4%B9%89%E5%8A%9B%E9%87%8F%E7%9C%9F%E5%AE%9E%E6%80%A7">3.因真实可信而具有强大的道义力量（真实性）</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%AC%AC%E4%B8%80%E8%8A%82-%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E9%81%93%E5%BE%B7%E7%9A%84%E6%A0%B8%E5%BF%83%E4%B8%8E%E5%8E%9F%E5%88%99">第五章第一节 社会主义道德的核心与原则</a>
<ul>
<li><a href="#1%E9%81%93%E5%BE%B7%E7%9A%84%E8%B5%B7%E6%BA%90%E5%92%8C%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88">1.道德的起源和本质是什么？</a></li>
<li><a href="#2%E9%81%93%E5%BE%B7%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9F%E8%83%BD%E5%92%8C%E4%BD%9C%E7%94%A8">2.道德有什么功能和作用？</a></li>
<li><a href="#3%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E9%81%93%E5%BE%B7%E6%98%AF%E5%B4%AD%E6%96%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%81%93%E5%BE%B7%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E9%81%93%E5%BE%B7%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%E5%85%88%E8%BF%9B%E6%80%A7%E7%89%B9%E5%BE%81">3.为什么说社会主义道德是崭新类型的道德，社会主义道德具有哪些先进性特征？</a></li>
<li><a href="#4%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E9%81%93%E5%BE%B7%E7%9A%84%E6%A0%B8%E5%BF%83%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88">4.社会主义道德的核心是什么？为什么？</a></li>
<li><a href="#5%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E5%B8%82%E5%9C%BA%E7%BB%8F%E6%B5%8E%E6%9D%A1%E4%BB%B6%E4%B8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BB%A7%E7%BB%AD%E5%9D%9A%E6%8C%81%E9%9B%86%E4%BD%93%E4%B8%BB%E4%B9%89%E5%8F%8D%E5%AF%B9%E4%B8%AA%E4%BA%BA%E4%B8%BB%E4%B9%89%E9%9B%86%E4%BD%93%E4%B8%BB%E4%B9%89%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B1%82%E6%AC%A1%E6%80%A7">5.社会主义市场经济条件下，为什么要继续坚持集体主义，反对个人主义？集体主义具有哪些层次性？</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%AC%AC%E4%B8%89%E8%8A%82-%E7%BB%B4%E6%8A%A4%E5%AE%AA%E6%B3%95%E6%9D%83%E5%A8%81">第六章第三节 维护宪法权威</a>
<ul>
<li><a href="#1%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%88%91%E5%9B%BD%E5%AE%AA%E6%B3%95%E7%9A%84%E5%9C%B0%E4%BD%8D%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99">1.如何理解我国宪法的地位和基本原则？</a></li>
<li><a href="#2%E5%9B%9E%E9%A1%BE%E6%88%91%E5%9B%BD%E5%AE%AA%E6%B3%95%E5%8F%91%E5%B1%95%E5%8F%B2%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%87%BA%E4%BB%80%E4%B9%88%E7%BB%93%E8%AE%BA">2.回顾我国宪法发展史，可以得出什么结论？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<br>
2023级思想道德与法治期末复习提纲<br>
（根据老师划的重点整理）by losyi</p>
<h1 id="主观题部分">主观题部分</h1>
<h2 id="第二章第三节-在实现中国梦的实践中放飞青春梦想">第二章第三节 在实现中国梦的实践中放飞青春梦想</h2>
<h3 id="1如何认识理想与现实的辩证统一关系">1.如何认识理想与现实的辩证统一关系？</h3>
<p>理想与现实是对立统一的。<br>
(1)理想和现实存在着对立的一面，它们不等同，二者的矛盾和冲突，属于“应然”和“实然”的矛盾。<br>
(2)理想和现实又是统一的。理想受现实的规定和制约，是在对现实认识的基础上发展起来的。一方面，现实中包含着理想的因素，孕育着理想的发展；另一方面，理想中也包含着现实，既包含着现实中必然发展的因素，又包含着理想转化为现实的条件，在一定的条件下，理想就可以转化为未来的现实。脱离现实的理想会成为空想。</p>
<h3 id="2当代青年应如何实现理想">2.当代青年应如何实现理想？</h3>
<p>(1)要认识到实现理想的长期性，艰巨性，曲折性。理想变为现实不是一帆风顺的，如果把实现理想设想得过分容易，对前进道路上的困难缺乏思想准备，那就会影响理想的实现。<br>
(2)艰苦奋斗是实现理想的必要条件。对于当代青年来说，理想的实现必须通过实践才能转变为现实。大学生要把敢于吃苦，用于奋斗的精神落实到日常的学习、生活和工作中。在学习上，刻苦钻研，不畏艰难，孜孜不倦地学习理论和专业知识，不断提高思想道德和专业知识水平；在生活上，艰苦朴素，勤俭节约，抵制和反对铺张奢华的思想和生活作风；在工作上，奋发图强、不怕困难、不避艰险，努力完成各项任务。</p>
<h3 id="3从个人理想和社会理想辩证关系的角度谈谈青年一代为什么要树立共同和远大理想">3.从个人理想和社会理想辩证关系的角度，谈谈青年一代为什么要树立共同和远大理想。</h3>
<p>(1)个人理想是指处于一定历史条件和社会关系中的个体对于自己未来的物质生活、精神生活所产生的向往和追求。社会理想是指社会集体乃至社会全体成员的共同理想，即在全社会占主导地位的共同奋斗目标。<br>
(2)个人理想与社会理想的关系实质上是个人与社会关系在理想层面的反映。<br>
①　个人理想以社会理想为指引。追求个人理想的实践活动都是在社会中进行的，个人理想的确立要顺应社会发展的客观规律和趋势要求；个人理想的实现要担当时代赋予的社会责任和历史使命。个人理想的确立要以社会理想为导向，个人理想的实现依赖于社会理想的指引。个人理想只有同国家的前途、民族的命运相结合，个人的向往和追求只有同社会的需要和人民的利益相一致，才可能变为现实。<br>
②　社会理想是对个人理想的凝练和升华。社会理想归根到底要靠全体社会成员的共同努力来实现，并具体体现在每个社会成员为实现个人理想而进行的活生生的实践中。当社会理想同个人理想有矛盾冲突的时候，有志气、有抱负的人可以作出最大的自我牺牲，使个人的理想服从全社会的共同理想。<br>
(3)个人只有把人生理想融入国家和民族的事业中才能最终成就一番事业。大学生对自己未来生活的追求和向往，不能脱离当代中国的社会现实。大学生要在社会理想的指引下，珍惜韶华、奋发有为，勇于追求个人理想，在实现社会理想的过程中努力实现个人理想。</p>
<h3 id="4大学生应如何做为实现中国梦注入青春能量肩负责任放飞青春梦想等">4.大学生应如何做为实现中国梦注入青春能量（肩负责任，放飞青春梦想等）</h3>
<p>“青年兴则国家兴，青年强则国家强。”大学生肩负实现中华民族伟大复兴的中国梦的历史重任，只有把实现理想的道路建立在脚踏实地的奋斗上，才能放飞青春梦想，实现人生理想。<br>
(1)立鸿鹄志，做奋斗者。志向，就是理想信念；立志，就是确立理想信念。青年志存高远，就能激发奋进潜力，这是关系大学生一生前途命运的重大课题。<br>
(2)心怀“国之大者”，敢于担当。新时代的大学生应该肩负历史使命，把个人命运与国家和人民的命运联系在一起，立为国奉献之志，立为民服务之志，积极投身于新时代中国特色社会主义伟大事业，让青春在为国家和人民利益的不懈奋斗中熠熠生辉。<br>
(3)自觉躬身实践，知行合一。通往理想的道路是遥远的，但起点就在脚下。大学生要牢记“空谈误国，实干兴邦”，志存高远、脚踏实地、埋头苦干，充分展现自己的抱负和激情，在“真刀实枪”的实干中成就一番事业。<br>
##第三章第三节 让改革创新成为青春远航的的动力</p>
<h3 id="1改革开放是当代中国的显著特征">1.改革开放是当代中国的显著特征</h3>
<p>(1)改革开放是当代中国最鲜明的特色。改革开放是党在新的历史条件下领导人民进行的新的伟大革命，是决定当代中国命运的关键抉择。一个国家、一个民族要振兴，就必须在历史前进的逻辑中前进、在时代发展的潮流中发展。中国特色社会主义之所以具有蓬勃生命力，就在于实行的是改革开放的社会主义。实践充分证明，改革开放是当代中国发展进步的活力之源，它只有进行时，没有完成时。<br>
(2)创新是改革开放的生命。改革开放创造的奇迹不是天上掉下来的，而是来自中国共产党和中国人民的理论创新、实践创新、制度创新、文化创新以及各方面创新。要用深邃的历史眼光、宽广的国际视野把握事物发展的本质和内在联系，立足亿万人民 的创造性实践，借鉴吸收人类一切优秀文明成果，以前所未有的积极性、主动性、创造性推进改革开放和社会主义现代化建设。</p>
<h3 id="2新时代下为什么要改革创新">2.新时代下，为什么要改革创新？</h3>
<p>改革创新是新时代的迫切要求。<br>
(1)创新决胜未来，改革关乎国运。在当代中国，经济社会发展离不开改革创新。必须将改革进行到底，进一步解放和发展社会生产力，进 一步激发和凝聚社会创造力。<br>
(2)创新是推动人类社会发展的重要力量。几个世纪以来，人类在科学技术方面取得的创新成果，英美在工业革命中抓住的机遇，表明创新深刻改变了世界发展面貌和力量格局，决定着世界政治经济力量对比的变化，也决定着各国各民族的前途命运。<br>
(3)创新能力是当今国际竞争新优势的集中体现。“在激烈的国际竞争中，惟创新者进，惟创新者强，惟创新者胜。”今天，国际竞争的新优势越来越集中体现在创新能力上，谁的创新能力强，谁就能占领先机，赢得优势。因此，创新战略竞争在综合国力竞争中的地位日益重要。<br>
(4)改革创新是赢得未来的必然要求。抓创新就是抓发展，谋创新就是谋未来。目前，虽然我国经济总量位居世界第二，但大而不强，主要体现在创新能力不强，科技发展水平总体不高，科技对经济社会发展的支撑能力不足等方面。 只有全面深化改革，坚持创新在我国现代化建设全局中的核心地位，在全社会积极营造鼓励大胆创新、勇于创新、 包容创新的良好氛围，才能把创新驱动的新引擎全速发动起来，为我国经 济社会发展提供前所未有的强劲动力。</p>
<h3 id="3新时代大学生应如何弘扬改革创新精神做改革创新生力军重点">3.新时代大学生应如何弘扬改革创新精神，做改革创新生力军？（<em>重点</em>）</h3>
<p>(1)树立改革创新的自觉意识。<br>
①　大学生要自觉增强改革创新的责任感，树立敢于突破陈规、大胆探索未知、勇于创新创造的思想观念，在实践中有直面困难的勇气，有突破难关的精神，锐意进取，奋力前行。<br>
②　要以时不我待、只争朝夕的紧迫感投身改革创新的实践，服务人民，奉献社会，实现人生价值。<br>
③　要敢于大胆突破陈规甚至常规，敢于大胆探索尝试，善于观察发 现、思考批判，不唯书、不唯上、只唯实，这是大学生在学习与实践中创 新创造的重要前提。<br>
(2)增强改革创新的能力本领。<br>
①　夯实创新基础，大学生作为改革创新的生力军，应从扎实系统的专业知识学习起步和入手，不能好高鸯远，空谈改革创新。<br>
②　培养创新思维。大学生在专业学习与社会实践中应自觉培养创新思维，勤于思考，善于发现，勇于创新。</p>
<h2 id="第四章第二节-社会主义核心价值观的显著特征">第四章第二节 社会主义核心价值观的显著特征</h2>
<h3 id="1反映人类社会发展进步的价值理念先进性">1.反映人类社会发展进步的价值理念（先进性）</h3>
<p>社会主义核心价值观具有超越以往一切社会核心价值观的先进性,它集中体现了社会主义的本质属性，扎根于中华优秀传统文化的土壤，吸收借鉴了一切人类优秀文化的先进价值，是反映人类社会发展进步的价值理念。<br>
(1)体现社会主义的本质属性。社会主义核心价值观的先进性，集中体现在它是社会主义所坚持和追求的价值理念。 社会主义核心价值观清晰地展现了社会主义的基本特征和根本追求，渗透于经济、政治、文化、社会、生态文明建设的各个方面，是我国社会主义制度的内在精神之魂。社会主义核心价值观生成于中国特色社会主义建设实践，同当今中国最鲜明的时代主题相适应，是中国特色社会主义本质规 定的价值表达。<br>
(2)扎根中华优秀传统文化土壤。中华优秀传统文化是涵养社会主义核心价值观的重要源泉是中华民族发展壮大的独特优势，也是社会主义核心价值观历史底蕴的集中体现。孝悌忠信、礼义廉耻、仁者爱人、与人为善、天人合一、道法自然、自强不息、兼爱非攻等诸多思想和理念，不论过去还是现在，都有其鲜明的民族特色，都有其永不褪色的时代价值。<br>
(3)吸纳世界文明有益成果。社会主义核心价值观在吸收人类优秀价值理念的基础上，以中国经验、中国实践为民主、自由、平等、公正、法治等价值理念赋予社会主义性质，代表了人类社会前进的方向和价值理念。</p>
<h3 id="2彰显人民至上的价值立场人民性">2.彰显人民至上的价值立场（人民性）</h3>
<p>社会主义核心价值观坚持人民历史主体地位，代表最广大人民的根本 利益，反映最广大人民的价值诉求，引导最广大人民为实现美好社会理想而奋斗。人民性是社会主义核心价值观的根本特性。<br>
(1)尊重人民群众历史主体地位。人民是中国共产党执政的最深厚基础和最大底气，人民至上是社会主义核心价值观鲜明的价值立场。<br>
(2)体现以人民为中心的价值导向。中国共产党践行全心全意为人民服务的根本宗旨，坚持人民当家作主，坚持以人民为中心的发展思想，把人民对美好生活的向往作为奋斗目标。鲜明的人民性，使得社会主义核心价值观具有强大的感召力。</p>
<h3 id="3因真实可信而具有强大的道义力量真实性">3.因真实可信而具有强大的道义力量（真实性）</h3>
<p>(1)社会主义核心价值观是真实可信的。中国特色社会主义的成功也验证了社会主义核心价值观的正确性、可信性，使 得社会主义核心价值观可以而且能够成为真切、具体、广泛的现实。<br>
(2)认清西方“普世价值”的实质。“普世价值”是一种极具迷惑性、欺骗性并且带有鲜明政治倾向的价值观。中国真诚呼吁世界各国弘扬和平、发展、公平、正义、民主、自由的全人类共同价值，促进各国人民相 知相亲，尊重世界文明多样性。这与唯我独尊、强施于人、旨在推行资本主义政治理念和制度模式的所谓“普世价值”根本不同。</p>
<h2 id="第五章第一节-社会主义道德的核心与原则">第五章第一节 社会主义道德的核心与原则</h2>
<h3 id="1道德的起源和本质是什么">1.道德的起源和本质是什么？</h3>
<p>道德是一种特殊的社会意识形态，它是以善恶为评价方式，主要依靠社会舆论、传统习俗和内心信念来发挥作用的行为规范的总和。道德是人类社会的特有现象，道德是人类社会发展到一定阶段的必然产物。<br>
(1)劳动是道德起源的首要前提。道德是人类社会的特有现象，动物的本能行为中不存在真正的道德。劳动将人与动物区分开来，创造了人、社会和社会关系，也创造了道德。劳动在创造人的同时也形成了人与人的关系。随着劳动的进一步发展，人与人之间、群体与群体之间的利益关系日渐清晰，包含自由、责任等内容的道德逐步得到确认。因此，劳动创造了人和人类社会，是道德起源的第一个历史前提。<br>
(2)社会关系是道德赖以产生的客观条件。社会关系的形成和发展产生了调节各种关系特别是利益关系的需要，可以说，道德正是适应社会关系尤其是利益关系调节的需要而产生的。<br>
(3)人的自我意识是道德产生的主观条件。意识是道德产生的思想认识前提。人只有在社会实践中，意识到自我作为社会成员与其他动物的根本区别，意识到自我在社会中的角色与地位，意识到自我与他人或集体不同的利益关系，并由此调节利益矛盾的迫切要求时，道德才得以产生。<br>
马克思主义强调，道德属于上层建筑的范畴，是一种特殊的社会意识形态。道德的本质是：<br>
(1)道德是反映社会经济关系的特殊意识形态。道德的产生、发展和变化，归根到底源于社会经济关系。首先，道德的性质和基本原则、规范反映了与之相应的社会经济关系的性质和内容。有什么样的社会经济关系，相应地就有什么样的道德。其次，道德随着社会经济关系的变化而变化。再次，道德作为一种社会意识，在阶级社会里总是反映着一定阶级的利益，因而不可避免地具有阶级性；同时，不同阶级之间的道德或多或少有一些共同之处，反映着道德的普遍性。最后，作为社会意识的道德一经产生，便有相对独立性。这种相对独立性既表现为道德的历史继承性，也表现为道德对社会发展具有能动的反作用。<br>
(2)道德是社会利益关系的特殊调节方式。是一种调整人与人、人与社会、人与自然以及人与自身之间关系的特殊行为规范。道德与法律规范、政治规范的不同之处在于它是用善恶标准去评价，依靠社会舆论、传统习俗、内心信念来维持的，因此是一种非强制性的规范。它通过社会的道德风尚和个人的道德风尚来调节利益关系。<br>
(3)道德是一种实践精神，在本质上是知行合一的。道德立足现实而追求理想，并以理想来改造和提升现实。<br>
总之，道德作为一种实践精神，是特殊的意识信念、行为准则、评价选择等方面的总和，是调节社会关系、发展个人品质、提高精神境界等活动的动力。</p>
<h3 id="2道德有什么功能和作用">2.道德有什么功能和作用？</h3>
<p>在道德的功能系统中，认识功能、规范功能、调节功能是最基本的功能。<br>
(1)道德的认识功能是指道德反映社会关系特别是反映社会经济关系的功 效与能力。道德往往运用善恶、荣辱、义务、良心等范畴，反映人类的道德实践活动和道德关系，从中揭示社会道德发展的趋势，为人们的行为选择提供指南。<br>
(2)道德的规范功能是指在正确善恶观的指引下，规范社会成员在社会公共领域、职业领域、家庭领域的行为，并规范个人品德的养成，引导并促 进人们崇德向善。<br>
(3)道德的调节功能是指道德通过评价等方式指导和纠正人们的行为和实 践活动、协调社会关系和人际关系的功效与能力。道德评价是道德调节的主要形式，社会舆论、传统习俗和人们的内心信念是道德调节所赖以发挥作用的力量。<br>
(4)道德的作用是指道德的认识、规范、调节、激励、导向、教育等功能的发挥和实现所产生的社会影响及实际效果。<br>
(5)道德作为维系社会稳定、促进国家发展的重要因素，对巩固特定社会的经济基础和上层建筑具有不可替代的重要作用。<br>
(6)同时，道德作为激励人们改造客观世界和主观世界的一种精神力量，也是提高人的精神境界、促进人的自我完善、推动人的全面发展的内在动力。<br>
道德作用的性质：道德发挥作用的性质与社会发展的不同历史阶段相联系，由道德所反映的经济基础、代表的阶级利益所决定。只有反映先进生产力发展要求和进步阶级利益的道德，才会对社会的发展和人的素质的提高产生积极的推动作用。</p>
<h3 id="3为什么说社会主义道德是崭新类型的道德社会主义道德具有哪些先进性特征">3.为什么说社会主义道德是崭新类型的道德，社会主义道德具有哪些先进性特征？</h3>
<p>社会主义道德是崭新类型的道德<br>
迄今为止，人类社会先后经历了五种基本社会形态，与此相适应，出现了原始社会的道德、<br>
奴隶社会的道德、封建社会的道德、资本主义社会的道德、社会主义社会的道德。在社会主义社会，有一部分先进分子还身体力行共产主义道德。 人类道德发展的历史过程与社会生产方式的发展进程大体一致，社会主义和共产主义道德，是人类道德合乎规律发展的必然产物，是人类道德发展史上的一种崭新类型的道德，是对人类道德传统的批判与继承，并必然随着社会的进步和实践的发展而与时俱进。<br>
与以往社会的道德形态相比，社会主义道德具有显著的先进性特征：<br>
(1)社会主义道德是社会主义经济基础的反映。<br>
(2)社会主义道德是对人类优秀道德资源的批判继承和创新发展。<br>
(3)社会主义道德克服了以往阶级社会道德的片面性和局限性，坚持以为人民服务为核心，坚持以集体主义为原则，展现出真实而强大的道义力量。</p>
<h3 id="4社会主义道德的核心是什么为什么">4.社会主义道德的核心是什么？为什么？</h3>
<p>为人民服务是社会主义道德的核心，决定并体现着道德建设的根本性质和发展方向，规定并制约着道德领域中的所有道德现象。为人民服务，不仅是坚持历史唯物主义的必然要求，是中国共产党践行的根本宗旨，也是社会主义道德观的集中体现，是全体中国人民共同遵循的道德要求。为人民服务作为社会主义道德的核心，是社会主义道德区别和优越于其他社会形态道德的显著标志。<br>
(1)为人民服务是社会主义道德的本质要求。为人民服务是社会主义经济基础和人际关系的客观要求，为人民服务是社会主义市场经济健康发展的要求。<br>
(2)为人民服务是先进性要求和广泛性要求的统一。</p>
<h3 id="5社会主义市场经济条件下为什么要继续坚持集体主义反对个人主义集体主义具有哪些层次性">5.社会主义市场经济条件下，为什么要继续坚持集体主义，反对个人主义？集体主义具有哪些层次性？</h3>
<p>在我国，国家利益、社会整体利益个人利益根本上的一致性，使得集体主义应当而且能够在全社会范围内贯彻实施。长期以来，集体主义已经成为调节国家利益、社会整体利益和个人利益关系的基本原则。<br>
(1)集体主义强调国家利益、社会整体利益和个人利益的辨证统一；<br>
(2)集体主义强调国家利益、社会利益高于个人利益；<br>
(3)集体主义重视和保障个人的正当利益。<br>
集体主义可分为三个层次：<br>
(1)一是无私奉献、一心为公。即时时处处为集体利益着想，并甘愿为集体牺牲一切。这是集体主义的最高层次，是优秀共产党员、先进分子应努力达到的道德目标。<br>
(2)二是先公后私、先人后己。即自 觉把集体利益放在个人利益之上，在维护集体利益的前提下，实现个人的正当利益。这是已经具有较高社会主义道德觉悟的人能够达到的要求，具有广泛的社会基础。<br>
(3)三是顾全大局、遵纪守法、热爱祖国、诚实劳动，以正当合法的手段保障个人利益。这是对公民最基本的道德要求。</p>
<h2 id="第六章第三节-维护宪法权威">第六章第三节 维护宪法权威</h2>
<h3 id="1如何理解我国宪法的地位和基本原则">1.如何理解我国宪法的地位和基本原则？</h3>
<p>地位：我国宪法实现了党的主张和人民意志的高度统一，具有显著优势、坚 实基础、强大生命力。宪法至上地位主要体现在其特有的作用、效力和内容等方面。<br>
(1)我国宪法是国家的根本法，是治国安邦的总章程，是党和人民意志的集中体现；<br>
(2)我国宪法是国家各项制度和法律法规的总依据；<br>
(3)我国宪法规定了国家的根本制度。<br>
基本原则：宪法的基本原则是贯穿宪法规范始终，对宪法的制定、修改、实施、 遵守等环节起指导作用的基本准则。我国宪法的基本原则集中反映了规范权力运行、保障公民权利的基本精神，体现了社会主义法治的根本性质。<br>
(1)党的领导原则:中国共产党是中国特色社会主义事业的领导核心，党的领导是人民当家做主的根本保证，是中国特色社会主义最本质的特征，是中国特色社会主义制度的最大优势。<br>
(2)人民主权原则;人民当家作主是社会主义民主政治的本质和核心。宪法体现了人民主权原则，强调国家的一切权利属于人民。<br>
(3)人权保障原则:人权是指人作为人享有和应当享有的基本权利，我国宪法规定的公民基本权利，都是最重要的人权。<br>
(4)法治原则:社会主义法治原则要求坚持宪法法律至上，法律面前人人平等，任何组织和个人都要在宪法和法律范围内活动，一切违法行为都应受到法律的追究。<br>
(5)民主集中制原则:民主集中制是我国国家组织形式和活动方式的基本原则，是我国国家制度的突出特点和优势，也是集中全党全国人民集体智慧，实现科学决策、民主决策的基本原则和主要途径。</p>
<h3 id="2回顾我国宪法发展史可以得出什么结论">2.回顾我国宪法发展史，可以得出什么结论？</h3>
<p>(1)一是制定和实施宪法，推进依法治国，建设法治国家，是实现国家富强、民族振兴、社会进步、人民幸福的必然要求。<br>
(2)二是我国现行宪法是在深刻总结我国社会主义革 命、建设、改革的成功经验基础上制定和不断完善的，是党领导人民长期奋斗的历史逻辑、理论逻辑、实践逻辑的必然结果。<br>
(3)三是只有中国共产党才能坚持立党为公、执政为民，充分发扬民主，领导人民制定出体现人民意志的宪法，领导人民实施宪法。<br>
(4)四是党高度重视发挥宪法在治国理政中的重要作用，坚定维护宪法尊严和权威，推动宪法完善和发展，这是我国宪法保持生机活力的根本原因所在。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[思想道德与法治期末复习指南]]></title>
        <id>https://Ilosyi.github.io/post/si-xiang-dao-de-yu-fa-zhi-qi-mo-fu-xi-zhi-nan/</id>
        <link href="https://Ilosyi.github.io/post/si-xiang-dao-de-yu-fa-zhi-qi-mo-fu-xi-zhi-nan/">
        </link>
        <updated>2024-08-23T12:58:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-单选题">一、单选题</h1>
<p>共10题（1*10），基本送分、</p>
<h1 id="二-多选题">二、多选题</h1>
<p>共10题（2*10），基本送分，少数题目涉及知识点可能需要记忆，建议考试前将学解考试宝典过一遍，如果老师给了选择题重点就看对应章节课本</p>
<h1 id="三-简答论述题">三、简答/论述题</h1>
<p>这部分老师会划重点，将对应章节的重点问题整理背诵即可<br>
不知道重点问题？去求助万能的<code>学数华科</code>吧</p>
<h1 id="四-材料分析题">四、材料分析题</h1>
<p>其实与前面差别不大，也是靠背诵，但会加入少量开放问题，此外，要想拿满分需要结合材料，不能只靠背诵的内容</p>
<h1 id="平时分">平时分</h1>
<h2 id="考勤">考勤</h2>
<p>不同老师考勤方法，次数不同，翘课前请自行考虑相应风险~</p>
<h2 id="作业">作业</h2>
<p>作业一般是作文，小论文，报告类<br>
想要拿高分需注意 <strong>字数</strong>（略高于要求但不要太长） <strong>格式</strong>（良好的观看体验很重要） <strong>内容</strong>(虽然基本靠GPT不过也需尽量避免AI味，注意思想的发散性，深刻性，和课本内容是否结合）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[新视野大学英语视听说教程3听力练习翻译]]></title>
        <id>https://Ilosyi.github.io/post/xin-shi-ye-da-xue-ying-yu-shi-ting-shuo-jiao-cheng-3-ting-li-lian-xi-fan-yi/</id>
        <link href="https://Ilosyi.github.io/post/xin-shi-ye-da-xue-ying-yu-shi-ting-shuo-jiao-cheng-3-ting-li-lian-xi-fan-yi/">
        </link>
        <updated>2024-08-23T12:57:37.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E8%A7%86%E5%90%AC%E8%AF%B43%E5%90%AC%E5%8A%9B%E7%BF%BB%E8%AF%91">视听说3听力翻译</a></li>
<li><a href="#unit-1">UNIT 1</a>
<ul>
<li><a href="#long-conversation">Long conversation</a></li>
<li><a href="#passage-1">Passage 1</a></li>
<li><a href="#passage-2">Passage 2</a></li>
</ul>
</li>
<li><a href="#unit-2">UNIT 2</a>
<ul>
<li><a href="#long-conversation-2">Long conversation</a></li>
<li><a href="#passage-1-2">Passage 1</a></li>
<li><a href="#passage-2-2">Passage 2</a></li>
</ul>
</li>
<li><a href="#unit-3">UNIT 3</a>
<ul>
<li><a href="#long-conversation-3">Long conversation</a></li>
<li><a href="#passage-1-3">Passage 1</a></li>
<li><a href="#passage-2-3">Passage 2</a></li>
</ul>
</li>
<li><a href="#unit-4">UNIT 4</a>
<ul>
<li><a href="#long-conversation-4">Long conversation</a></li>
<li><a href="#passage-1-4">Passage 1</a></li>
<li><a href="#passage-2-4">Passage 2</a></li>
</ul>
</li>
<li><a href="#unit-5">UNIT 5</a>
<ul>
<li><a href="#long-conversation-5">Long conversation</a></li>
<li><a href="#passage-1-5">Passage 1</a></li>
<li><a href="#passage-2-5">Passage 2</a></li>
</ul>
</li>
<li><a href="#unit-6">UNIT 6</a>
<ul>
<li><a href="#long-conversation-6">Long conversation</a></li>
<li><a href="#passage-1-6">Passage 1</a></li>
<li><a href="#passage-2-6">Passage 2</a></li>
</ul>
</li>
<li><a href="#unit-7">UNIT 7</a>
<ul>
<li><a href="#long-conversation-7">Long conversation</a></li>
<li><a href="#passage-1-7">Passage 1</a></li>
<li><a href="#passage-2-7">Passage 2</a></li>
</ul>
</li>
<li><a href="#unit-8">UNIT 8</a>
<ul>
<li><a href="#long-conversation-8">Long conversation</a></li>
<li><a href="#passage-1-8">Passage 1</a></li>
<li><a href="#passage-2-8">Passage 2</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="视听说3听力翻译">视听说3听力翻译</h1>
<p>by losyi</p>
<h1 id="unit-1">UNIT 1</h1>
<h2 id="long-conversation">Long conversation</h2>
<p>Scripts<br>
W: 感谢您与我见面，Pearl博士。我需要您的许可来退选您的课程，文学与写作。<br>
M: Stacey，现在才是第二周，你为什么这么快就放弃了？我们只写了一篇文章，而且你要等到下周三才能拿到成绩！<br>
W: 我知道，先生。但作为一名大三的工程学生，我不想冒险在写作课上得分低而降低我的平均绩点！<br>
M: 好吧…你在担心什么？<br>
W: 我花了两周时间读《远大前程》，然后花了10个小时写了那篇三页的论文。嗯，我们知道，工程课程很容易但很重要。但写作课…我不知道。我下个学期只会选一门电影课，那不难——每部电影只需要写两段影评。那样就能满足我的人文学科要求了。<br>
M: 好的Stacey，听着：在大学里，我正好相反。数学很难，文学很容易。但后来，当我开了我的咖啡店，The Found Librarian，位于第15街，数学帮了我大忙！<br>
W: 等等！你是The Found Librarian的老板？那是我们最喜欢的咖啡店。我们每周在那里喝咖啡，看超过30个不同制片厂的剧本——还有做数学作业。<br>
M: 是的，那是我的店。Stacey，让我们重新考虑一下。在生活中取得成功需要各种技能。人文学科专业需要数学。工程学专业需要写作技巧。这门写作课会对你有好处。去大学写作中心报名免费辅导。然后每周五上午11点来我办公室，我会和你一起努力。一起成为一名优秀的作家，如何？<br>
W: 是的！谢谢您，Pearl博士！</p>
<h2 id="passage-1">Passage 1</h2>
<p>Scripts<br>
1978年，当我申请在伊利诺伊大学学习电影时，我父亲反对并向我引用了一个统计数据：“每年有5万名演员竞争百老汇上的200个角色。”尽管他的建议，我还是搭乘了飞往美国的航班。几年后，当我从电影学院毕业时，我开始理解我父亲的担忧。对于一个中国新来者在美国电影行业取得成功几乎是闻所未闻的。从1983年开始，我经历了六年的困惑和绝望。大部分时间里，我都在帮助电影剧组搬运设备或者担任编辑助理。我最痛苦的经历是在30多家不同的制片公司推销剧本，每次都遭到严厉的拒绝。<br>
那一年，我已经30岁了。然而，我甚至无法养活自己。我能做什么呢？继续等待，还是放弃我的电影梦想？我的妻子给了我坚定的支持。她的收入非常微薄。为了让我不感到内疚，我承担了所有的家务事——做饭、打扫卫生、照顾儿子——除此之外，还要阅读、评论电影和写剧本。<br>
对于一个男人来说，过这种生活真是丢脸。后来，我在社区大学报名参加了一门计算机课程。那时，似乎只有计算机知识能让我迅速找到工作。一天早上，在妻子上班前，她转身站在我们家门前的台阶上说：“李安，别忘了你的梦想。”<br>
之后的某个时候，我获得了我的剧本的资金支持，并开始拍摄自己的电影。之后，我的一些电影开始赢得国际奖项。回想起以前的时光，我的妻子坦言：“我一直相信你只需要一个天赋。你的天赋就是拍电影。”而今天，我终于赢得了那座金色的雕像。我认为我的坚持和妻子无私的牺牲终于得到了回报。</p>
<h2 id="passage-2">Passage 2</h2>
<p>Scripts and answers<br>
自信无所不能。当你真正有理由自信时，它会像阳光一样从你身上散发出来，像磁铁一样吸引成功。<br>
相信自己非常重要。相信你在任何情况下都能做到任何事情，因为如果你相信你能，那么你真的能。这种信念让你不断追求成功，很快你就能够实现它。<br>
自信不仅仅是一种态度，它来自于明确自己的目标和如何实现这些目标的能力。它来自于坚定的目标感。它来自于承担责任的强烈承诺，而不仅仅是任由生活发生。培养自信的一种方法是做你害怕的事情，并在背后积累成功的经验。<br>
自信并不等于自负。自负源于恐惧和不安全感，而自信来自于力量和正直。自信不仅仅是相信你能做到。自信是知道你能做到，并且知道你有能力实现任何你想要的事情。通过专注、坚定的努力、承诺和自信，任何事情都可以实现。<br>
如果你的生活不是你渴望的样子，你有能力去改变它，你必须时刻都做出这样的改变。与你的目标和行动计划一起生活，每一刻都牢记你的优先事项，那么你就会拥有你想要的生活。</p>
<h1 id="unit-2">UNIT 2</h1>
<h2 id="long-conversation-2">Long conversation</h2>
<p>Scripts<br>
W: 周五快乐，克里斯！今天的山真美啊……天啊，克里斯，你没事吧？你在哭吗？我说了什么吗？<br>
M: 没事，莎莉。只是今天是我父亲去世一周年纪念日。<br>
W: 我很抱歉。今天一定很难过。<br>
M: 今天早上我醒来，看着雷尼尔山看了45分钟，想着他。那是他最喜欢的山，从我七岁起到去年他去世，每年我们至少会一起去那座山上徒步和露营三四次。<br>
W: 哇，那也是我最喜欢的地方。我喜欢初夏时覆盖在山坡上的蓝色和黄色的花朵。<br>
M: 他也喜欢那些花，葬礼上我们摆满了篮子和一束束的花。<br>
W: 听起来很特别。这些小细节可以给人带来很多安慰。<br>
M: 是的，它们是我们在一起最快乐的回忆的提醒。老实说，我希望自己能像他那样平静地去世。我们刚从一次为期五天的徒步和露营旅行回来。我们钓了六条鱼作为晚餐，妈妈正在厨房里准备它们。爸爸坐在他最喜欢的绿色椅子上，突然心脏病发作，很快而平静地去世了。<br>
W: 失去所爱的人很难受，但听起来他过了一段美好的生活。<br>
M: 的确如此。他去世时78岁。过得很好，非常好。<br>
W: 克里斯，今天请休息一天吧。也许去雷尼尔山徒步会让你感觉好些。天气很好。<br>
M: 莎莉，你是个好老板，也是个好朋友。谢谢。</p>
<h2 id="passage-1-2">Passage 1</h2>
<p>Scripts<br>
在工作或学校的激烈竞争中，你经常感到压力大，容易生气。如何缓解这种压力呢？遵循以下的建议，将你的压力降到可控的水平！<br>
避免“必须思维”。你必须摆脱“必须以某种方式做某事”的观念。例如，“我必须在考试中取得好成绩。”这种思维模式只会增加你的压力。理性和分析地评估你的情况，不要把它看成是“生死攸关”的情况。<br>
整理一下混乱。不要在杂乱或拥挤的地方学习。为自己创造一个漂亮、开放的空间，远离干扰。<br>
设定可管理的目标。将大项目分解为较小的部分，当你完成每个部分时，你会感到积极的成就感。<br>
想象倾倒你的烦恼。想象自己走在美丽的海滩上，手里拿着一个沙桶。找个好地方停下来，把你的烦恼放进桶里。放下桶，看着它漂向大海。<br>
思考好的事情。创造一组积极但简短的假设，并在晚上入睡前在脑海中反复念诵，你会在早上感到更加积极。<br>
想象自己成功。闭上眼睛，回想一下你在现实生活中做得很好的情境。想象自己以同样自信的心态面对压力情境。<br>
床是用来睡觉，不是用来学习的。你的大脑可能会开始将床与工作联系在一起，这会让你更难入睡。<br>
听放松的音乐。如果你想听音乐，把音量调低。尤其是古典音乐可以帮助学习过程。<br>
将这些建议应用到你自己的生活中，很快你会发现越来越少的情况会让你感到压力。</p>
<h2 id="passage-2-2">Passage 2</h2>
<p>Scripts and answers<br>
专家们说，情绪往往会变得固定，对一个人的观点产生几个小时、几天甚至几周的影响。如果你的情绪是愉快的，那就太好了，但如果你感到悲伤、焦虑、愤怒或孤独，那就会成为一个问题。<br>
也许处理这种情绪的最好方法之一是倾诉。然而，有时候没有人愿意倾听。<br>
现代科学提供了大量的药物来处理不好的情绪。但科学家们也发现了几种非药物方法的实用性，可以让你摆脱不想要的情绪。这些方法和药物一样有用，并且更加健康。所以，下次你感到不舒服时，不要去药店，试试以下方法。<br>
在所有改变情绪的自助技巧中，体育锻炼似乎是治疗不好的情绪最有效的方法。“如果你能坚持锻炼，你会情绪高涨，”《跑步健康与美丽》的作者凯瑟琳·兰斯说。显然，体育活动与情绪变化有关。研究人员已经解释了生化和其他各种变化，这使得锻炼与药物相比成为一种提高情绪的方法。然而，像家务这样的体力活动几乎没有帮助，可能是因为它不够强烈，人们通常不情愿去做。关键是体育锻炼，比如跑步、骑自行车、散步、游泳或其他持续的活动，可以提高心率，增加血液循环，改善身体对氧气的利用。每次至少进行20分钟的锻炼，每周三到五次。</p>
<h1 id="unit-3">UNIT 3</h1>
<h2 id="long-conversation-3">Long conversation</h2>
<p>Scripts<br>
W: 你好，卢卡斯先生，我想请下个月八月请假十天。加上两个周末，我将有连续14天的假期。<br>
M: 八月两周？露西，选举季节即将来临，新闻和故事吸引了公众的眼球。我们可能需要我们最好的新闻制作人员，比如你，参与采访。有什么这么重要吗？<br>
W: 我知道这是一个繁忙的季节，但我每年都会请两周假来为人类住房计划(Habitat for Humanity)做志愿工作，这是我无论如何都会坚持的承诺。这是一个为有需要的人建造低成本住房的伟大组织。工作都是志愿者工作，大部分建房所需的材料都是免费提供的。这是建立社区和交朋友的好方式。<br>
M: 我喜欢人类住房计划！2005年，路易斯安那州遭受卡特里娜飓风袭击后，超过15万名志愿者帮助建造了2200多座房屋。我女儿在新奥尔良与他们一起工作，我兄弟也在人类住房计划做志愿者已经五年了。<br>
W: 哇！你知道我和我丈夫在西雅图做志愿者已经六年了。当我刚开始的时候，我甚至不知道怎么拿锤子，但现在我学会了如何粉刷、建造屋顶，甚至安装厨房水槽！我喜欢与其他志愿者和受益于我们工作的社区建立的社区感觉。<br>
M: 好吧！我们会解决的。我会给你休假时间。也许今年你还可以学习如何安装门！</p>
<h2 id="passage-1-3">Passage 1</h2>
<p>Scripts<br>
BBC的iPM广播节目向听众提出有趣的问题。作为回应，一位听众提出了以下问题：“我想问一下关于邻居之间的关系。我指的是那些住在你附近的人。我们与许多人交谈过后发现，他们都说他们不认识他们附近的任何人。”<br>
那你呢？你是否认识你附近的邻居，除了简单的问候，比如“早上好”或“下午好”之外？<br>
一个研究小组进行了一项调查，询问人们对邻居的了解程度，以下是研究小组发现的结果。<br>
令人惊讶的是，77%的人表示他们认识他们的邻居。调查还发现，如果他们住在独栋房屋，无论是城镇还是农村地区，有80%的人认识他们的邻居。<br>
然而，如果他们住在公寓里，这个比例会降至75%。调查还揭示，人们似乎随着年龄增长而变得更友好。事实上，只有64%的18至24岁的人认识他们的邻居，但对于55至64岁的人来说，这个数字上升到了88%。有趣的是，男性似乎比女性更不太可能说他们认识他们的邻居，而富人与邻居的关系比较亲近，比较不富裕的人则相对较远。<br>
这个话题在BBC的许多听众中非常受欢迎，并在BBC的iPM网站上引发了很多评论。<br>
其中一位听众说：“只有当我的邻居的房子着火时，我才真正认识他们。现在我们成了好朋友。”<br>
另一个人回忆说：“三年前我们搬进这所房子时，邻居的第一句话是‘所以，你们搬进来了？我希望你们没有吵闹的孩子。’我们向他保证我们没有孩子，并试图进行交谈，但没有成功。”</p>
<h2 id="passage-2-3">Passage 2</h2>
<p>Scripts and answers<br>
由于沟通不畅，许多邻居纠纷最终会进入法庭。如果发生危险或非法事件，警察是显而易见的解决方案。但如果出现的问题比较模糊，沟通是节省金钱和麻烦的最佳途径。以下是一些成为好邻居并处理不好邻居的建议：<br>
• 互相了解。成为一个好邻居并不意味着要和他们一起度假。只要足够了解他们，可以打个招呼，也许借一杯糖或借一个园艺工具，可以建立信任和理解。问题更容易在陌生人之间发生，而不是在即使是随便认识的人之间。<br>
• 在问题成为问题之前解决它们。如果你在家里举办派对，去找可能会受到影响的邻居，给他们两样东西：口头邀请参加派对和一张带有你电话号码的卡片。如果他们对噪音不耐烦或出现其他问题，你的邻居可以打电话给你，而不是要求警察干预。<br>
• 告诉邻居你的困扰——不要假设他们知道问题是什么。要坦诚直接，不要暗中挑衅。征求他们的意见，并在可能的情况下提出一个既能妥协又能分歧的解决方案。保持冷静和积极，即使你的邻居不是。<br>
• 与其他邻居交流。看看街区上是否还有其他人遇到类似的问题，他们可能愿意帮助解决。如果其中一个邻居与惹麻烦的人关系密切，可以让他们和你一起进行交流。<br>
总之，和任何关系一样，成为一个好邻居或处理不好的邻居都需要通过沟通来实现。</p>
<h1 id="unit-4">UNIT 4</h1>
<h2 id="long-conversation-4">Long conversation</h2>
<p>Scripts<br>
男：唉！这个创意写作课太难了！我必须在10月8日之前写一篇五页的短篇小说，但我不知道该写什么。<br>
女：我们已经上学期两个月了，你肯定之前写过故事。上次你写了什么？<br>
男：就是这个问题——到目前为止，我们只需要写真实的故事，有趣的小事情发生在我们身上或我们的家人身上。我的前三个故事都是关于我和我的童年狗布朗尼一起打猎或钓鱼，以及我在高中时期每年夏天去看望祖母。这一次，必须是虚构的。嘿！你是个很棒的艺术家，你是怎么得到灵感的？<br>
女：谢谢，但我不确定绘画和写作是否完全相同。当我准备开始一幅新画时，我通常会沿着海滩或在树林里长时间散步。我在大自然中找到大部分灵感。<br>
男：嗯…我觉得那对我来说可能不太适用。我需要人物和情节。<br>
女：你可以试试在火车站闲逛。那里总是有有趣的人，他们戴着奇怪的帽子或有着奇怪口音的人来来往往，戏剧性的离别和浪漫的重逢。只需在大厅坐上一两个小时，观察每个人。试着想象他们是谁，他们要去哪里，为什么这么匆忙。<br>
男：火车站？这实际上是个很好的主意！你是怎么想出这么好的主意的？<br>
女：我很高兴你喜欢，但我不能为此负责。这是我从许多艺术家和作家那里学到的一个老把戏。你只需要一些新鲜刺激的东西来激发创意。</p>
<h2 id="passage-1-4">Passage 1</h2>
<p>Scripts<br>
我们可能认为马桶的发明理所当然，但对于我们许多人来说，很难想象没有它该怎么生活。公共卫生系统早在很久以前就被发明出来了，但马桶是什么时候发明的呢？马桶的故事可以追溯到1596年。<br>
马桶是由约翰·哈林顿爵士为他的教母伊丽莎白一世女王而创造的。哈林顿称他的设计为“水厕”，并于1596年安装在伊丽莎白女王的城堡中。<br>
最初的马桶，或者水厕，有一个链条上的旋钮，必须拉动才能释放水从碗中流出。在碗的下方，有一个需要经常清空和清洁的盆或收集碗。这不是我们所熟知的卫生和舒适的排泄方式，但为后来的改进铺平了道路。<br>
随着时间的推移，许多发明家通过改进与底部连接的管道和建立在原始马桶基础上的冲水系统来改进哈林顿最初的水厕。到1896年，托马斯·克拉珀开始销售马桶。克拉珀认识到马桶的重要性和必要性，并利用他对这个产品的赞赏来帮助推广和销售马桶。<br>
毫无疑问，哈林顿的发明是一个难以离开的发明。发明家们将继续在哈林顿最初的水厕基础上进行改进。</p>
<h2 id="passage-2-4">Passage 2</h2>
<p>Scripts and answers<br>
科学研究应该改善我们整体的生活质量。政府应该为任何可能会带来即时和重大效益的研究提供财政和政治支持。然而，人们对于政府是否应该支持没有实际用途的科学研究的观点存在差异。尽管如此，很大一部分人认为政府应该向旨在改善人们福祉的任何科学研究分配足够的资金，即使在短期内没有实际用途。<br>
那些社会效益即时、可预测且深远的科学研究应该继续成为重中之重。例如，生物技术研究已被证明有助于治愈和预防疾病；信息技术使教育更加易于获取；通信技术通过改善人们之间的相互理解和参与民主进程来促进全球和平。<br>
然而，这并不意味着那些效益不太直接或不太明确的研究应该被降低优先级。很难预测哪些研究最终会对社会做出最大贡献。对于不那么实际的科学研究的不愿意提供资金支持可能对探索新知识的努力产生有害影响。这在计算机科学领域尤为明显。例如，在第一台计算机被发明之前，公众舆论对它持反对态度，因为大多数人认为计算机研究没有实际用途。然而，计算机在长期内改变了人类社会的演变方式，并在军事、医学、航空和教育等领域的科学发展方面证明了其巨大作用。<br>
因此，我们永远不应认为那些效益未知的科学研究不值得追求，因为任何研究的目的都应该是发现真理，无论它是什么。</p>
<h1 id="unit-5">UNIT 5</h1>
<h2 id="long-conversation-5">Long conversation</h2>
<p>Scripts<br>
M: 米歇尔，我真希望我能辞掉这份糟糕的工作——如果我能负担得起房租的话，我今天就辞职。想想整个夏天都在这么炎热的天气下工作……我梦想着我未来富有的时候！<br>
W: 哦，马克，情况没有那么糟糕！我承认，天气非常炎热，我现在很想要一杯冰凉的柠檬汁。但你只是个园丁，你觉得你怎么能变得富有呢？你觉得你会种出一棵结金子的树，然后收获一袋袋的黄金吗？<br>
M: 现在我只是个园丁，但总有一天我会变得富有。我会创办自己的企业，赚到百万！我会在一座大楼里拥有一个带有大黑皮椅和整个城市景色的角落办公室！<br>
W: 哦，我不知道成为百万富翁这么简单！如果事情就这么简单，我想我也会变得富有。但我不会去一些无聊的办公室工作。<br>
M: 哦不？那去哪里呢？如果你可以在世界上任何工作，你想要什么？<br>
W: 世界上任何工作？我想我会想要一些有趣的工作。嗯……也许可以靠玩电子游戏谋生……或者我可以成为一名飞行员……或者是一名专业的舞厅舞蹈演员！就是这样！我可以成为一名舞者，在美丽的晚礼服中在舞池中翩翩起舞！<br>
M: 你，跳舞？我对此并不太确定……你跳舞……嗯……<br>
W: 哦，拜托。我已经学了七年的舞厅舞蹈，我真的很厉害！你应该看看我……下周四晚上8点要不要一起去跳舞？</p>
<h2 id="passage-1-5">Passage 1</h2>
<p>Scripts<br>
曾经我在一家了不起的公司拥有一份很棒的工作。我有灵活的工作时间，一个理解的老板，还有高薪水。我喜欢我的工作。但是在尝试了六年各种职业角色之后，我感觉我已经超越了公司提供的固定职位。<br>
我必须承认，拥有很多钱是很好的。钱可以买到东西，好东西。然而，俗话说得对——金钱不能买到幸福，拥有金钱并不意味着你是一个成功的人。几年过去了，我意识到我赚的钱越多，我越不满足。日子开始变得模糊，时间飞逝，我深深地渴望着更有意义的事情。<br>
意识到我在用时间换取金钱后，我开始尝试其他收入来源。我开始创办并结束了几个企业，将爱好变成了专业追求，尝试了不同的投资策略。<br>
最后，我学到了无论你在做什么，都无关紧要。只要你做的是能表达你的激情的事情，你会感觉很棒，获得满足感。我还学到了从零开始创业并见证其成长是非常有回报的。<br>
通过寻找激情，我发现博客是一个平台，我可以在上面分享我最关心的想法和所学到的教训，作为服务他人的一种方式。我人生中第一次感到我正在活出我的人生目标。</p>
<h2 id="passage-2-5">Passage 2</h2>
<p>Scripts and answers<br>
一位培训不良的经理可能会让员工的生活变得痛苦。在100个案例中，有99个员工可能会因为他们的上司不认可他们、不听他们的意见，或者总体上削弱他们的自尊心而逐渐对工作失去热情。<br>
每个经理在工作中应该使用的三项基本技能是：具体说明、增强他人的自尊心和有效倾听。<br>
具体说明意味着清晰地说明要做什么以及要达到的结果。具体说明还意味着描述人的行为而不是给人贴标签。这包括给予正面反馈，告诉他们要重复的行为，以及给予坚定但不批评的纠正性反馈。<br>
然后，关键是唤起员工的自尊心。自尊心是一种私人的、个体的事情。它不是固定的，而是从一天到另一天，甚至从一个小时到另一个小时都会有起伏。因此，建立自尊心并不容易。经理不能让人们对自己感到好，而是需要帮助人们发展自己的自尊心，因为自尊心就像一扇从内部上锁的门。<br>
如今，经理们比以往任何时候都更需要的最后一项技能是倾听。倾听可能看起来是一项司空见惯的技能，但在当今商业环境中并没有得到应有的重视。人们在别人说话时往往会考虑如何回应，而不是专注于对方在说什么和他/她的意思。</p>
<h1 id="unit-6">UNIT 6</h1>
<h2 id="long-conversation-6">Long conversation</h2>
<p>Scripts<br>
W: 外面真热啊！<br>
M: 嗨，黛西！是不是华氏75度？<br>
W: 超过100度了，爷爷！你只是觉得凉爽，因为你一直开着空调！我整个早上都在院子里工作。我太热了，感觉自己要融化了！<br>
M: 至少你可以进屋喝一杯凉爽的柠檬汁。<br>
W: 我真的需要！我已经在亚利桑那的阳光下曝晒了两个小时了，我无法想象有什么比站在凉爽的空气中享受一杯冰冷的饮料更好的了。<br>
M: 当我和你一样年轻的时候，我们没有空调。威利斯·卡里尔直到1902年才发明了空调，直到二战后才有人们家中安装空调。<br>
W: 哇！那时候你的生活是怎样的？<br>
M: 我在邻居家当农场工人，整天都在修建篱笆。你应该看到我13岁时，晒得满身红肿，又脏又乱。<br>
W: 那时候你还住在亚利桑那吗？<br>
M: 不，我当时在德克萨斯。我们通过一直游泳来抵挡炎热。农场里有一条小溪，每隔几个小时，我就会跳进水里！即使我的衣服完全湿透，太阳也能在10分钟内把我晒干！<br>
W: 我知道你们那时没有手机和电脑，但我忘记了像空调这样的小舒适。<br>
M: 是的，很多事情都变了，但夏天的炎热没有变！<br>
W: 我想知道科学家在下一个世纪会发明什么来让我们保持凉爽。<br>
M: 我希望有一台天气机器，在这些漫长的干旱期间能下雨。<br>
W: 就我个人而言，我希望有人发明一台个人冰淇淋机！它可以跟着我一整天做巧克力冰淇淋！</p>
<h2 id="passage-1-6">Passage 1</h2>
<p>Scripts<br>
大约70年前，残疾人参与体育运动的想法是从未听说过的。但是，当1948年英国的年度残奥会由路德维希·古特曼爵士创办时，情况开始发生改变。<br>
古特曼爵士因为纳粹对犹太人的迫害离开了德国，1943年被英国政府要求在伦敦附近的斯托克曼德维尔医院建立一个伤病中心。他治疗伤病的方法包括残疾人参与体育运动。<br>
在第一届比赛中，只有两支受伤士兵的队伍参加。第二年，也就是1949年，有五支队伍参加。从那时起，事情发展迅速。1960年，第一届残奥会在罗马举行，与正常的奥运会在同一地点举行。从那以后，残奥会与奥运会在同一年举行。1988年首尔残奥会对残奥运动来说是一个里程碑。在首尔，夏季残奥会在夏季奥运会之后直接举行，使用同一主办城市和设施。这一先例最终在2001年国际残奥委员会和国际奥委会之间的协议中得到正式确认。<br>
残奥会在促进国际友谊和理解方面取得了巨大成功，并证明残疾并不意味着不能享受体育运动。然而，对于组织和参与残奥会的人来说，国际奥委会不愿在奥运会中包括残疾人项目仍然是一个小小的失望。也许还需要几年时间来说服那些幸运没有残疾的人，他们的残奥会运动员同样不应该被排除在外。</p>
<h2 id="passage-2-6">Passage 2</h2>
<p>Scripts and answers<br>
Sultana是一艘密西西比河上的蒸汽船，于1865年4月27日发生爆炸事故并沉没。据估计，2400名乘客中有1800人遇难，事故发生地距田纳西州孟菲斯不远。由于这起灾难发生在亚伯拉罕·林肯总统遇刺后不久，所以没有引起太多公众关注。<br>
这艘木质蒸汽船建于1863年，原本用于密西西比下游的棉花贸易。这艘蒸汽船注册吨位为1719吨，最多只能搭载376人。在两年时间里，它在圣路易斯和新奥尔良之间定期航行。有时还被要求运送军队。<br>
Sultana于1865年4月21日离开新奥尔良。大部分乘客是刚从南方联邦监狱营救出来的联邦士兵。美国政府与Sultana签订了合同，将这些前战俘运送回北方的家乡。<br>
4月27日凌晨2点，在孟菲斯以北约七英里处，至少有一台锅炉发生故障，导致巨大的爆炸，摧毁了船的中部，将正在睡觉的人们抛向空中，然后落入河中。混乱和混乱随之而来，人们试图自救和救助他人。许多人在水中溺亡，还有人被烧死。<br>
事故爆炸的直接原因后来确定为漏水和修复不良的蒸汽锅炉。幸存了初始爆炸的乘客不得不冒着生命危险在密西西比冰冷的水中求生，否则就会和船一起燃烧。许多人死于溺水或寒冷。数月来，继续在下游发现受害者的尸体，其中许多人永远没有被找到。Sultana的一些船员，包括船长在内，也是遇难者之一。</p>
<h1 id="unit-7">UNIT 7</h1>
<h2 id="long-conversation-7">Long conversation</h2>
<p>Scripts<br>
M: 梅根？嗯…我能问你几个问题吗？…我需要一些帮助。我真的很担心我的心理学入门课。<br>
W: 怎么了，蒂姆？我以为你很喜欢那门课…你写论文有困难吗？<br>
M: 不，写论文还好…但是我在考试方面真的很困扰。我一遍又一遍地读教科书，但就是无法理解一些概念。我明白这些词语的意思，但似乎无法理解这些概念如何相互关联…<br>
W: 你试过和教授交流吗？我听说史密斯博士非常乐于助人。我的朋友玛吉上过那门课，她说如果不是每周在史密斯博士的办公时间，也就是周三上午11点见面，她可能会挂科。<br>
M: 不，不行！我太害羞了。每次他在课堂上点到我，我都紧张得说不出话来。我真的很担心，不知道该怎么办。<br>
W: 你可以试试找助教简谈谈。她以将心理学的复杂概念讲解得易于理解而闻名，而且她很好沟通，因为她是个很好的倾听者。也许她能帮到你！简的办公时间是周四下午1点。<br>
M: 好的。助教简，周四下午1点。还有其他建议吗？<br>
W: 对。别忘了互联网。试着在网上做一些研究。很多大学教授会发布免费观看的视频讲座。对于像心理学入门这样的课程，我敢打赌你能在网上找到一些很棒的讲座，对你会有很大帮助。<br>
M: 谢谢梅根！我会试试的！</p>
<h2 id="passage-1-7">Passage 1</h2>
<p>Scripts<br>
我们生活中的每一种关系——友谊、家庭关系、恋爱关系和职业关系——都有可能因为冲突而被破坏。解决冲突的解决办法不是忽视冲突或者不断地四处寻找完美的人。解决关系中的冲突是我们应该培养的最重要的生活技能之一，也是我们需要珍视的东西。那么如何解决冲突呢？<br>
首先，如果我们遇到一个困难的问题，从对方的角度看问题是很重要的。这并不意味着我们必须同意他们的观点，而是试图从不同的角度看问题。这种共情至少可以帮助我们理解他们的立场，以及他们为什么持有特定的态度。如果我们只从自己的角度看问题，冲突就更容易发生。<br>
其次，我们需要宽容。关系中冲突的一个主要原因是我们期望人们以某种方式行事。期望他人以特定的行为方式行事的问题在于，当他们未能达到我们的期望时，我们会感到沮丧。我们需要宽容他人的错误和局限性。我们必须尊重他们对自己生活方式的决定。<br>
第三，我们应该进行交流。当紧张的情况出现时，交流可能是解决问题的最有效方式。在交流时，我们应该试图关注积极的问题，并寻找我们在某些方面的共识和合作。有些事情最好不说出来；除非绝对必要，否则不建议提及旧的冲突。<br>
没有冲突是无法解决的。如果我们愿意改变自己的态度，即使与困难的人相处，我们也可以发展和谐。如果我们能在关系中发展和谐，这肯定会对我们的生活产生重大影响。</p>
<h2 id="passage-2-7">Passage 2</h2>
<p>Scripts and answers<br>
研究表明，阅读速度与理解之间存在密切关系，大多数情况下，速度的增加伴随着理解的增加，速度的减少则伴随着理解的减少。然而，仅仅加快速度，特别是通过强制加速，实际上可能导致真正的阅读问题更加严重。因此，明显的解决办法是将速度的增加作为整个阅读过程的一部分。那么如何做到呢？<br>
你可以通过养成一些可行的习惯来为最大限度地提高速度做准备，比如避免重复阅读和阅读时低声诵读，学会调整阅读速度以提高理解力。<br>
速度调整可以是整体调整，也可以是文章内部的调整。类比一下，想象一下你计划在三个小时内完成一次100英里的山地旅行，平均时速约为35英里。这是你的整体速度调整。然而，在实际驾驶过程中，你可能在某些弯道上减速到每小时15英里，而在相对笔直的路段上加速到每小时50英里。这是你的内部速度调整。<br>
如果读者试图在所有类型的材料和所有阅读目的中使用相同的速度，那么结果将是不可避免的。一个好的读者会根据文章的不同调整阅读速度，甚至在同一篇文章中也会如此。因此，你需要通过日常训练培养良好的阅读习惯，直到灵活的阅读速度成为你的第二天性。</p>
<h1 id="unit-8">UNIT 8</h1>
<h2 id="long-conversation-8">Long conversation</h2>
<p>Scripts<br>
W: 哦！我的信来了！终于！我两个多星期前给贝丝写了信，过去四天我一直在检查邮件，等待她的回信。<br>
M: 贝丝是谁？为什么你因为她的信像小狗一样跳来跳去？<br>
W: 她是我在悉尼，澳大利亚的笔友。去年夏天我们在格拉纳达，西班牙相遇，当时我们都在那里度假。她在悉尼的一家医院急诊室工作，有一个五岁的儿子，正好和我女儿一样大。<br>
M: 一个在澳大利亚悉尼的护士？你是佛罗里达州迈阿密的会计师。你们到底能聊什么？我是说，你们不能谈论政治、当地事件，甚至天气…<br>
W: 哦，人们不仅仅是工作或天气！我们是朋友！我们都喜欢收集海贝壳，我们都有一个五岁的孩子，我们都是老牛仔电影的超级粉丝！<br>
M: 那么，如果你这么兴奋地等待悉尼贝丝的回信，为什么不发电子邮件呢？你可以在一小时内发送和接收电子邮件，而不是等待10天到两个星期的邮件。<br>
W: 当然，发送电子邮件速度更快，但是收到老式的信件有一种令人兴奋和美妙的感觉——感受手中的纸张，阅读和反复阅读那些深思熟虑的文字和思想…就像从远方寄来的一份惊喜礼物。<br>
M: 嗯，我能理解。当我在邮件中订购一本新书时，等待的感觉很美妙。当它到达时，我很喜欢这种感觉…这个等待是值得的！</p>
<h2 id="passage-1-8">Passage 1</h2>
<p>Scripts<br>
新技术和社交媒体网站不断变化、发展，这意味着个人交流的面貌也在改变。然而，这些变化往往意味着人们之间的面对面交流越来越少。<br>
电子邮件、短信和Facebook只是几个减少口头交流的例子；与20年前相比，口头交流已经大大减少，而当今大部分使用的技术在20年前甚至都不存在。<br>
电子邮件在20世纪70年代开始出现，但直到20世纪90年代才在公众领域流行起来，它是最早的在线交流技术之一，至今仍在使用。电子邮件目前是最受欢迎的在线交流形式，即使排除了大量的垃圾邮件。根据一项调查，每天约发送出1880亿封电子邮件，79%的人使用智能手机查看电子邮件，这个比例远高于使用智能手机打电话的43%。<br>
短信自20世纪90年代问世以来也大幅增长，现在用于交流的频率超过打电话。根据一项调查，超过70%的人使用智能手机发短信。<br>
通过社交媒体网站（如Facebook）发送消息也取代了口头交流。每天有超过40亿条消息通过Facebook发送。虽然这远远落后于发送的电子邮件数量，但几乎与美国每天发送的短信数量相当，成为人们交流的重要方式之一。<br>
众所周知，人们在新技术和社交媒体网站上花费的时间越来越多，这减少了现实生活中的交流时间。<br>
同样，毫无疑问，随着这些数字的不断上升，面对面和口头交流将继续减少，甚至可能成为过去的一种趋势。</p>
<h2 id="passage-2-8">Passage 2</h2>
<p>Scripts and answers<br>
媒体中最有用的部分正在消失。在北美，报纸现在已经成为一种濒危物种。向读者销售文字并向广告商销售读者的业务，这一直是它们在社会中的角色所依赖的，但现在这个业务正在瓦解。<br>
在所有旧媒体中，报纸受到互联网的影响最大。在许多国家，发行量一直在下降。但在过去几年里，互联网加速了这一衰落。在菲利普·迈尔的书《消失的报纸》中，他计算出2043年第一季度将是美国新闻纸消亡的时刻，因为最后一位疲惫不堪的读者将抛弃最后一份皱巴巴的报纸。<br>
广告也在追随转向互联网的读者。这场竞争激烈，主要是因为互联网是一个吸引人的媒介，可以前所未有地将买家与卖家匹配，并向广告商证明他们的投资物有所值。在瑞士和荷兰，报纸已经失去了一半的分类广告。<br>
报纸还没有大规模关闭，但这只是时间问题。在未来几十年里，北美一半的主流报纸可能会倒闭。工作岗位已经在消失。根据美国报业协会的数据，1990年至2004年间，报纸行业就业人数下降了约18%。此外，今年投资银行摩根士丹利批评纽约时报公司，因为其股价在四年内下跌了近50%。这或多或少表明，上市报纸公司股价的暴跌引发了投资者的愤怒。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转载】华科军事理论在线作业答案]]></title>
        <id>https://Ilosyi.github.io/post/zhuan-zai-hua-ke-jun-shi-li-lun-zai-xian-zuo-ye-da-an/</id>
        <link href="https://Ilosyi.github.io/post/zhuan-zai-hua-ke-jun-shi-li-lun-zai-xian-zuo-ye-da-an/">
        </link>
        <updated>2024-08-23T12:55:57.000Z</updated>
        <content type="html"><![CDATA[<p>原文连接:<a href="https://dekrt.cn/answer/military/">dekrt's blog</a></p>
<h1 id="第一章中国国防答案">第一章：中国国防答案</h1>
<ol>
<li>西汉初期，实行征兵制，规定凡年满 20 岁的男丁都要登记，从 23 岁起，服兵役（ ）。</li>
</ol>
<p>A . 一年 B . 两年 C . 三年 D . 四年</p>
<p>正确答案：B</p>
<p>2.“天下虽安，忘战必危” 出自于 ( )。</p>
<p>A .《孙子兵法》 B .《孙膑兵法》 C .《战争论》 D .《司马法・仁本》</p>
<p>正确答案：D</p>
<ol start="3">
<li>下列哪个朝代对长城陆续加工增修并逐渐改建成最接近今天的面貌。( )</li>
</ol>
<p>A . 元朝 B . 清朝 C . 唐朝 D . 明朝</p>
<p>正确答案：D</p>
<ol start="4">
<li>国防是随着 ( ) 的出现而产生的。</li>
</ol>
<p>A . 阶级 B . 军队 C . 国家 D . 社会</p>
<p>正确答案：C</p>
<ol start="5">
<li>下列哪个国家的国防类型是典型的中立型国防（ ）</li>
</ol>
<p>A . 瑞士 B . 韩国 C . 朝鲜 D . 中国</p>
<p>正确答案：A</p>
<p>6.“兵者，国之大事” 是出自哪本兵书（ ）</p>
<p>A .《孙子兵法》 B .《汉书》 C .《兵制》 D .《孙膑兵法》</p>
<p>正确答案：A</p>
<p>7.“足食，足兵，民信” 是由谁提出（ ）</p>
<p>A . 老子 B . 孔子 C . 孙武 D . 岳飞</p>
<p>正确答案：B</p>
<ol start="8">
<li>在中国东部沿海设置的卫、所等海防工程是在哪个朝代建立（ ）</li>
</ol>
<p>A . 宋朝 B . 明朝 C . 清朝 D . 元朝</p>
<p>正确答案：B</p>
<ol start="9">
<li>长城修筑的历史最早可上溯到（ ）时期</li>
</ol>
<p>A . 秦朝 B . 明朝 C . 春秋战国 D . 西周</p>
<p>正确答案：C</p>
<ol start="10">
<li>第二次鸦片战争爆发于（ ）</li>
</ol>
<p>A .1840 年 B .1841 年 C .1856 年 D .1860 年</p>
<p>正确答案：C</p>
<ol start="11">
<li>国防建设是我国社会主义建设事业的重要组成部分，必须适应国家利益的需要，必须与经济建设协调发展，必须坚持以 ( ) 为中心，必须遵循独立自主方针，必须由全国军民共同建设，必须进行全面深入改革。</li>
</ol>
<p>A . 四项基本原则 B . 现代化建设 C . 富国强军 D . 装备化建设</p>
<p>正确答案：B</p>
<p>12.2013 年，中国共产党 ( ) 决定对深化国防和军队改革，构建中国特色现代军事力量体系作出了明确部署。</p>
<p>A . 十八届一中全会 B . 十八届二中全会 C . 十八届三中全会 D . 十八届四中全会</p>
<p>正确答案：C</p>
<ol start="13">
<li>我国坚持走和平发展的道路，坚定不移地奉行 ( ) 的国防政策。</li>
</ol>
<p>A . 防御性 B . 攻击性 C . 半攻击半防御 D . 中立性</p>
<p>正确答案：A</p>
<ol start="14">
<li>根据宪法制定并于 1997 年通过的《中华人民共和国国防法》进一步明确规定：中华人民共和国的武装力量受 ( ) 领导。</li>
</ol>
<p>A . 全国人民 B . 中国共产党 C . 工人阶级 D . 中国共产党和其他民主党派</p>
<p>正确答案：B</p>
<p>15.( )，作为军委主管国防动员和后备力量建设的职能部门 —— 军委国防动员部成立。</p>
<p>A .2016 年 1 月 11 日 B .2016 年 8 月 1 日 C .2015 年 1 月 11 日 D .2015 年 8 月 1 日</p>
<p>正确答案：A</p>
<ol start="16">
<li>国防动员的内容十分丰富，其中 () 是核心。</li>
</ol>
<p>A . 武装力量动员 B . 国民经济动员 C . 人民防空动员 D . 交通运输动员</p>
<p>正确答案：A</p>
<p>17.( )，是为了应对战争、突发事件和紧急状态的需要，国家有计划、有组织地将交通运输设施、设备、工具和交通运输专业技术保障力量及其相应的体制，由平时状态转入战时 (急时) 状态所进行的一系列活动。</p>
<p>A . 武装力量动员 B . 国民经济动员 C . 人民防空动员 D . 交通运输动员</p>
<p>正确答案：D</p>
<p>18.( )，是国家有计划地组织各政党、各人民团体，以及工、农、商、学等社会各界，结成广泛的爱国统一战线，鼓励国内社会政治力量参与应对战争、突发事件和紧急状态所进行的一系列活动。</p>
<p>A . 政治宣传和精神灌注 B . 国内社会政治力量动员 C . 外交动员 D . 国民经济动员</p>
<p>正确答案：B</p>
<ol start="19">
<li>健全战时 (急时) 国防动员体制，是军队和政府的共同职责。我国《国防法》明确规定：( ) 动员准备和动员实施工作。</li>
</ol>
<p>A . 国务院 B . 中央军委 C . 国防部 D . 国务院和中央军委共同领导</p>
<p>正确答案：D</p>
<ol start="20">
<li>国防动员令是国家为了应对战争、突发事件和紧急状态的需要，由国家最高权力机关决定并依法下达的国防动员决定和国防动员实施命令，实际上是国家宣布进入战时 (急时) 状态的命令。我国《宪法》明确规定：( ) 决定战争和和平的问题；( ) 会决定战争状态的宣布，决定全国总动员或者局部动员；国家主席根据全国人民代表大会及常务委员会的决定，宣布战争状态，宣布进入紧急状态，发布动员令。</li>
</ol>
<p>A . 全国人民代表大会，全国人民代表大会</p>
<p>B . 全国人民代表大会，全国人民代表大会常务委员</p>
<p>C . 全国人民代表大会常务委员，全国人民代表大会常务委员</p>
<p>D . 全国人民代表大会常务委员，全国人民代表大会</p>
<p>正确答案：B</p>
<ol start="21">
<li>全民国防教育日是（ ）。</li>
</ol>
<p>A . 每年 9 月的第三个星期五</p>
<p>B . 每年 10 月的第三个星期五</p>
<p>C . 每年 9 月的第三个星期六</p>
<p>D . 每年 10 月的第三个星期六</p>
<p>正确答案：C</p>
<ol start="22">
<li>按照《兵役法》规定我国公民的合法服兵役的最高年龄限制是 ( ) 岁。</li>
</ol>
<p>A.18 B.20 C.22 D.24</p>
<p>正确答案：C</p>
<ol start="23">
<li>中国人民解放军的 “三化” 是指（ ）、现代化和 正规化。</li>
</ol>
<p>A . 革命化 B . 制度化 C . 规范化 D . 程序化</p>
<p>正确答案：A</p>
<ol start="24">
<li>第一次鸦片战争是在（ ）年爆发。</li>
</ol>
<p>A .1840 B .1841 C .1842 D .1843</p>
<p>正确答案：A</p>
<ol start="25">
<li>联盟型国防可分为两种：一是一元体系联盟，一是（ ）联盟。</li>
</ol>
<p>A . 多元体系 B . 二元体系 C . 三元体系 D . 四元体系</p>
<p>正确答案：A</p>
<p>26.《兵役法》规定，平时应征公民拒绝、逃避征集拒不改正的，在（ ）年内不得被录取为国家公务员、国有企业职员，不得出国或者升学。</p>
<p>A .1 B .2 C .3 D .4</p>
<p>正确答案：B<br>
27.《孙子兵法》的作者是（ ）。</p>
<p>A . 孙武 B . 孙膑 C . 孔子 D . 孟子</p>
<p>正确答案：A</p>
<ol start="28">
<li>秦朝的主要武装力量体制包括京师兵、郡县兵和（ ）。</li>
</ol>
<p>A . 骑兵 B . 边兵 C . 单兵 D . 步兵</p>
<p>正确答案：B</p>
<ol start="29">
<li>长城的有著名的 “九镇”、“三关”，其中三关包括嘉峪关、山海关和（ ）。</li>
</ol>
<p>A . 玉门关 B . 居庸关 C . 井陉关 D . 雁门关</p>
<p>正确答案：B</p>
<ol start="30">
<li>中国人民解放军的现役部队包括陆军、空军、海军和（ ）。</li>
</ol>
<p>A . 民兵 B . 火箭军 C . 通信兵 D . 特种兵</p>
<p>正确答案：B</p>
<ol start="31">
<li>国防的基本特征包括（ ）</li>
</ol>
<p>A . 国防安全的整体性</p>
<p>B . 国防实力的综合性</p>
<p>C . 国防手段的多元性</p>
<p>D . 国防建设的系统协调性。国防事业的社会性</p>
<p>正确答案：A,B,C,D,E</p>
<ol start="32">
<li>中国古代的国防工程包括（ ）</li>
</ol>
<p>A . 城池 B . 京杭大运河 C . 长城 D . 海防工程</p>
<p>正确答案： A,B,C,D</p>
<ol start="33">
<li>以下属于国防的地位和作用的是（ ）</li>
</ol>
<p>A . 国家安全的重要保障</p>
<p>B . 国家经济发展的重要基础</p>
<p>C . 国家独立自主的前提</p>
<p>D . 国家繁荣发展的重要条件</p>
<p>正确答案： A,C,D</p>
<ol start="34">
<li>国防的类型有扩张型、中立型和 ( )</li>
</ol>
<p>A . 同盟型 B . 联盟型 C . 侵略型 D . 自卫型</p>
<p>正确答案：B,D</p>
<ol start="35">
<li>国家作为一个政治概念，应包括哪几个基本要素（ ）</li>
</ol>
<p>A . 领土 B . 政府 C . 主权 D . 人民 E. 国防</p>
<p>正确答案： A,B,C,D</p>
<ol start="36">
<li>国家利益按利益的内容可分为（ ）</li>
</ol>
<p>A . 政治利益 B . 文化利益 C . 安全利益 D. 军事利益 E. 经济利益</p>
<p>正确答案： A,B,C,E</p>
<ol start="37">
<li>下列哪些属于非传统安全领域（ ）</li>
</ol>
<p>A . 能源危机 B . 环境问题 C . 人权问题 D . 军事冲突 E. 网络安全</p>
<p>正确答案： A,B,C,E<br>
38. 以下属于联盟型国防类型的国家是（ ）</p>
<p>A . 日本 B . 瑞典 C . 中国 D . 美国 E. 瑞士</p>
<p>正确答案： A,D<br>
39. 下列属于国防要素内容的是 ( )</p>
<p>A . 政治要素 B . 经济要素 C . 文化要素 D . 历史要素</p>
<p>正确答案： A,B,C<br>
40. 中国古代国防思想的局限性主要表现在（ ）</p>
<p>A . 重防非攻 B . 寓兵于农 C . 重陆轻海 D . 以仁为本</p>
<p>正确答案： A,C<br>
41.1958 年 7 月，中央军委扩大会议通过的决议规定，中央军委是全军统帅，下设 ( )；国防部是军委对外的名义。军委决定的事项，凡须经国务院批准，或须用行政名义下达的，由国防部签署对外发布。</p>
<p>A . 总参谋部 B . 总政治部 C . 总后勤部 D . 总装备部</p>
<p>正确答案： A,B,C<br>
42. 我国维护国家安全的基本目标和任务是 ( )。</p>
<p>A . 制止分裂，促进统一，防备和抵抗侵略，捍卫国家主权、领土完整和海洋权益 B . 维护国家发展利益，促进经济社会全面、协调、可持续发展 C . 保障人民群众的政治、经济、文化权益 D . 保持 正常社会秩序和社会稳定</p>
<p>正确答案： A,B,C,D<br>
43.2015 年 12 月 31 日，成立了 ( )。这是党中央和中央军委着眼实现中国梦、强军梦作出的重大决策，是构建中国特色现代军事力量体系的战略举措，必将成为我军现代化建设的一个重要里程碑，载入人民军队史册。</p>
<p>A . 陆军领导机构 B . 海军领导机构 C . 火箭军 D . 战略支援部队</p>
<p>正确答案： A,C,D<br>
44. 目前我国海军共有三大舰队分别是 ( )</p>
<p>A . 北海舰队 B . 东海舰队 C . 渤海舰队 D . 南海舰队</p>
<p>正确答案： A,B,D<br>
45. 中央军委勤保障部队于 2016 年 9 月 13 日成立，部队组成主要包括 ( )。</p>
<p>A . 武汉联勤保障基地 B . 郑州联勤保障基地 C . 无锡、桂林、西宁、沈阳、武汉五个联勤保障重心 D . 无锡、桂林、西宁、沈阳、郑州五个联勤保障重心</p>
<p>正确答案： A,D<br>
46. 人民防空动员，是国家为了保障人民群众的生命和财产安全而组织进行的防备敌人空袭、消除空袭后果的一系列活动。人民防空动员，在部分国家也称为民防动员。在我国，人民防空与 ( ) 一起构成三位一体的国土防空体系。</p>
<p>A . 工农业防空 B . 要地防空 C . 野战防空 D . 海陆防空</p>
<p>正确答案：B,C<br>
47. 交通运输动员的目的，主要是为动员输送、军队机动、物资供应、居民疏散、工厂和机关的转移搬迁等提供交通运输保障。交通运输动员的内容，主要包括 ( )。</p>
<p>A . 交通运输工具动员 B . 交通运输设施、设备和物资动员 C . 交通运输铁路 D . 交通运输人员动员</p>
<p>正确答案： A,B,D<br>
48. 国防动员令是国家发布的关于动员实施的命令，具有很强的 ( )。</p>
<p>A . 政治性 B . 权威性 C . 严肃性 D . 时效性</p>
<p>正确答案： A,B,C,D<br>
49. 搞好人民防空动员，对于普及和加强人民防空知识，推进防空基础设施建设，组织人员和物资疏散隐蔽，加强重要军事、政治和经济目标防护，消除空袭后果，减少国家及人民群众生命财产的损失，保存战争潜力，增强国家的防御能力，具有重要意义。人民防空动员的内容，主要包括 ( ) 等几个方面。</p>
<p>A . 群众防护动员 B . 人防专业队伍动员 C . 人防工程物资技术保障动员 D . 人防预警保障动员</p>
<p>正确答案： A,B,C,D<br>
50. 武装力量是国家或政治集团所拥有的各种武装组织的总称。我国的武装力量主要包括 ( )。</p>
<p>A . 中国人民解放军 B . 中国人民武装警察部队 C . 中国民兵 D . 中国自卫军</p>
<p>正确答案： A,B,C<br>
51.2016 年 2 月，成立中国人民解放军 5 大战区，撤销原来的 7 大军区。五大战区分别是：东部战区、西部战区、南部战区，北部战区和中部战区，真 正形成 ( ) 的格局。</p>
<p>A . 军委管总 B . 战区主战 C . 军种主建 D . 多兵种配合</p>
<p>正确答案： A,B,C<br>
52. 中国人民解放军是中国共产党缔造和领导的人民军队，是中国武装力量的主体。人民解放军由 ( ) 和 ( ) 组成。</p>
<p>A . 现役部队 B . 预备役部队 C . 民兵 D . 工程兵</p>
<p>正确答案： A,B<br>
53. 国防领导体制，是国家（ ）国防建设和军事斗争的组织体系及相应制度，包括国防领导机构的设置、职权划分和相互关系等，是国家体制和军事组织体制的重要组成部分。</p>
<p>A . 谋划 B . 决策 C . 指挥 D . 协调</p>
<p>正确答案： A,B,C,D<br>
54. 中国人民共和国武装力量，由（ ）组成。</p>
<p>A . 中国人民解放军现役部队 B . 预备役部队 C . 中国人民武装警察部队 D . 民兵</p>
<p>正确答案： A,B,C,D<br>
55. 军民融合是指把国防和军队现代化建设深深融入经济社会发展体系之中，全面推进军民在（ ）等各个领域的融合。</p>
<p>A . 经济 B . 科技 C . 教育 D . 人才</p>
<p>正确答案： A,B,C,D<br>
56. 国防法规包含（ ）等法律。</p>
<p>A .《国防法》B .《兵役法》C .《国防教育法》D .《国防动员法》</p>
<p>正确答案： A,B,C,D<br>
57. 公民履行兵役义务的主要形式有（ ）</p>
<p>A . 服现役 B . 服预备役 C . 参加学生军事训练 D . 学习军事理论知识</p>
<p>正确答案： A,B,C<br>
58. 公民的国防权利包括（ ）</p>
<p>A . 提出建议权 B . 制止和检举权 C . 获得补偿权 D . 服兵役权</p>
<p>正确答案： A,B,C<br>
59. 国防动员体制包括（ ）</p>
<p>A . 决策体制 B . 协调体制 C . 执行体制 D . 激励体制</p>
<p>正确答案： A,B,C<br>
60. 国防动员的内容十分丰富，通常包括（ ）以及政治动员等几个主要方面。</p>
<p>A . 武装力量动员 B . 国民经济动员 C . 人民防空动员 D . 交通运输动员</p>
<p>正确答案： A,B,C,D</p>
<h1 id="第二章-第-12-节答案">第二章 第 12 节答案</h1>
<ol>
<li>增强忧患意识，做到居安思危，是我们治党治国必须始终坚持的一个重大原则。我们党要巩固执政地位，要团结带领人民坚持和发展中国特色社会主义，保证（ ）是头等大事。</li>
</ol>
<p>A . 改革开放 B . 军事强大 C . 国家安全 D . 经济发展</p>
<p>正确答案：C<br>
2. 国家安全工作应当坚持（ ）。</p>
<p>A . 总体安全观 B . 总体国家安全观 C . 国家安全观 D . 传统安全观</p>
<p>正确答案：B<br>
3. 国家安全工作应当坚持以（ ）为宗旨。</p>
<p>A . 政治安全 B . 经济安全 C . 人民安全 D . 社会安全</p>
<p>正确答案：C<br>
4. 国家安全工作应当坚持以 ( ) 为根本。</p>
<p>A . 政治安全 B . 经济安全 C . 人民安全 D . 社会安全</p>
<p>正确答案： A<br>
5. 国家安全工作应当坚持以 ( ) 为基础。</p>
<p>A . 政治安全 B . 经济安全 C . 人民安全 D . 社会安全</p>
<p>正确答案：B<br>
6. 坚持（ ）对国家安全工作的领导，建立集中统一、高效权威的国家安全领导体制。</p>
<p>A . 人民代表大会 B . 国家安全局 C . 公安机关 D . 中国共产党</p>
<p>正确答案：D<br>
7. 维护国家安全，应当遵守宪法和法律，坚持社会主义法治原则，尊重和保障人权，依法保护公民的（ ）。</p>
<p>A . 权利和自由 B . 权利和义务 C . 自由和平等 D . 义务和权益</p>
<p>正确答案： A<br>
8. 维护国家安全，应当与（ ）相协调。</p>
<p>A . 经济发展 B . 社会发展 C . 社会文化发展 D . 经济社会发展</p>
<p>正确答案：D<br>
9. 维护国家安全，应当坚持（ ），专门工作与群众路线相结合，充分发挥专门机关和其他有关机关维护国家安全的职能作用，广泛动员公民和组织，防范、制止和依法惩治危害国家安全的行为。</p>
<p>A . 惩治为主、预防为辅 B . 标本兼治、惩治为主 C . 预防为主、标本兼治 D . 预防为主、处罚结合</p>
<p>正确答案：C<br>
10. 根据《中华人民共和国国家安全法》规定，每年（ ）为全民国家安全教育日。</p>
<p>A .4 月 15 日 B .7 月 7 日 C .9 月 18 日 D .10 月 25 日</p>
<p>正确答案： A<br>
11. 根据《中华人民共和国国家安全法》规定，公民和组织因支持、协助国家安全工作导致财产损失的，按照国家有关规定给予（ ）。</p>
<p>A . 奖励 B . 补偿 C . 补助 D . 赔偿</p>
<p>正确答案：B<br>
12.（ ）是指人类社会与自然地理环境的相互关系，是长期影响国家安全的基本因素。</p>
<p>A . 周缘 B . 政缘 C . 地缘 D . 人缘</p>
<p>正确答案：C<br>
13. 中国有（ ）个邻国，是世界上邻国最多的国家，这些邻国在政治、经济、文化等方面都表现出差异很大的多样性，使中国成为世界上周边环境最复杂的国家。</p>
<p>A .8 B .14 C .18 D .20</p>
<p>正确答案：D<br>
14. 中美贸易摩擦不断升级，美国对中国商品额外征收高额关税，集中在（ ）中主要发展的高科技产业。</p>
<p>A . 中国制造 2020 B . 中国制造 2025 C . 中国制造 2030 D . 中国制造 2035</p>
<p>正确答案：B<br>
15.（ ）实现香港回归祖国、（ ）实现澳门回归祖国，现在继续为解决台湾问题、实现祖国完全统一而奋斗。</p>
<p>A .1997 年 1 月 1 日、1999 年 7 月 1 日 B .1997 年 7 月 1 日、1999 年 7 月 1 日 C .1997 年 7 月 1 日、1999 年 12 月 20 日 D .1997 年 1 月 1 日、1999 年 12 月 20 日</p>
<p>正确答案：C 16. 根据宪法，制定《中华人民共和国国家安全法》的意义（ ）。</p>
<p>A . 维护国家安全 B . 保卫人民民主专政的政权和中国特色社会主义制度 C . 保护人民的根本利益 D . 保障改革开放和社会主义现代化建设的顺利进行。实现中华民族伟大复兴</p>
<p>正确答案： A,B,C,D,E<br>
17. 国家安全是指（ ）和国家其他重大利益相对处于没有危险和不受内外威胁的状态，以及保障持续安全状态的能力。</p>
<p>A . 国家政权、主权、统一 B . 领土完整 C . 人民福祉 D . 经济社会可持续发展。个人</p>
<p>正确答案： A,B,C,D<br>
18. 国家安全工作应当统筹（ ）。</p>
<p>A . 生命安全和财产安全 B . 内部安全和外部安全 C . 国土安全和国民安全 D . 传统安全和非传统安全。自身安全和共同安全</p>
<p>正确答案：B,C,D,E<br>
19. 维护国家安全，应当坚持（ ），积极同外国政府和国际组织开展安全交流合作，履行国际安全义务，促进共同安全，维护世界和平。</p>
<p>A . 互信 B . 互利 C . 互惠 D . 平等。协作</p>
<p>正确答案： A,B,D,E<br>
20. 根据《中华人民共和国国家安全法》规定，中国的主权和领土完整不容侵犯和分割。维护（ ）是包括港澳同胞和台湾同胞在内的全中国人民的共同义务。</p>
<p>A . 国家主权 B . 国家利益 C . 统一 D . 领土完整。个人权益</p>
<p>正确答案： A,C,D<br>
21. 国家防范、制止和依法惩治（ ）行为。</p>
<p>A . 叛国 B . 分裂国家、煽动叛乱 C . 颠覆或者煽动颠覆人民民主专政政权 D . 窃取、泄露国家秘密。境外势力的渗透、破坏、颠覆、分裂活动</p>
<p>正确答案： A,B,C,D,E<br>
22. 国家加强边防、海防和空防建设，采取一切必要的防卫和管控措施，保卫（ ）安全，维护国家领土主权和海洋权益。</p>
<p>A . 领陆 B . 内水 C . 领水 D . 领海。领空</p>
<p>正确答案： A,B,D,E<br>
23. 国家加强武装力量（ ）建设，建设与保卫国家安全和发展利益需要相适应的武装力量；</p>
<p>A . 革命化 B . 军事化 C . 现代化 D . 正规化。战略化</p>
<p>正确答案： A,C,D<br>
24. 国家在维护能源安全方面的措施（ ）。</p>
<p>A . 合理利用和保护资源能源 B . 有效管控战略资源能源的开发 C . 加强战略资源能源储备，完善资源能源运输战略通道建设和安全保护措施 D . 加强国际资源能源合作。全面提升应急保障能力，保障经济社会发展所需的资源能源持续、可靠和有效供给</p>
<p>正确答案： A,B,C,D,E<br>
25. 国家在维护文化安全方面的措施（ ）。</p>
<p>A . 坚持社会主义先进文化前进方向 B . 继承和弘扬中华民族优秀传统文化 C . 培育和践行社会主义核心价值观 D . 防范和抵制不良文化的影响。掌握意识形态领域主导权</p>
<p>正确答案： A,B,C,D,E<br>
26. 总体国家安全观的核心要义的关系包括（ ）。</p>
<p>A . 既重视发展问题，又重视安全问题 B . 既重视外部安全，又重视内部安全 C . 既重视国土安全，又重视国民安全 D . 既重视传统安全，又重视非传统安全。既重视自身安全，又重视共同安全</p>
<p>正确答案： A,B,C,D,E<br>
27. 我国地缘环境的基本特征（ ）。</p>
<p>A . 国土面积大 B . 人口众多 C . 地理环境差异大 D . 自然资源禀赋充足。自然资源禀赋不足</p>
<p>正确答案： A,B,C,E<br>
28. 当前我国所面临的政治安全风险十分复杂，“三股势力”（ ）活动带来巨大危害。</p>
<p>A . 暴力恐怖势力 B . 民族分裂势力 C . 港独台独势力 D . 宗教分裂势力。宗教极端势力</p>
<p>正确答案： A,B,E<br>
29. 中国是世界上第一个提出 &quot;核安全观&quot; 概念的国家，中国核安全观是（ ）。</p>
<p>A . 发展和安全并重 B . 权利和义务并重 C . 改革和开放并重 D . 自主和协作并重。治标和治本并重</p>
<p>正确答案： A,B,D,E<br>
30. 新兴领域的国家安全是指（ ）。</p>
<p>A . 维护海洋安全 B . 维护陆地安全 C . 维护太空安全 D . 维护网络安全。维护科技安全</p>
<p>正确答案： A,C,D</p>
<h1 id="第二章-第-3-节答案">第二章 第 3 节答案</h1>
<ol>
<li>国际战略形势是判断国家安全所处的国际战略环境，分析国家安全形势，（ ）与进行国家安全战略指导的重要依据。</li>
</ol>
<p>A . 制定国家安全战略 B . 寻求国家安全措施 C . 确定国际战略格局 D . 分析国际战略趋势</p>
<p>正确答案： A<br>
2. 以下关于国际战略格局和国际战略形势的关系描述错误的是（ ）：</p>
<p>A . 国际战略格局是国际战略环境的框架结构，国际战略形势是国际战略环境的动态表现 B . 国际战略格局制约国际战略形势变化，而国际战略形势变化又推动国际战略格局的发展 C . 国际战略格局是国际战略环境的基础，国际战略形势是国际战略环境的静态表现 D . 国际战略形势与国际战略格局之间是一种互动发展的关系</p>
<p>正确答案：C<br>
3. 当今世界 正面临百年未有之大变局。2018 年以来的世界异常复杂， 偶然与必然、苗头与趋势、乱局与变局交织。 几大全局性、系统性、结构性矛盾集中显现，其影响几乎无处不在并贯穿始终， 给 “当今世界 正在发生数百年未有大变局” 之说下了注脚， 也给世界未来发展走向带来很大的不确定性和嬗变性。总体呈现出的特点中不包括（ ）：</p>
<p>A . 霸权国家与崛起大国的对立 B . 单边主义与多边主义的碰撞 C . 全球化与反全球化激荡 D . 和平与发展并存</p>
<p>正确答案：D<br>
4. 习近平同志指出：“只要把握住历史发展大势，抓住历史变革时机，奋发有为，锐意进取，人类社会就能更好前进。” 国际社会日益成为 “你中有我、我中有你” 的命运共同体，和平、发展、（ ）、共赢成为不可阻挡的时代潮流。</p>
<p>A . 合作 B . 共享 C . 协作 D . 互助</p>
<p>正确答案： A<br>
5. 以下哪一项不是国际战略形势的趋势（ ）：</p>
<p>A . 多极化趋势不断深入发展 B . 社会信息化、文化多样化持续推进 C . 全球化深入发展，但存在负面影响 D . 国际反恐斗争影响国际战略格局演变</p>
<p>正确答案：B<br>
6. 随着中国综合国力快速增强，作为未来多极格局中的一极，中国对世界影响是多方面的，其主要作用体现在三个方面，其中不包括（ ）：</p>
<p>A . 中国是世界经济发展的中坚力量 B . 中国是全球发展的推动者，是世界经济增长的重要引擎 C . 中国是国际秩序的维护者 D . 中国是世界和平的建设者</p>
<p>正确答案： A<br>
7. 科学认识当前世界主要国家军事力量及战略动向，对维护我国国家安全具有重要意义。对我国安全构成重大影响的世界主要军事强国，是美国及周边的俄罗斯、（ ）和印度。</p>
<p>A . 加拿大 B . 英国 C . 德国 D . 日本</p>
<p>正确答案：D<br>
8. 俄军的战略动向是（ ）：</p>
<p>A . 确保霸权地位 B . 走向政治军事大国 C . 力保大国地位 D . 大国崛起</p>
<p>正确答案：C<br>
9. 以下哪一项不是美国保持其在世界的霸权地位、在全球化中的主导地位的措施？（ ）</p>
<p>A . 重提大国竞争激化军备竞赛 B . 走精兵之路，加快改革步伐 C . 积极调整太空战略形成太空霸权 D . 大力加强和扩充核武器确保绝对核优势</p>
<p>正确答案：B<br>
10. 以下哪一项不是印度实现其军事战略动向的措施？（ ）</p>
<p>A . 不断加大军费投入提升自卫队现代化水平 B . 军事战略由重实战转向为重威慑 C . 提升军费升级军备 D . 对华军事战略从 “劝阻威慑” 转向 “积极威慑”</p>
<p>正确答案： A<br>
11.“当今世界 正面临百年未有之大变局”，这句话是国家主席习近平在什么时候时间和场合说的？（ ）</p>
<p>A .2018 年 11 月 8 日，国家主席习近平在人民大会堂会见美国前国务卿基辛格博士时指出 B .2019 年 5 月 15 日，国家主席习近平在亚洲文明对话开幕式上的讲话指出 C .2018 年 5 月 2 日，国家主席习近平在北京大学师生座谈会上的讲话指出 D .2018 年 9 月 15 日，国家主席习近平在全国教育大会上的讲话</p>
<p>正确答案： A<br>
12. 全球化是要素的流动，主要涉及三个要素：（ ）、物流（器物与货币），以及信息流，包括思想的传播。</p>
<p>A . 资本 B . 消费 C . 人流 D . 商品</p>
<p>正确答案：C<br>
13. 当前，全球范围的社会信息化进入了全面渗透、跨界融合、引领创新的新阶段，以 “信息 ” 为主要特征的技术融合和产业变革已经成为推动人类生产生活方式变革和社会进步的重要力量。当今世界的三元不包括（ ）：</p>
<p>A . 自然社会 B . 人类社会 C . 物理世界 D . 信息空间</p>
<p>正确答案： A<br>
14. 日本现役自卫队的组成不包括（ ）：</p>
<p>A . 陆上自卫队 B . 海上自卫队 C . 航空自卫队 D . 海岸警卫队</p>
<p>正确答案：D<br>
15. 以下哪一项不是日本实现其军事战略动向的措施？（ ）</p>
<p>A . 以持续构建更高层级安全防卫体制谋求军事大国 B . 不断加大军费投入提升自卫队现代化水平 C . 积极调整太空战略形成太空霸权 D . 广泛开展各种军事演习促进军事合作、加强军事同盟</p>
<p>正确答案：C 16. 影响世界格局变化最为重要的国家间关系有（ ）</p>
<p>A . 中美 B . 中俄 C . 美俄 D . 中日</p>
<p>正确答案： A,B,C<br>
17. 美国面对世界的变化，认为自己在多边体系和国际机制中透支了、受损了， 让其他国家搭了便车，需要有选择地 “破旧立新”。美国所采取的措施有：（ ）</p>
<p>A . 宣布退出 “伊核协议” B . 宣布启动退出《中导条约》C . 公开威胁退出 WTOD . 公开宣扬反对全球主义</p>
<p>正确答案： A,B,C,D<br>
18. 从 2017 年以来，发达国家反 （ ） 势头继续看涨，发达国家之间在许多问题上的矛盾加剧，离心倾向加剧，加之在世界格局中对主动权和有利地位的角逐，传统发达国家不希望继续依附在美国的霸权之下，成为加剧发达国家之间矛盾的主要原因。</p>
<p>A . 民粹主义 B . 民族主义 C . 保护主义 D . 资本主义</p>
<p>正确答案： A,B,C<br>
19. 国际社会日益成为 “你中有我、我中有你” 的命运共同体，（ ） ，成为不可阻挡的时代潮流。</p>
<p>A . 和平 B . 发展 C . 合作 D . 共赢</p>
<p>正确答案： A,B,C,D<br>
20. （ ）、（ ） 、（ ）的相对衰落和发展中国家群体崛起，推动全球战略格局向有利于多极化的方向演变。</p>
<p>A . 美 B . 日 C . 欧 D . 英</p>
<p>正确答案： A,B,C<br>
21. 全球化也存在负能量的传播。全球化是要素的流动，主要涉及三个要素：（ ） 、（ ） 、（ ） ，包括思想的传播。</p>
<p>A . 人流 B . 物流 C . 信息流 D . 能源流</p>
<p>正确答案： A,B,C<br>
22.“信息 ” 带来的开放合作将使不同国家相互受益、共同繁荣，更加有力有效地促进人才、信息、技术等生产要素在全球范围自由流动，推动经济全球化朝着更加（ ） 、共赢的方向发展，使经济全球化的红利为世界各国人民所共享。</p>
<p>A . 开放 B . 包容 C . 普惠 D . 平衡</p>
<p>正确答案： A,B,C,D<br>
23. 美军武装力量分为 （ ） 、（ ） 、（ ）、美国海军陆战队和美国海岸警卫队等五大军种。</p>
<p>A . 美国陆军 B . 美国海军 C . 美国空军 D . 美国自卫队</p>
<p>正确答案： A,B,C<br>
24. 美国战略核力量有（ ）</p>
<p>A . 洲际弹道导弹 B . 弹道导弹潜艇 C . 潜射弹道导弹 D . 战略轰炸机</p>
<p>正确答案： A,B,C,D<br>
25. 印度海岸警卫队分（ ） 三个大队。</p>
<p>A . 西岸 B . 东岸 C . 南岸 D . 安达曼和尼科巴</p>
<p>正确答案： A,B,D<br>
26. 俄罗斯联邦武装力量被划分为哪些军种（ ）</p>
<p>A . 陆军 B . 海军 C . 空军 D . 火箭军</p>
<p>正确答案： A,B,C<br>
27. 鉴于俄、中、朝、伊 (朗) 等对手的核能力及目标，美国强调必须发展 “（ ） 、（ ） 、（ ） ” 的核力量，针对对手特点分别实施量身定做的核威慑战略。</p>
<p>A . 现代 B . 灵活 C . 科技 D . 弹性</p>
<p>正确答案： A,B,D<br>
28. 日本现役自卫队由 （ ） 队组成。</p>
<p>A . 陆上自卫队 B . 海上自卫队 C . 航空自卫队 D . 特种军自卫队</p>
<p>正确答案： A,B,C<br>
29. 印度自 2014 年 正式提出 “东向政策” 以来，莫迪政府不断渲染中国的军事威胁，加强与（ ） 的战略关系，致力于建设一个 “自由、开放、繁荣和包容” 的印度洋，以提升印度在亚太地缘角逐中的制衡力度，应对中国在该地区日益上升的影响力。</p>
<p>A . 美国 B . 日本 C . 澳大利亚 D . 中国</p>
<p>正确答案： A,B,C<br>
30. 当前，以（ ）为代表的新一代信息技术日新月异，新一轮科技革命和产业变革孕育兴起，人类生产生活的智能化水平大幅提升。</p>
<p>A . 物联网 B . 大数据 C . 互联网 D . 人工智能</p>
<p>正确答案：B,C,D</p>
<h1 id="第三章思考题答案">第三章思考题答案</h1>
<ol>
<li>我国《军事大百科全书》对军事思想的定义是：军事思想是关于战争、军队和国防的基本问题的 （ ） , 是人们长期从事军事实践的经验总结和理论概括。</li>
</ol>
<p>A . 观察思考 B . 总结提炼 C . 理性认识 D . 感性认识</p>
<p>正确答案：C<br>
2. 军事思想是军事实践的行动指南，军事思想对军事实践的指导作用体现在 （ ） 。</p>
<p>A . 为认识军事问题提供基本观点 B . 为军事预测提供思想方法 C . 为从事各项军事实践活动提供全局性指导 D . 以上全是</p>
<p>正确答案：D<br>
3. 现代军事科学包括军事理论科学和军事技术科学两大部分，其中军事理论科学由军事思想和（ ） 组成，可见军事思想在军事科学体系中占有极其重要的地位.</p>
<p>A . 军事谋略 B . 军事学术 C . 军事格局 D . 军事哲学</p>
<p>正确答案：B<br>
4. 军事思想的内容大体可分为两个层次，一个是（ ） 层次上的问题，一个是军事活动实践的基本指导原则层次上的问题.</p>
<p>A . 军事理论 B . 军事学术 C . 实战经验 D . 军事哲学</p>
<p>正确答案：D<br>
5.１５和１６世纪之交，欧洲军事思想领域出现了近代化的萌芽，主要代表著作是意大利马基雅维利的 （ ） 等。</p>
<p>A .《军事教训》 B .《战争艺术》 C .《战争指导》 D .《军事战略》</p>
<p>正确答案：B<br>
6. 拿破仑一世凭借 （ ） 所造成的新的社会条件，创立了使用广大民众力量进行战争的崭新作战体系。</p>
<p>A . 法国大革命 B . 雾月政变 C . 拿破仑战争 D . 土伦战役</p>
<p>正确答案： A<br>
7. 马克思和恩格斯在研究哲学、政治经济学的基础上，对军事问题进行论述，共同创立了（ ） 主义军事理论.</p>
<p>A . 马克思 B . 恩格斯 C . 共产 D . 无产阶级</p>
<p>正确答案： A<br>
8. 苏联的（ ） 认为，高新技术的不断发展完善，将引起军事上的深革命，对军队组织结构、指挥体制、武器系统和作战方法等产生根本性影响。他被誉为世界新军事革命的首倡者。</p>
<p>A . 奥尔加科夫 B . 沙波什尼科夫 C . 戈尔什科夫 D . 克雷诺夫</p>
<p>正确答案： A<br>
9.“（ ） ” 的实质是利用计算机信息网络对处于各地的部队或士兵实施一体化指挥和控制，其核心是利用网络让所有作战力量实现信息共享，实时掌握战场态势，缩短决策时间，提高打击速度与精度。</p>
<p>A . 计算机网络 B . 网络中心战 C . 信息战 D . 电子对抗</p>
<p>正确答案：B<br>
10. 中国古代军事思想萌芽于（ ）</p>
<p>A . 春秋战国 B . 西汉 C . 魏晋南北朝 D . 夏商</p>
<p>正确答案：D<br>
11. 中国古代军事思想成熟于（ ）时期</p>
<p>A . 春秋战国 B . 西汉 C . 魏晋南北朝 D . 隋唐</p>
<p>正确答案： A<br>
12. 宋元时期军事思想的发展，最重要的体现在（ ）的发展</p>
<p>A . 战争观 B . 战略思想 C . 战术思想 D . 军事技术</p>
<p>正确答案：D<br>
13. 中国古代军事思想的产生、形成及发展大致可分为三个阶段，其中不包括（）</p>
<p>A . 西周 B . 春秋 C . 秦汉 D . 清末民初</p>
<p>正确答案：D<br>
14. 中国古代兵法中占首要位置的地位的是（ ）</p>
<p>A . 战争观 B . 战略 C . 战术 D . 军事技术</p>
<p>正确答案：B<br>
15. 中国古代第一形成战略思想的伟大人物是（ ）</p>
<p>A . 孙武 B . 孙膑 C . 李世民 D . 成吉思汗</p>
<p>正确答案： A<br>
16. 孙武是春秋末期（ ）国人</p>
<p>A . 秦 B . 齐 C . 魏 D . 赵</p>
<p>正确答案：B<br>
17.《孙子兵法》现存（）篇</p>
<p>A .11 B .12 C .13 D .14</p>
<p>正确答案：C<br>
18. 中古古代哪本兵书被誉为古代第一兵书（ ）</p>
<p>A .《六韬》 B .《左传》 C .《孙子兵法》 D .《孙膑兵法》</p>
<p>正确答案：C<br>
19. 下列那句话体现了《孙子兵法》重战的思想（ ）</p>
<p>A .“兵者，国之大事” B .“知兵知将，民之司命，国家安危之主” C .“兵无常势” D .“争天下者，必先争人”</p>
<p>正确答案： A<br>
20.、自中国共产党成立到（ ）前，是毛泽东军事思想的产生和形成时期</p>
<p>A . 古田会议 B . 遵义会议 C . 八七会议 D . 瓦窑堡会议</p>
<p>正确答案：B<br>
21. 抗日战争爆发后，毛泽东发表了 （ ）一书，精辟地分析了抗日战争的形势，科学地论证了战争 发展的规律，指明了坚持抗战的 正确道路</p>
<p>A .《矛盾论》 B .《井冈山的斗争》 C .《论持久战》 D .《星星之火，可以燎原》</p>
<p>正确答案：C<br>
22. 毛泽东把（ ）作为坚持武装斗争的首要问题</p>
<p>A . 打持久战 B . 保持优良传统 C . 狠抓纪律 D . 建立人民军队</p>
<p>正确答案：D<br>
23.（ ）是毛泽东军事思想的核心，是我党进行革命战争的根本指导路线。</p>
<p>A . 军队建设的思想 B . 人民战争思想 C . 战争与和平的思想 D . 持久战的思想</p>
<p>正确答案：B<br>
24. 毛泽东的人民战争的战略战术中指出我军的基本作战方针是 （）</p>
<p>A . 歼灭战 B . 运动战 C . 速决战 D . 游击战</p>
<p>正确答案： A<br>
25. 邓小平科学分析和 正确判断了国际形势和我国的安全环境，提出了战争与和平的理论、建设有中国特色的现代化国防理论和现代条件下 ( ) 战略的理论。</p>
<p>A . 国家战争 B . 局部战争 C . 人民战争 D . 侵略战争</p>
<p>正确答案：C<br>
26. 江泽民指出，中国人民解放军是（ ）的坚强柱石，是捍卫社会主义祖国的钢铁长城、建设中国特色社会主义的重要力量。</p>
<p>A . 改革开放 B . 人民民主专政 C . 可持续发展 D . 祖国统一</p>
<p>正确答案：B<br>
27. 胡锦涛指出，全面履行党和人民赋予的新世纪新阶段军队历史使命，必须坚持以毛泽东军事思想、邓小平新时期军队建设思想、江泽民国防和军队建设思想为指导，把（ ）作为国防和军队建设的重要指导方针。</p>
<p>A . 科学发展观 B . 三个代表 C . 现代化建设 D . 改革开放</p>
<p>正确答案： A<br>
28. 习近平总书记深刻指出，军事手段是实现伟大梦想的保底手段，军事斗争是进行伟大斗争的重要方 面，（ ）能力是维护国家安全的战略能力</p>
<p>A . 保障 B . 创新 C . 打赢 D . 改革</p>
<p>正确答案：C<br>
29. 习近平强军思想明确党在新时代的强军目标是，力争到（ ）年基本实现国防和军队现代化，到本世纪中叶把人民军队全面建成世界一流军队</p>
<p>A .2020 B .2025 C .2030 D .2035</p>
<p>正确答案：D<br>
30. 习近平指出，（ ）是灵魂，决定军队建设的政治方向。</p>
<p>A . 听党指挥 B . 作风优良 C . 能打胜仗 D . 严明纪律</p>
<p>正确答案： A<br>
31. 习近平指出，坚持（ ）是中国特色社会主义的本质特征，是党和国家的重要政治优势。</p>
<p>A . 军民融合发展 B . 发展和安全兼顾 C . 党对军队绝对领导 D . 富国和强军统一</p>
<p>正确答案：C 32. 军事思想通常包括（ ） 、（ ）、（ ） 、（ ） 等。</p>
<p>A . 战争观 B . 军事问题认识论和方法论 C . 战争指导思想 D . 军事发展史。国防和军队建设思想</p>
<p>正确答案： A,B,C,E<br>
33. 军事思想具备以下的基本特征 （ ） 、（ ） 、（ ） 、（ ）。</p>
<p>A . 阶级性 B . 时代性 C . 继承性 D . 借鉴性。通用性</p>
<p>正确答案： A,B,C,D<br>
34. 像希罗多德的 （ ） 、修昔底德的（ ） 、色诺芬的（ ） 、凯撒的（ ） 等书中，都可反映出古代欧洲一些国家的军事思想。</p>
<p>A . 历史 B . 伯罗奔尼撒战争史 C . 远征记 D . 高卢战记和内战记</p>
<p>正确答案： A,B,C,D<br>
35. 英国斯宾塞的 “（ ）”“（ ） ” 和德国拉采尔的 “（ ） ” 认为，“强存弱汰” 是国际生活的 “自然法则”, 一个 “健全的国家有机体” 有权通过战争扩展自己的 “生存空间”.( )</p>
<p>A . 社会达尔文主义 B . 地缘政治论 C . 社会有机论 D . 地理环境决定论</p>
<p>正确答案： A,C,D<br>
36. 美国首先提出 “（ ）” 理论和 “（ ） ” 的战略理论。苏联提出未来战争是一场全面的火箭核大战。但是，在美苏核武器数量越来越多，英国、法国和中国都拥有核武器以后，核力量由比较悬殊到相对均势的发展变化，世界形成 “（ ） ”、许多国家都认识到谁也不能轻易发动核战争，转而研究 “ （ ）” 等理论，将目光重新转向常规战争。</p>
<p>A . 核武器制胜 B . 大规模报复 C . 恐怖的核平衡 D . 有限核威僵</p>
<p>正确答案： A,B,C,D<br>
37. 书中提出，（ ） 是历史发展的一个决定性因素，海军战略的目标是保证国家获得平时和战时的海权。马汉认为，海上作战最重要的任务是（ ） ，而掌握制海权有赖于强大的 （ ）。</p>
<p>A . 海权 B . 掌握制海权 C . 国家 D . 海军</p>
<p>正确答案： A,B,D<br>
38. 战争论是普鲁士资产阶级著名的军事理论家卡尔。冯. 克劳塞维茨 (１７８０－１８３１), 在总结以往战争特别是拿破仑战争的基础上写成的，全书共３卷８篇１２４章，第一篇 “（ ） ”, 第二篇 “（ ）”, 第三篇 “ （ ） ”, 第四篇 “战斗”, 第五篇 “军队”, 第六篇 “防御”, 第七篇 “进度”, 第八篇 “战争计划”。</p>
<p>A . 战争的起源 B . 论战争的性质 C . 论战争理论 D . 战略概论。战争要素</p>
<p>正确答案：B,C,D<br>
39.《战争论》其基本的思想观点是：战争是政治的继续；战争的目的就是消灭敌人；人民战争是战争整个发酵过程的扩大和加强；战略包括 （ ）、（ ）、（ ）、（ ）、（ ）五大要素；战略上最重要而又最简单的准则是集中兵力；战争中的攻防。</p>
<p>A . 精神 B . 物质 C . 数学 D . 地理。历史。统计</p>
<p>正确答案： A,B,C,D,E<br>
40. 下列哪些是战国时期出世的兵书（ ）</p>
<p>A .《孙子兵法》B .《孙膑兵法》C .《司马法》D .《六韬》</p>
<p>正确答案： A,B,C,D<br>
41. 中国古代军事思想涉及下列那些方面的内容（ ）</p>
<p>A . 战争观 B . 战略观 C . 治军思想 D . 作战方法与谋略</p>
<p>正确答案： A,B,C,D<br>
42. 中国古代军事思想认为，战争与（ ）相关</p>
<p>A . 政治 B . 经济 C . 文化 D . 环境</p>
<p>正确答案： A,B<br>
43. 中国古代军事思想的主要特点包括（ ）</p>
<p>A . 重视军事与政治、经济的关系 B . 重视发挥谋略的作用 C . 重视发挥主观指导作用 D . 重视将帅的地位和作用</p>
<p>正确答案： A,B,C,D<br>
44. 孙武认为将必有五德，五德包括（ ）</p>
<p>A . 智 B . 信 C . 仁 D . 勇。严</p>
<p>正确答案： A,B,C,D,E<br>
45.《孙子兵法》第一部分的内容有（ ）</p>
<p>A .《计》B .《作战》C .《谋攻》D .《九变》</p>
<p>正确答案： A,B,C<br>
46.《孙子兵法》第二部分的内容有（ ）</p>
<p>A .《军争》B .《九变》C .《行军》D .《地形》</p>
<p>正确答案： A,B,C,D<br>
47.《孙子兵法》第二部分的内容有（ ）</p>
<p>A .《火攻》B .《九地》C .《用间》D .《虚实》</p>
<p>正确答案： A,B,C,D<br>
48. 下列哪些属于《孙子兵法》的思想（ ）</p>
<p>A . 重战、慎战、备战思想 B .“知彼知己，百战不殆” 的战争指导思想 C . 以谋略制胜为核心的用兵思想 D .“文武兼施，恩威并用” 的治军思想</p>
<p>正确答案： A,B,C,D<br>
49.《孙子兵法》的局限性主要表现在（ ）</p>
<p>A . 战争观方面未能区分战争的性质 B . 治军方面的愚兵政策 C . 军队补给方面的抢掠政策 D . 作战原则方面存有某些片面性</p>
<p>正确答案： A,B,C,D<br>
50. 毛泽东军事思想的内容体系包括（ ）</p>
<p>A . 无产阶级的战争观和方法论 B . 人民军队建设理论 C . 人民战争思想；D . 人民战争的战略战术</p>
<p>正确答案： A,B,C,D<br>
51. 经过（ ）, 毛泽东人民军队的建军思想开始确立，并在以后的斗争实践中逐步完善，形成一整套的人民军队的建军原则</p>
<p>A . 遵义会议 B . 三湾改编 C . 古田会议 D . 瓦窑堡会议</p>
<p>正确答案：B,C<br>
52. 毛泽东关于开展人民战争的战略战术方针是 ()</p>
<p>A . 战略上藐视敌人 B . 战术上重视敌人 C . 政治上瓦解敌人 D . 战场上消灭敌人</p>
<p>正确答案： A,B<br>
53. 毛泽东军事思想的产生和形成时期，毛泽东撰写了（ ）等重要军事著作，这标志着毛泽东军事思想的形成。</p>
<p>A .《中国的红色政权为什么能够存在》B .《井冈山的斗争》C .《星星之火，可以燎原》D .《论持久战》E.《关于纠 正党内错误思想》</p>
<p>正确答案： A,B,C,E<br>
54. 邓小平科学分析和 正确判断了国际形势和我国的安全环境，提出了（ ）</p>
<p>A . 建立人民军队 B . 战争与和平的理论 C . 建设有中国特色的现代化国防理论 D . 现代条件下人民战争战略</p>
<p>正确答案：B,C,D<br>
55. 江泽民认为，和平时期进一步加强国防和军队建设，对（ ）具有深远的战略意义，号召全党和全国人民要积极关心和支持国防和军队建设。</p>
<p>A . 改革开放 B . 维护国家的长治久安 C . 保证社会主义现代化建设的顺利进行 D . 祖国统一</p>
<p>正确答案：B,C<br>
56. 胡锦涛国防和军队建设思想的科学含义包括（ ）</p>
<p>A . 是巩固党执政地位重要的力量保证 B . 是国家发展战略机遇期坚强的安全保障 C . 是维护国家利益有力的战略支撑 D . 人民民主专政的基本保障</p>
<p>正确答案： A,B,C<br>
57. 党在新时代的强军目标是建设一支（ ）的人民军队</p>
<p>A . 听党指挥 B . 能打胜仗 C . 作风优良 D . 保障有力</p>
<p>正确答案： A,B,C<br>
58. 习近平指出，明确军民融合发展是兴国之举、强军之策，必须形成（ ）军民融合深度发展格局，构建一体化的国家战略体系和能力. A . 新技术 B . 全要素 C . 多领域 D . 高效益</p>
<p>正确答案：B,C,D<br>
59. 习近平强军思想的重要意义（ ）</p>
<p>A . 是确保军队建设 正确方向的迫切需求 B . 是实现党在新形势下的强军目标的迫切需求 C . 是深化国防和军队改革的迫切需求 D . 是汇聚强军兴军强大能量的迫切需求</p>
<p>正确答案： A,B,C,D<br>
60. 党的十八大以来，以习近平同志为总书记的党中央和中央军委着眼于坚持和发展中国特色的社会主义、实现中华民族伟大复兴中国梦，围绕强军兴军提出了一系列重大战略思想、理论观点、决策部署，深刻阐述了国防和军队建设的（ ）的重大问题。</p>
<p>A . 根本性 B . 全局性 C . 方向性 D . 整体性</p>
<p>正确答案： A,B,C</p>
<h1 id="第四章-现代战争答案">第四章 现代战争答案</h1>
<ol>
<li>战争是阶级间、民族间、国家间、政治集团间矛盾斗争的 ( ) 形式，以（ ）反映政治实质，经济是战争的物质基础，（ ）决定战争的方式，（ ）是战争的基本原则。</li>
</ol>
<p>A . 最低 武装斗争 武器装备 消灭敌人 B . 最高 暴力手段 科学技术的发展水平 消灭敌人 C . 最高 暴力手段 科学技术的发展水平 保存自己和消灭敌人 D . 最低 武装斗争 科学技术的发展水平 保存自己和消灭敌人</p>
<p>正确答案：C<br>
2. 全世界从奴隶社会早期到２０世纪８０ 年代，在有文字记载的３５００多年的时间里，共发生过（ ）次战争. A .140 余 B .1400 余 C .14000 余 D .140000 余</p>
<p>正确答案：C<br>
3. 以下哪种说法反映了历史唯物主义者对战争的看法？（ ）</p>
<p>A . 战争是自然和永恒的现象，战争的根源在于自然环境和人类的生物本性。 B . 为战争是上帝对人的惩罚，并用超自然力量解释战争起因。 C . 战争是由优劣民族之间差别引起的。 D . 战争是社会生产力和生产关系发展到一定阶段的产物，是私有制产生以后，随着阶级和国家的出现，有了压迫和反压迫时才出现的。</p>
<p>正确答案：D<br>
4. 总结各种战争的具体起因，可以得出战争的一般起因是（ ）</p>
<p>A . 争夺权力 B . 争夺物资 C . 人类社会的生产关系不适应生产力而导致的利益对抗 D . 自然灾难</p>
<p>正确答案：C<br>
5.（ ）是现代战争的根源。</p>
<p>A . 领土争端 B . 帝国主义、霸权主义 C . 意识形态冲突 D . 宗教冲突</p>
<p>正确答案：B<br>
6.() 决定战争的性质，() 是战争的物质基础，( ) 是直接决定战争胜负的因素。</p>
<p>A . 政治 经济 军事 B . 政治 经济 自然环境 C . 军事 经济 政治 D . 经济 军事 政治</p>
<p>正确答案： A<br>
7. 任何战争说到底，都受人和物这两个因素的制约，但战争胜负的决定因素是（ ）。</p>
<p>A . 人 B . 物</p>
<p>正确答案： A<br>
8. 传统战争体现着鲜明的（ ）的特点。</p>
<p>A . 暴力主导 B . 信息主导 C . 舆论主导 D . 贸易主导</p>
<p>正确答案： A<br>
9. 与以往那种通过彻底摧毁对方抵抗力量或意志赢得战争胜利的零和观念不同，现代战争更加体现（ ）性，通过（ ）的打击行动，达成营造态势和有效控局的目的。</p>
<p>A . 有限，有限 B . 局部，局部 C . 快速，快速 D . 有效，有效</p>
<p>正确答案： A<br>
10. 现代战争绝非单纯的（ ）, 而是在（ ）的基础上，以（ ）为主，在政治、经济、科技、外交、文化等多种手段配合下进行的整体较量。</p>
<p>A . 武力较量，综合国力，军事手段 B . 武力较量，军事实力，军事手段 C . 暴力较量，科技实力，政治斗争 D . 暴力较量，科技实力，军事手段</p>
<p>正确答案： A<br>
11. 战争的（ ）性，在作战中的主要表现是以小博大、撬动全局，力争用战术行动达成战略战役目的。</p>
<p>A . 目的有限 B . 规模可控 C . 空间有限 D . 行动联合</p>
<p>正确答案：B<br>
12.“兵无常势，水无常形。” 说的是（ ）</p>
<p>A . 作战样式的多样性 B . 作战环境的多变性 C . 作战因素的多元性 D . 作战目的的有限性</p>
<p>正确答案： A<br>
13. 拿破仑指出，运动是战争的灵魂。美国前国防部长科恩也指出，以往的作战哲学是大吃小，今天是快吃慢。这些都精辟阐述了（ ）在战争制胜中的重要性。</p>
<p>A . 力量 B . 科技 C . 速度 D . 人数</p>
<p>正确答案：C<br>
14. 战争活动在不同的历史时期有着不同的表现，从战争实践活动可分为（ ）</p>
<p>A . 冷兵器时代战争、热兵器时代战争、机械化时代战争和信息化时代战争 B . 中国古代战争和西方现代战争 C . 局部战争和世界大战 D . 侵略战争和自卫战争</p>
<p>正确答案： A<br>
15. 马克思、恩格斯的军事著作，运用辩证唯物主义和历史唯物主义的观点分析战争，揭示战争的普遍规律，认为 “到目前为止的一切社会的历史都是（ ）的历史，战争的本质不是别的，而是（ ）的经济、政治制度的直接产物，是阶级斗争的最高形式，即（ ）尖锐到一定程度而进行的暴力斗争；一切历史冲突都根源于生产力和生产关系之间的矛盾”</p>
<p>A . 阶段斗争，阶级社会，阶级斗争，阶级矛盾 B . 阶级斗争，人类社会，阶级斗争，民族矛盾 C . 阶级斗争，人类社会，阶级斗争，阶级矛盾 D . 阶级斗争，人类社会，阶级斗争，社会矛盾</p>
<p>正确答案： A<br>
16. 战争是在（ ）社会后期出现的.</p>
<p>A . 奴隶 B . 原始 C . 封建 D . 资本主义</p>
<p>正确答案：B<br>
17. 自（ ）以来，世界军事领域兴起了一场新的深刻革命，被称 之为 “新军事革命”.</p>
<p>A .２０世纪 60 年代末 70 年代初 B .２０世纪 70 年代末 80 年代初 C .２０世纪 80 年代末 90 年代初 D .２０世纪 90 年代末２１世纪初</p>
<p>正确答案：C<br>
18.2003 年的伊拉克战争中，美军运用了（ ）颗侦察卫星，（ ）多架各型侦察机，能够（ ）小时不间断地获取实时的战场态势图像和情报，实现了战场情况的单向透明。</p>
<p>A .9 ， 7 ， 12 B .9 ， 7， 24 C .90， 70 ， 12 D .90， 70， 24</p>
<p>正确答案：D<br>
19. 伊拉克战争中，美军共发射巡航导弹约（ ）枚，总投弹量约（ ）多枚，其中精确制导弹药约占总弹药量的（ ）, 除大量使用战斧式巡航导弹、联合直接攻击弹药外，还使用了高能微波炸弹等精确制导武器，起到了事半功倍的效果.</p>
<p>A .80 ， 200， 50% B .800 ， 2000 ， 50% C .800 ， 2000， 70% D .800， 20000， 70%</p>
<p>正确答案：D<br>
20. 在军队信息化装备方面，哪个国家现在走在最前面（ ）</p>
<p>A . 美国 B . 俄国 C . 中国 D . 德国</p>
<p>正确答案： A<br>
21. 新军事技术的崛起经历了四个阶段，第一个阶段是（ ）</p>
<p>A . 从 20 世纪 60 年代初到 70 年代末 B . 从第二次世界大战到 20 世纪 50 年代末 C . 从 20 世纪 90 年代初至今 D . 从 20 世纪 80 年代初到 80 年代末</p>
<p>正确答案：B<br>
22. 机械化战争以物质力量为主导要素。二战期间，军用飞机的生产多达（ ）余万架，航空母舰多达（ ）余艘，潜艇多达（ ）余艘。</p>
<p>A .80， 140， 1500 B .70 ， 140 ， 1500 C .70， 240， 1500 D .70 ， 140， 2500</p>
<p>正确答案：B<br>
23. 在信息时代，战争可以用公式（ ）来认知。</p>
<p>A . 战争 = 综合强制 + 流血的强制 + 不流血的强制 B . 战争 = 暴力 = 流血的交战 C . 战争 = 暴力 = 综合强制 D . 战争 = 综合强制 + 流血的强制</p>
<p>正确答案： A<br>
24. 伊拉克战争历史 43 天，大致可分为三个阶段。第一个阶段是（ ）</p>
<p>A .“斩首行动” B .“震慑行动” C .“围剿行动” D .“和平计划”</p>
<p>正确答案： A<br>
25. 在整个科索沃战争期间，北约军队电子战飞机使用量占比（ ）以上。</p>
<p>A .30% B .40% C .50% D .60%</p>
<p>正确答案：B<br>
26. 碳纤维石墨炸弹被首次应用于哪次战争中（ ）</p>
<p>A . 科索沃战争 B . 阿富汗战争 C . 利比亚战争 D . 伊拉克战争</p>
<p>正确答案： A<br>
27.1990 年 8 月 2 日凌晨，伊拉克军队动用（ ）个师，总兵力（ ）余万人，在空、海军的配合下，突然大举入侵科威特，仅用（ ）余个小时就吞并了号称 “海湾明珠” 的科威特。</p>
<p>A .24， 10， 10 B .14， 10， 10 C .14， 10， 20 D .14， 20， 10</p>
<p>正确答案：B<br>
28. 计算机控制信息系统，将陆、海、空、天、电多维空间的行动凝聚为一体，在 “沙漠风暴” 行动中，多国部队每天出动飞机（ ）多架次，从不同的基地起飞、袭击不同的目标，这些都需要强大的战场自动化控制系统。</p>
<p>A .20 B .200 C .2000 D .20000</p>
<p>正确答案：C<br>
29. 什么时候开始出现就地征用与基地保障相结合的部队补给方式（ ）</p>
<p>A .16 至 17 世纪 B .18 世纪后期至 19 世纪初期 C .19 世纪后半期至 20 世纪初 D .20 世纪初至 20 世纪中叶</p>
<p>正确答案：B<br>
30. 从冷兵器战争演进到机械化战争的军事革命进程持续了近（ ）余年</p>
<p>A .200 B .300 C .400 D .500</p>
<p>正确答案：B 31. 以下哪些战争属于 正义战争（ ）</p>
<p>A . 自卫战争 B . 为保卫祖国和平而进行的战争 C . 保卫国家主权和领土完整 D . 为了自由和尊严而进行的战争</p>
<p>正确答案： A,B,C,D<br>
32. 以下哪些是非 正义战争（ ）、</p>
<p>A . 侵略战争 B . 征服战争 C . 为了压迫和掠夺而进行的战争</p>
<p>正确答案： A,B,C<br>
33. 任何战争都是为了达到既定目的而进行的，具体表现为（ ）</p>
<p>A . 战争的军事目的 B . 战争的政治目 C . 战争的经济目的。正确答案： A,B,C<br>
34. 战争的本质特点有哪些（ ）</p>
<p>A . 战争的政治性 B . 战争的目的有限性 C . 战场空间的全域性 D . 战争实施的整体性。战争规模的可控性、作战方式的多样性。作战行动的联合性、战争制胜的速决性</p>
<p>正确答案： A,B,C,D,E,F<br>
35. 现代战争中作战力量联合的深度和广度也得到了新的发展，表现在以下那些方面（ ）</p>
<p>A . 联合一体化加强 B . 诸军种联合向跨领域联合发展 C . 由战略战役层次联合向战术层次联合发展</p>
<p>正确答案： A,B,C<br>
36. 以下哪些描述阐述了速度在战争制胜中的重要性（ ）</p>
<p>A .“兵贵神速” B . 运动是战争的灵魂 C . 快鱼吃慢鱼 D . 大鱼吃小鱼</p>
<p>正确答案： A,B,C<br>
37. 新军事变革包含哪些要素（ ）</p>
<p>A . 新军事技术 B . 新组织体制 C . 新军事理论 D . 新军事管理。正确答案： A,B,C,D<br>
38. 新军事革命主要呈现出以下哪些特点（ ）</p>
<p>A . 武器装备高科技化 B . 编制体制精干化 C . 指挥控制自动化 D . 作战空间多维化。作战样式体系化</p>
<p>正确答案： A,B,C,D,E<br>
39. 新军事变革的只要内容是（ ）</p>
<p>A . 创新军事技术 B . 创新军队的体制编制 C . 创新作战理论 D . 创新军事管理。战争形态从机械化向信息化转变</p>
<p>正确答案： A,B,C,D,E<br>
40. 军事高技术建立在高技术的基础之上，与一般技术相比，有八哪些特点（ ）</p>
<p>A . 高智力 B . 高投资 C . 高竞争 D . 高风险。高效益、高速度。高渗透、高保密</p>
<p>正确答案： A,B,C,D,E,F<br>
41. 随着军事高技术的发展及其在军事领域的广泛应用，已经对作战行动产生了巨大影响。这种影响概括起来就是（ ）</p>
<p>A . 侦察立体化 B . 打击精确化 C . 反应高速化 D . 防护综合化。控制智能化</p>
<p>正确答案： A,B,C,D,E<br>
42. 当前，世界各主要国家都在努力推进新一轮军事改革，世界新军事革命深入发展，其基本内涵是 ( )</p>
<p>A . 体制编制的联合化、小型化、自主化趋势更加明显；B . 武器装备呈现出向数字化、精确化、隐形化、无人化的发展趋势；C . 联合作战形态向 “四非”(非接触、非线性、非对称和非 正规) 和 “三无”(无 形、无声、无人) 作战方向发展；D . 军队指挥形态更加扁平化、自动化、网络化、无缝化，一体化联合作战指挥体系 逐步形成；. 现代国防管理体制不断完善</p>
<p>正确答案： A,B,C,D,E<br>
43. 新军事变革对于一个国家、一个民族既是机遇，又是挑战。党的十九大报告明确提出，要 “适应世界新军事革命发展趋势和国家安全需求，提高建设质量和效益，确保到 2020 年基本实现机械化，信息化建设取得重大进展，战略能力有大的提升。同国家现代化进程相一致，全面推进（ ），力争到 2035 年基本实现国防和军队现代化，到本世纪中叶把人民军队全面建成世界一流军队。”</p>
<p>A . 军事理论现代化 B . 军队组织形态现代化 C . 军事人员现代化 D . 武器装备现代化</p>
<p>正确答案： A,B,C,D<br>
44. 机械化战争的基本特征包括（ ）</p>
<p>A . 机械化战争以物质力量为主导要素 B . 机械化战争的作战指挥控制是金字塔式 C . 机械化战争的作战效能是武器系统之间的对抗 D . 机械化战争的作战目的在于消灭对方的有生力量</p>
<p>正确答案： A,B,C,D<br>
45. 美军 “太空篱笆” 建成后，可探测和跟踪 20 万个直径大于 2 厘米的空间目标。其主要做法包括：（）</p>
<p>A . 推动高超音速武器进入作战体系 B . 加快信息 “网伞” 建设，打造全维一体态势感知体系 C . 抢占新型作战空间，拓展态势感知的范围与精度 D . 提高导弹预警探测能力，提升态势感知威慑能力</p>
<p>正确答案：B,C,D<br>
46. 在未来信息化战争时代，战争的表现形式有了许多拓展，主要包括（ ）</p>
<p>A . 战争暴力性减弱 B . 作战指挥控制更加扁平 C . 战争层次更加模糊 D . 战争主体多元化</p>
<p>正确答案： A,C,D<br>
47. 今后军事力量合成的基本趋势是战斗单元的（ ）</p>
<p>A . 多能化 B . 复合化 C . 一体化 D . 精干化</p>
<p>正确答案： A,B,C,D<br>
48. 世界各主要国家十分重视国防改革，积极转变国防管理方式，具体表现包括（ ）</p>
<p>A . 提高战略规划水平 B . 提高国防投入效益 C . 提高科技创新能力 D . 提高军队职业化水平</p>
<p>正确答案： A,B,C,D<br>
49. 作战空间是传统的战场概念的眼神。美军将三域，包括（ ）</p>
<p>A . 物理域 B . 信息域 C . 认知域 D . 心理域</p>
<p>正确答案： A,B,C<br>
50. 以下哪些战争属于信息化战争的经典战例（ ）</p>
<p>A . 海湾战争 B . 科索沃战争 C . 阿富汗战争 D . 伊拉克战争。利比亚战争。第二次世界大战</p>
<p>正确答案： A,B,C,D,E<br>
51. 在未来信息化战争中，伴随着新军事革命的步伐，军队的发展趋势是（ ）</p>
<p>A . 军队规模将加速小型化 B . 军队信息系统构成将高度一体化 C . 军队指挥与作战手段将高度智能化 D . 军队装备将加速机械化</p>
<p>正确答案： A,B,C<br>
52. 从高技术向军事领域自然延伸的角度，新军事技术可分为哪些领域（ ）</p>
<p>A . 军用信息技术 B . 军事航天技术 C . 军事海洋开发技术 D . 军用生物技术。军用新材料技术。军用新能源技术、军用先进防御技术</p>
<p>正确答案： A,B,C,D,E,F<br>
53. 以下哪些是我国依靠自己力量在新军事领域取得的重大成就（ ）</p>
<p>A . 核武器和战略导弹试验成功 B . 人造地球卫星上天 C . 核潜艇下水和航空母舰建成 D . 牛膜岛素人工合成。嫦娥奔月。空间站建设</p>
<p>正确答案： A,B,C,D,E,F<br>
54. 新军事变革使战争形态从机械化向信息化转变，主要体现为（ ）</p>
<p>A . 战场空间日益扩展 B . 战争节奏加快、持续时间缩短 C . 战略、战役、战术行动融为一体 D . 制信息权成为战场主动权的焦点</p>
<p>正确答案： A,B,C,D<br>
55. 世界新军事变革深入发展具有全面性。世界主要国家军事改革和军事转型不仅涉及信息化军事技术形态、联合化组织形态和高效化管理形态，而且还包括（ ）等领域。</p>
<p>A . 军事理论形态 B . 作战形态 C . 保障形态 D . 教育形态</p>
<p>正确答案： A,B,C,D<br>
56. 世界新军事变革深入发展，军队指挥形态将更加（ ），一体化联合作战指挥体系逐步形成。</p>
<p>A . 扁平化 B . 自动化 C . 网络化 D . 无缝化</p>
<p>正确答案： A,B,C,D<br>
57. 世界新军事变革深入发展，武器装备呈现出向（ ）的发展趋势。</p>
<p>A . 数字化 B . 精确化 C . 隐形化 D . 无人化</p>
<p>正确答案： A,B,C,D<br>
58. 世界新军事变革已进入深入发展的阶段。俄军 “新面貌” 改革进入调整完善阶段，力求实现（ ）的建军方针。</p>
<p>A . 精干高效 B . 机动灵活 C . 装备精良 D . 训练有素</p>
<p>正确答案： A,B,C,D<br>
59. 机械化战争时期，由于工业革命带来的新军事革命，出现了新的机械化战争理论。下列哪些属于典型的机械化战争理论（ ）</p>
<p>A . 杜黑的 “空军制胜论” B . 马汉的 “海军制胜论” C . 英国军事家富勒、德国的将军古德里安提出的 “坦克制胜论” D . 戴高乐提出的 “职业化军队 &quot; 理论。德国军事家鲁登道夫提出 “总体战” 理论</p>
<p>正确答案： A,B,C,D,E<br>
60. 以下哪些特征属于联合作战形态的 “四非”（ ）</p>
<p>A . 非接触 B . 非线性 C . 非对称 D . 非 正规</p>
<p>正确答案： A,B,C,D</p>
<h1 id="第五章习题答案">第五章习题答案：</h1>
<ol>
<li>信息化弹药也称精确制导弹药，是指依靠自身动力装置推进，能够获取和利用目标所提供的位置信息，并由制导系统控制飞行路线和弹道，以准确攻击目标直接命中概率通常大于 ( ) 的弹药。</li>
</ol>
<p>A .0.3 B .0.4 C .0.5 D .0.6</p>
<p>正确答案：C<br>
2. 新概念武器是指在工作原理、破坏机理和作战运用方式上与传统武器有明显区别，能够大幅度（ ）或形成新型军事能力的高技术武器载体。</p>
<p>A . 提高作战效能 B . 提高作战效费比 C . 提高作战能力 D . 减少战争消耗</p>
<p>正确答案：C<br>
3. 据日本长崎大学 “核武器废除研究中心” 的研究报告称，截至 2018 年 6 月，世界 9 个国家持有约（ ）枚核弹头。</p>
<p>A .12350 B .14450 C .16600 D .20000</p>
<p>正确答案：B<br>
4. 新概念武器是指在工作原理、破坏机理和作战运用方式上与传统武器有明显区别，能够大幅度（ ）或形成新型军事能力的高技术武器载体。</p>
<p>A . 提高作战效费比 B . 提高作战效率 C . 增强杀伤效果 D . 增强杀伤机理</p>
<p>正确答案： A<br>
5. 陆军信息化作战平台，是指陆军在遂行以陆上为主的作战和保障任务时，使用的信息化武器装备体系中具有运载功能并可作为（ ）的载体部分，如各类军用车辆、坦克、步兵战车等除火器之外的部分。</p>
<p>A . 机械依托 B . 火器依托 C . 动力依托 D . 信息依托</p>
<p>正确答案：B<br>
6. 海军是遂行海上作战任务的战略军种，海军作战平台在占地球表面积（ ）的海洋上独具制海的战略优势。</p>
<p>A .0.53 B .0.6 C .0.71 D .0.82</p>
<p>正确答案：C<br>
7. 海军信息化作战平台，是海军在遂行以海上为主的作战和保障任务时，使用的信息化武器装备体系中具有运载功能，并可作为（ ）地载体部分。</p>
<p>A . 机械依托 B . 火器依托 C . 动力依托 D . 信息依托</p>
<p>正确答案：B<br>
8. 空军信息化作战平台，是空军在遂行以空中为主的作战和保障任务时，使用的信息化武器装备体系中具有运载功能，并可作为（ ）地载体部分。</p>
<p>A . 机械依托 B . 火器依托 C . 动力依托 D . 信息依托</p>
<p>正确答案：B<br>
9. 预警探测系统是指利用各种探测和监视手段，对各种军事威胁目标进行发现、识别、跟踪或监视，为防卫或反击作战提供（ ）的专用信息系统。</p>
<p>A . 情报侦察 B . 情报探测 C . 情报收集 D . 情报保障</p>
<p>正确答案：D<br>
10. 我国北斗卫星导航系统，截止 2019 年 11 月 6 日，共成功发射了（ ）北斗导航卫星， 标志着北斗三号系统 3 颗倾斜地球同步轨道卫星全部发射完毕。</p>
<p>A . 第 41 颗 B . 第 43 颗 C . 第 49 颗 D . 第 50 颗</p>
<p>正确答案：C<br>
11. 精确制导武器，是指采用精确制导技术，直接命中概率在（ ）以上的武器，精确制导技术是在复杂的战场环境中，利用目标的特征、信号、发现、识别和跟踪目标，并将武器直接导引至实施有效打击的武器技术。</p>
<p>A .0.4 B .0.5 C .0.8 D .1</p>
<p>正确答案：B<br>
12. 核武器是利用核反应瞬间（ ）起杀伤破坏作用的武器。</p>
<p>A . 释放出的巨大能量 B . 释放出的巨大辐射 C . 产生的巨大爆炸 D . 产生的强烈闪光</p>
<p>正确答案： A<br>
13. 光辐射（又称热辐射）是爆炸后（ ）时间内的闪光及几千万摄氏度以上的高温火球辐射出来的强光和热，其杀伤破坏因素包括 “烧”、“爆 “，光辐射直接照射无隐蔽的人员会造成烧伤。</p>
<p>A .1 秒至 10 秒 B .10 秒至 20 秒 C .1 分钟至 10 分钟 D .10 分钟至 20 分钟</p>
<p>正确答案： A<br>
14. 冲击波是核爆炸时（ ），高温高压火球猛烈膨胀压缩周围空气而形成的高速高温高压气浪，它对人员、物体能够造成挤压、抛掷作用，挤压作用造成严重内伤，抛掷作用造成外伤，冲击波可造成建筑物倒塌，砖瓦抛掷造成人员间接伤害及堵塞交通。</p>
<p>A . 几秒种内 B . 几十秒种内 C . 几分钟种内 D . 几十分钟种内</p>
<p>正确答案：B<br>
15. 核电磁脉冲是核爆炸瞬间产生的一种（ ），其作用半径可达几千千米，对人员没有直接的杀伤力作用，但能消除计算机上存储的信息，使自动控制系统失灵，家用电器受到干扰和破坏。</p>
<p>A . 强电流 B . 强脉冲 C . 强电磁波 D . 强闪光</p>
<p>正确答案：C<br>
16. 生物武器，是以（ ）杀伤敌方有生力量、毁坏动植物的各种武器和器材的总称。由生物战剂、生物弹药及运载系统等组成，生物战是使用生物武器伤害对方人员、动植物以至造成大面积杀伤的一种战争手段。</p>
<p>A . 生物毒性 B . 生物弹药 C . 运载系统 D . 生物战剂</p>
<p>正确答案：D<br>
17. 次声波武器是一种能发射 ( ) 以下低频声波即次声波的大功率武器装置。</p>
<p>A .10 赫兹 B .20 赫兹 C .25 赫兹 D .30 赫兹</p>
<p>正确答案：C<br>
18. 基因武器，也被称作遗传工程武器或 DN A 武器，它运用遗传工程技术，用类似工程的办法，按需要重组基因，在一些致病细菌或病毒中 ( ) 能抵抗普通疫苗或药物的基因，或者在一些本来不会致病的微生物体内接入致病基因而制造成生物武器。</p>
<p>A . 产生 B .“植入” C . 转化 D . 接入</p>
<p>正确答案：B<br>
19. 失能性毒剂是一类暂时使人的思维和运动机能发生障碍从而（ ）的化学毒剂。</p>
<p>A . 丧失战斗力 B . 丧失意志 C . 丧失思维 D . 机能坏死</p>
<p>正确答案： A<br>
20. 动能武器是指利用发射高超速弹头的动能直接撞毁目标的武器。所谓高超速，通常指具备（ ）以上的音速（331.36 米 / 秒）的速度。</p>
<p>A .2 倍 B .5 倍 C .6 倍 D .10 倍</p>
<p>正确答案：B 21. 信息化武器装备的特点是（ ）。</p>
<p>A . 智能化 B . 网络化 C . 一体化 D . 数字化</p>
<p>正确答案： A,B,C<br>
22. 战争历来会造成巨大的破坏和消耗，现代战争更是如此。造成未来战争破坏和消耗巨大的主要原因是（ ）。</p>
<p>A . 高技术杀伤破坏力大 B . 高精度武器命中率极高 C . 信息化武器造价昂贵 D . 作战物资消耗巨大</p>
<p>正确答案： A,B,C,D<br>
23. 一些发达国家信息化装备科技含量与装备性能不断提高，趋于（ ），代表了信息化装备的发展方向。</p>
<p>A . 隐形化 B . 通用化 C . 无人化 D . 系统化</p>
<p>正确答案： A,B,C<br>
24. 信息化装备按照使用性能划分（ ）</p>
<p>A . 信息化装备 B . 信息化弹药 C . 信息化作战平台 D .C4ISR. 单兵数字化装备</p>
<p>正确答案： A,B,C,D,E<br>
25. 军信息化作战平台有多种分类。按照功能用途，可分为（ ）。</p>
<p>A . 信息作战平台 B . 信息保障平台 C . 指挥控制平台 D . 自动化平台</p>
<p>正确答案： A,B,C<br>
26. 陆军信息化作战平台的发展趋势（ ）</p>
<p>A . 增强打击能力 B . 提高机动能力 C . 提高生存能力 D . 加强信息能力.E．完善自主能力</p>
<p>正确答案： A,B,C,D,E<br>
27. 海战信息化作战平台的分类（ ）</p>
<p>A . 水面舰艇 B . 潜艇 C . 舰载机 D . 航空母舰。正确答案： A,B,C,D<br>
28. 海军信息化作战平台的发展趋势（ ）。</p>
<p>A . 提高网络化程度和联合作战平台 B . 增强对地精确打击和常规威慑能力 C . 增强经济可承受性和多功能化 D . 自动化、智能化和无人化。隐身化和高防护能力</p>
<p>正确答案： A,B,C,D,E<br>
29. 空军信息化作战平台，按照不同标准有不同分类。按照载体结构分为（ ）。</p>
<p>A . 飞行 B . 飞艇和气球 C . 高超音速飞行器 D . 军用飞机</p>
<p>正确答案：B,C,D<br>
30. 空军信息化作战平台的发展趋势（ ）。</p>
<p>A . 隐身化、高机动、多用途 B . 智能化、无人化 C . 电子对抗能力 D . 高超声速军用飞机</p>
<p>正确答案： A,B,C,D<br>
31. 指挥控制系统的分类通常分为（ ）。</p>
<p>A . 战略指挥信息系统 B . 战役指挥信息系统 C . 战术指挥信息系统 D . 作战平台单兵信息系统</p>
<p>正确答案： A,B,C,D<br>
32. 预警探测系统按照战场空间分类，可以分为 ( )。</p>
<p>A . 天基预警系统 B . 空中预警系统 C . 海上预警系统 D . 陆基预警系统</p>
<p>正确答案： A,B,C,D<br>
33. 预警探测系统的发展趋势有（ ）。</p>
<p>A . 发展机载与太空监视、多功能相控阵雷达预警探测系统 B . 对抗隐身目标的预警探测系统 C . 电子信息系统 D . 向多功能综合化发展</p>
<p>正确答案： A,B,D<br>
34. 综合电子信息系统的发展趋势有（ ）</p>
<p>A . 加快网络一体化建设步伐 B . 重视提高侦察预警能力 C . 加快与作战系统相融合 D . 增强系统攻防作战能力</p>
<p>正确答案： A,B,C,D<br>
35. 精确制导武器的制导方式按照所采用的物理量特性分类，其制导方式有（ ）。</p>
<p>A . 无线电制导 B . 红外制导 C . 激光制导 D . 雷达制导。电视制导</p>
<p>正确答案： A,B,C,D,E<br>
36. 精确制导武器的制导方式按照制导系统的控制导引技术的差异，其制导方式有（ ）。</p>
<p>A . 自主式制导 B . 遥控制导 C . 寻的制导 D . 复合制导</p>
<p>正确答案： A,B,C,D<br>
37. 寻的制导的制导方式有（ ）。</p>
<p>A . 主动寻的制导 B . 半主动寻的制导 C . 被动寻的制导 D . 复合制导</p>
<p>正确答案： A,B,C<br>
38. 精确制导武器按导弹射程，可分为（ ）。</p>
<p>A . 近程导弹（射程在 1000 公里以内）B . 中程导弹（射程在 1000-3000 公里以内）C . 远程导弹（射程在 3000-8000 公里以内）D . 洲际导弹（射程在 8000 公里以上）</p>
<p>正确答案： A,B,C,D<br>
39. 精确制导弹药也称灵巧弹药，根据不同的作用原理可分为（ ）。</p>
<p>A . 末制导弹药 B . 末敏弹药 C . 炸弹类 D . 地雷</p>
<p>正确答案： A,B<br>
40. 核武器爆炸后，能产生五种杀伤因素（ ）。</p>
<p>A . 光辐射榜 B . 冲击波 C . 早期核辐射 D . 核电磁脉冲。放射性沾染</p>
<p>正确答案： A,B,C,D,E<br>
41. 生物武器的特点（ ）。</p>
<p>A . 致病力强 B . 传染性大 C . 污染面积大 D . 有潜伏期</p>
<p>正确答案： A,B,C,D<br>
42. 生物武器的新种类有哪些（ ）。</p>
<p>A . 基因武器 B . 纳米生物武器 C . 机器人 D . 生物机器</p>
<p>正确答案： A,B<br>
43. 生物战剂的种类有（ ）。</p>
<p>A . 细菌类 B . 病毒类 C . 立克次体类 D . 牛膜岛素人工合成。依原体类</p>
<p>正确答案： A,B,C,D,E<br>
44. 化学武器按分散方式可分为（ ）基本类型。</p>
<p>A . 布洒型 B . 热分散型 C . 爆炸分散型 D . 燃烧型</p>
<p>正确答案： A,B,C<br>
45. 毒剂的种类有（ ）。</p>
<p>A . 神经性毒剂 B . 烂性毒剂 C . 全身中毒性毒剂 D . 失能性毒剂。刺激性毒剂。皇息性毒剂</p>
<p>正确答案： A,B,C,D,E,F<br>
46. 化学武器与常用武器比较，毒剂的特点有（ ）。</p>
<p>A . 毒性作用强 B . 中毒途径多 C . 持续时间长 D . 杀伤范围广</p>
<p>正确答案： A,B,C,D<br>
47. 新概念武器的基本特征通常表现为（ ）。</p>
<p>A . 创新性 B . 高效性 C . 探索性 D . 竞争性</p>
<p>正确答案： A,B,C<br>
48. 新概念武器的种类有（ ）。</p>
<p>A . 定能武器、动能武器 B . 军用机器人 C . 网络战武器 D . 基因武器。次声波武器。幻觉武器</p>
<p>正确答案： A,B,C,D,E,F<br>
49. 动能武器主要包括（ ）。</p>
<p>A . 电磁炮 B . 反卫星、反导弹动能拦截弹 C . 群射火箭与反卫星卫星 D . 激光器</p>
<p>正确答案： A,B,C<br>
50. 电磁炮，是一种利用电磁力沿导轨发射炮弹的武器，电磁炮与普通火炮或其他常规动能武器相比，具有很多独特的优势（ ）。</p>
<p>A . 射速快，动能大，射击精度高，射程远 B . 射击隐蔽性好 C . 射程可调 D . 威力大</p>
<p>正确答案： A,B,C</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转自黑马】C++提高编程笔记]]></title>
        <id>https://Ilosyi.github.io/post/zhuan-zi-hei-ma-cti-gao-bian-cheng-bi-ji/</id>
        <link href="https://Ilosyi.github.io/post/zhuan-zi-hei-ma-cti-gao-bian-cheng-bi-ji/">
        </link>
        <updated>2024-08-15T13:55:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c提高编程">C++提高编程</h1>
<p><ul class="markdownIt-TOC">
<li><a href="#c%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B">C++提高编程</a>
<ul>
<li><a href="#1-%E6%A8%A1%E6%9D%BF">1 模板</a>
<ul>
<li><a href="#11-%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%A6%82%E5%BF%B5">1.1 模板的概念</a></li>
<li><a href="#12-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF">1.2 函数模板</a>
<ul>
<li><a href="#121-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95">1.2.1 函数模板语法</a></li>
<li><a href="#122-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">1.2.2 函数模板注意事项</a></li>
<li><a href="#123-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%A1%88%E4%BE%8B">1.2.3 函数模板案例</a></li>
<li><a href="#124-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8C%BA%E5%88%AB">1.2.4 普通函数与函数模板的区别</a></li>
<li><a href="#125-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99">1.2.5 普通函数与函数模板的调用规则</a></li>
<li><a href="#126-%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7">1.2.6 模板的局限性</a></li>
</ul>
</li>
<li><a href="#13-%E7%B1%BB%E6%A8%A1%E6%9D%BF">1.3 类模板</a>
<ul>
<li><a href="#131-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95">1.3.1 类模板语法</a></li>
<li><a href="#132-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%8C%BA%E5%88%AB">1.3.2 类模板与函数模板区别</a></li>
<li><a href="#133-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA">1.3.3 类模板中成员函数创建时机</a></li>
<li><a href="#134-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%AF%B9%E8%B1%A1%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">1.3.4 类模板对象做函数参数</a></li>
<li><a href="#135-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%BB%A7%E6%89%BF">1.3.5 类模板与继承</a></li>
<li><a href="#136-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%B1%BB%E5%A4%96%E5%AE%9E%E7%8E%B0">1.3.6 类模板成员函数类外实现</a></li>
<li><a href="#137-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99">1.3.7 类模板分文件编写</a></li>
<li><a href="#138-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%8F%8B%E5%85%83">1.3.8 类模板与友元</a></li>
<li><a href="#139-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%A1%88%E4%BE%8B">1.3.9 类模板案例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-stl%E5%88%9D%E8%AF%86">2 STL初识</a>
<ul>
<li><a href="#21-stl%E7%9A%84%E8%AF%9E%E7%94%9F">2.1 STL的诞生</a></li>
<li><a href="#22-stl%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">2.2 STL基本概念</a></li>
<li><a href="#23-stl%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6">2.3 STL六大组件</a></li>
<li><a href="#24-stl%E4%B8%AD%E5%AE%B9%E5%99%A8-%E7%AE%97%E6%B3%95-%E8%BF%AD%E4%BB%A3%E5%99%A8">2.4  STL中容器、算法、迭代器</a></li>
<li><a href="#25-%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%9D%E8%AF%86">2.5 容器算法迭代器初识</a>
<ul>
<li><a href="#251-vector%E5%AD%98%E6%94%BE%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">2.5.1 vector存放内置数据类型</a></li>
<li><a href="#252-vector%E5%AD%98%E6%94%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">2.5.2 Vector存放自定义数据类型</a></li>
<li><a href="#253-vector%E5%AE%B9%E5%99%A8%E5%B5%8C%E5%A5%97%E5%AE%B9%E5%99%A8">2.5.3 Vector容器嵌套容器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-stl-%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8">3 STL- 常用容器</a>
<ul>
<li><a href="#31-string%E5%AE%B9%E5%99%A8">3.1 string容器</a>
<ul>
<li><a href="#311-string%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">3.1.1 string基本概念</a></li>
<li><a href="#312-string%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">3.1.2 string构造函数</a></li>
<li><a href="#313-string%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C">3.1.3 string赋值操作</a></li>
<li><a href="#314-string%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5">3.1.4 string字符串拼接</a></li>
<li><a href="#315-string%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2">3.1.5 string查找和替换</a></li>
<li><a href="#316-string%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83">3.1.6 string字符串比较</a></li>
<li><a href="#317-string%E5%AD%97%E7%AC%A6%E5%AD%98%E5%8F%96">3.1.7 string字符存取</a></li>
<li><a href="#318-string%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4">3.1.8 string插入和删除</a></li>
<li><a href="#319-string%E5%AD%90%E4%B8%B2">3.1.9 string子串</a></li>
</ul>
</li>
<li><a href="#32-vector%E5%AE%B9%E5%99%A8">3.2 vector容器</a>
<ul>
<li><a href="#321-vector%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">3.2.1 vector基本概念</a></li>
<li><a href="#322-vector%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">3.2.2 vector构造函数</a></li>
<li><a href="#323-vector%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C">3.2.3 vector赋值操作</a></li>
<li><a href="#324-vector%E5%AE%B9%E9%87%8F%E5%92%8C%E5%A4%A7%E5%B0%8F">3.2.4  vector容量和大小</a></li>
<li><a href="#325-vector%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4">3.2.5 vector插入和删除</a></li>
<li><a href="#326-vector%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96">3.2.6 vector数据存取</a></li>
<li><a href="#327-vector%E4%BA%92%E6%8D%A2%E5%AE%B9%E5%99%A8">3.2.7 vector互换容器</a></li>
<li><a href="#328-vector%E9%A2%84%E7%95%99%E7%A9%BA%E9%97%B4">3.2.8 vector预留空间</a></li>
</ul>
</li>
<li><a href="#33-deque%E5%AE%B9%E5%99%A8">3.3 deque容器</a>
<ul>
<li><a href="#331-deque%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">3.3.1 deque容器基本概念</a></li>
<li><a href="#332-deque%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">3.3.2 deque构造函数</a></li>
<li><a href="#333-deque%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C">3.3.3 deque赋值操作</a></li>
<li><a href="#334-deque%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C">3.3.4 deque大小操作</a></li>
<li><a href="#335-deque-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4">3.3.5 deque 插入和删除</a></li>
<li><a href="#336-deque-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96">3.3.6 deque 数据存取</a></li>
<li><a href="#337-deque-%E6%8E%92%E5%BA%8F">3.3.7  deque 排序</a></li>
</ul>
</li>
<li><a href="#34-%E6%A1%88%E4%BE%8B-%E8%AF%84%E5%A7%94%E6%89%93%E5%88%86">3.4 案例-评委打分</a>
<ul>
<li><a href="#341-%E6%A1%88%E4%BE%8B%E6%8F%8F%E8%BF%B0">3.4.1 案例描述</a></li>
<li><a href="#342-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4">3.4.2 实现步骤</a></li>
</ul>
</li>
<li><a href="#35-stack%E5%AE%B9%E5%99%A8">3.5 stack容器</a>
<ul>
<li><a href="#351-stack-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">3.5.1 stack 基本概念</a></li>
<li><a href="#352-stack-%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3">3.5.2 stack 常用接口</a></li>
</ul>
</li>
<li><a href="#36-queue-%E5%AE%B9%E5%99%A8">3.6 queue 容器</a>
<ul>
<li><a href="#361-queue-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">3.6.1 queue 基本概念</a></li>
<li><a href="#362-queue-%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3">3.6.2 queue 常用接口</a></li>
</ul>
</li>
<li><a href="#37-list%E5%AE%B9%E5%99%A8">3.7 list容器</a>
<ul>
<li><a href="#371-list%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">3.7.1 list基本概念</a></li>
<li><a href="#372-list%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">3.7.2  list构造函数</a></li>
<li><a href="#373-list-%E8%B5%8B%E5%80%BC%E5%92%8C%E4%BA%A4%E6%8D%A2">3.7.3 list 赋值和交换</a></li>
<li><a href="#374-list-%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C">3.7.4 list 大小操作</a></li>
<li><a href="#375-list-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4">3.7.5 list 插入和删除</a></li>
<li><a href="#376-list-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96">3.7.6 list 数据存取</a></li>
<li><a href="#377-list-%E5%8F%8D%E8%BD%AC%E5%92%8C%E6%8E%92%E5%BA%8F">3.7.7 list 反转和排序</a></li>
<li><a href="#378-%E6%8E%92%E5%BA%8F%E6%A1%88%E4%BE%8B">3.7.8 排序案例</a></li>
</ul>
</li>
<li><a href="#38-set-multiset-%E5%AE%B9%E5%99%A8">3.8 set/ multiset 容器</a>
<ul>
<li><a href="#381-set%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">3.8.1 set基本概念</a></li>
<li><a href="#382-set%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC">3.8.2 set构造和赋值</a></li>
<li><a href="#383-set%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BA%A4%E6%8D%A2">3.8.3 set大小和交换</a></li>
<li><a href="#384-set%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4">3.8.4 set插入和删除</a></li>
<li><a href="#385-set%E6%9F%A5%E6%89%BE%E5%92%8C%E7%BB%9F%E8%AE%A1">3.8.5 set查找和统计</a></li>
<li><a href="#386-set%E5%92%8Cmultiset%E5%8C%BA%E5%88%AB">3.8.6 set和multiset区别</a></li>
<li><a href="#387-pair%E5%AF%B9%E7%BB%84%E5%88%9B%E5%BB%BA">3.8.7 pair对组创建</a></li>
<li><a href="#388-set%E5%AE%B9%E5%99%A8%E6%8E%92%E5%BA%8F">3.8.8 set容器排序</a></li>
</ul>
</li>
<li><a href="#39-map-multimap%E5%AE%B9%E5%99%A8">3.9 map/ multimap容器</a>
<ul>
<li><a href="#391-map%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">3.9.1 map基本概念</a></li>
<li><a href="#392-map%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC">3.9.2  map构造和赋值</a></li>
<li><a href="#393-map%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BA%A4%E6%8D%A2">3.9.3 map大小和交换</a></li>
<li><a href="#394-map%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4">3.9.4 map插入和删除</a></li>
<li><a href="#395-map%E6%9F%A5%E6%89%BE%E5%92%8C%E7%BB%9F%E8%AE%A1">3.9.5 map查找和统计</a></li>
<li><a href="#396-map%E5%AE%B9%E5%99%A8%E6%8E%92%E5%BA%8F">3.9.6 map容器排序</a></li>
</ul>
</li>
<li><a href="#310-%E6%A1%88%E4%BE%8B-%E5%91%98%E5%B7%A5%E5%88%86%E7%BB%84">3.10 案例-员工分组</a>
<ul>
<li><a href="#3101-%E6%A1%88%E4%BE%8B%E6%8F%8F%E8%BF%B0">3.10.1 案例描述</a></li>
<li><a href="#3102-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4">3.10.2 实现步骤</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-stl-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1">4 STL- 函数对象</a>
<ul>
<li><a href="#41-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1">4.1 函数对象</a>
<ul>
<li><a href="#411-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5">4.1.1 函数对象概念</a></li>
<li><a href="#412-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8">4.1.2  函数对象使用</a></li>
</ul>
</li>
<li><a href="#42-%E8%B0%93%E8%AF%8D">4.2  谓词</a>
<ul>
<li><a href="#421-%E8%B0%93%E8%AF%8D%E6%A6%82%E5%BF%B5">4.2.1 谓词概念</a></li>
<li><a href="#422-%E4%B8%80%E5%85%83%E8%B0%93%E8%AF%8D">4.2.2 一元谓词</a></li>
<li><a href="#423-%E4%BA%8C%E5%85%83%E8%B0%93%E8%AF%8D">4.2.3 二元谓词</a></li>
</ul>
</li>
<li><a href="#43-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1">4.3 内建函数对象</a>
<ul>
<li><a href="#431-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E6%84%8F%E4%B9%89">4.3.1 内建函数对象意义</a></li>
<li><a href="#432-%E7%AE%97%E6%9C%AF%E4%BB%BF%E5%87%BD%E6%95%B0">4.3.2 算术仿函数</a></li>
<li><a href="#433-%E5%85%B3%E7%B3%BB%E4%BB%BF%E5%87%BD%E6%95%B0">4.3.3 关系仿函数</a></li>
<li><a href="#434-%E9%80%BB%E8%BE%91%E4%BB%BF%E5%87%BD%E6%95%B0">4.3.4 逻辑仿函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-stl-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95">5 STL- 常用算法</a>
<ul>
<li><a href="#51-%E5%B8%B8%E7%94%A8%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95">5.1 常用遍历算法</a>
<ul>
<li><a href="#511-for_each">5.1.1 for_each</a></li>
<li><a href="#512-transform">5.1.2 transform</a></li>
</ul>
</li>
<li><a href="#52-%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95">5.2 常用查找算法</a>
<ul>
<li><a href="#521-find">5.2.1 find</a></li>
<li><a href="#522-find_if">5.2.2 find_if</a></li>
<li><a href="#523-adjacent_find">5.2.3 adjacent_find</a></li>
<li><a href="#524-binary_search">5.2.4 binary_search</a></li>
<li><a href="#525-count">5.2.5 count</a></li>
<li><a href="#526-count_if">5.2.6 count_if</a></li>
</ul>
</li>
<li><a href="#53-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">5.3 常用排序算法</a>
<ul>
<li><a href="#531-sort">5.3.1 sort</a></li>
<li><a href="#532-random_shuffle">5.3.2 random_shuffle</a></li>
<li><a href="#533-merge">5.3.3 merge</a></li>
<li><a href="#534-reverse">5.3.4 reverse</a></li>
</ul>
</li>
<li><a href="#54-%E5%B8%B8%E7%94%A8%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95">5.4 常用拷贝和替换算法</a>
<ul>
<li><a href="#541-copy">5.4.1 copy</a></li>
<li><a href="#542-replace">5.4.2 replace</a></li>
<li><a href="#543-replace_if">5.4.3 replace_if</a></li>
<li><a href="#544-swap">5.4.4 swap</a></li>
</ul>
</li>
<li><a href="#55-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%9C%AF%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95">5.5 常用算术生成算法</a>
<ul>
<li><a href="#551-accumulate">5.5.1 accumulate</a></li>
<li><a href="#552-fill">5.5.2 fill</a></li>
</ul>
</li>
<li><a href="#56-%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95">5.6 常用集合算法</a>
<ul>
<li><a href="#561-set_intersection">5.6.1 set_intersection</a></li>
<li><a href="#562-set_union">5.6.2 set_union</a></li>
<li><a href="#563-set_difference">5.6.3  set_difference</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<ul>
<li>本阶段主要针对C++<mark>泛型编程</mark>和<mark>STL</mark>技术做详细讲解，探讨C++更深层的使用</li>
</ul>
<h2 id="1-模板">1 模板</h2>
<h3 id="11-模板的概念">1.1 模板的概念</h3>
<p>模板就是建立<strong>通用的模具</strong>，大大<strong>提高复用性</strong></p>
<p>例如生活中的模板</p>
<p>一寸照片模板：</p>
<figure data-type="image" tabindex="1"><img src="assets/1547105026929.png" alt="1547105026929" loading="lazy"></figure>
<p>PPT模板：</p>
<figure data-type="image" tabindex="2"><img src="assets/1547103297864.png" alt="1547103297864" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="assets/1547103359158.png" alt="1547103359158" loading="lazy"></figure>
<p>模板的特点：</p>
<ul>
<li>模板不可以直接使用，它只是一个框架</li>
<li>模板的通用并不是万能的</li>
</ul>
<h3 id="12-函数模板">1.2 函数模板</h3>
<ul>
<li>
<p>C++另一种编程思想称为 <mark>泛型编程</mark> ，主要利用的技术就是模板</p>
</li>
<li>
<p>C++提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong></p>
</li>
</ul>
<h4 id="121-函数模板语法">1.2.1 函数模板语法</h4>
<p>函数模板作用：</p>
<p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-C++">template&lt;typename T&gt;
函数声明或定义
</code></pre>
<p><strong>解释：</strong></p>
<p>template  ---  声明创建模板</p>
<p>typename  --- 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T    ---   通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">
//交换整型函数
void swapInt(int&amp; a, int&amp; b) {
	int temp = a;
	a = b;
	b = temp;
}

//交换浮点型函数
void swapDouble(double&amp; a, double&amp; b) {
	double temp = a;
	a = b;
	b = temp;
}

//利用模板提供通用的交换函数
template&lt;typename T&gt;
void mySwap(T&amp; a, T&amp; b)
{
	T temp = a;
	a = b;
	b = temp;
}

void test01()
{
	int a = 10;
	int b = 20;
	
	//swapInt(a, b);

	//利用模板实现交换
	//1、自动类型推导
	mySwap(a, b);

	//2、显示指定类型
	mySwap&lt;int&gt;(a, b);

	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;

}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>函数模板利用关键字 template</li>
<li>使用函数模板有两种方式：自动类型推导、显示指定类型</li>
<li>模板的目的是为了提高复用性，将类型参数化</li>
</ul>
<h4 id="122-函数模板注意事项">1.2.2 函数模板注意事项</h4>
<p>注意事项：</p>
<ul>
<li>
<p>自动类型推导，必须推导出一致的数据类型T,才可以使用</p>
</li>
<li>
<p>模板必须要确定出T的数据类型，才可以使用</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//利用模板提供通用的交换函数
template&lt;class T&gt;
void mySwap(T&amp; a, T&amp; b)
{
	T temp = a;
	a = b;
	b = temp;
}


// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用
void test01()
{
	int a = 10;
	int b = 20;
	char c = 'c';

	mySwap(a, b); // 正确，可以推导出一致的T
	//mySwap(a, c); // 错误，推导不出一致的T类型
}


// 2、模板必须要确定出T的数据类型，才可以使用
template&lt;class T&gt;
void func()
{
	cout &lt;&lt; &quot;func 调用&quot; &lt;&lt; endl;
}

void test02()
{
	//func(); //错误，模板不能独立使用，必须确定出T的类型
	func&lt;int&gt;(); //利用显示指定类型的方式，给T一个类型，才可以使用该模板
}

int main() {

	test01();
	test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li>
</ul>
<h4 id="123-函数模板案例">1.2.3 函数模板案例</h4>
<p>案例描述：</p>
<ul>
<li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li>
<li>排序规则从大到小，排序算法为<strong>选择排序</strong></li>
<li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试</li>
</ul>
<p>示例：</p>
<pre><code class="language-C++">//交换的函数模板
template&lt;typename T&gt;
void mySwap(T &amp;a, T&amp;b)
{
	T temp = a;
	a = b;
	b = temp;
}


template&lt;class T&gt; // 也可以替换成typename
//利用选择排序，进行对数组从大到小的排序
void mySort(T arr[], int len)
{
	for (int i = 0; i &lt; len; i++)
	{
		int max = i; //最大数的下标
		for (int j = i + 1; j &lt; len; j++)
		{
			if (arr[max] &lt; arr[j])
			{
				max = j;
			}
		}
		if (max != i) //如果最大数的下标不是i，交换两者
		{
			mySwap(arr[max], arr[i]);
		}
	}
}
template&lt;typename T&gt;
void printArray(T arr[], int len) {

	for (int i = 0; i &lt; len; i++) {
		cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}
void test01()
{
	//测试char数组
	char charArr[] = &quot;bdcfeagh&quot;;
	int num = sizeof(charArr) / sizeof(char);
	mySort(charArr, num);
	printArray(charArr, num);
}

void test02()
{
	//测试int数组
	int intArr[] = { 7, 5, 8, 1, 3, 9, 2, 4, 6 };
	int num = sizeof(intArr) / sizeof(int);
	mySort(intArr, num);
	printArray(intArr, num);
}

int main() {

	test01();
	test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：模板可以提高代码复用，需要熟练掌握</p>
<h4 id="124-普通函数与函数模板的区别">1.2.4 普通函数与函数模板的区别</h4>
<p><strong>普通函数与函数模板区别：</strong></p>
<ul>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//普通函数
int myAdd01(int a, int b)
{
	return a + b;
}

//函数模板
template&lt;class T&gt;
T myAdd02(T a, T b)  
{
	return a + b;
}

//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换
void test01()
{
	int a = 10;
	int b = 20;
	char c = 'c';
	
	cout &lt;&lt; myAdd01(a, c) &lt;&lt; endl; //正确，将char类型的'c'隐式转换为int类型  'c' 对应 ASCII码 99

	//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换

	myAdd02&lt;int&gt;(a, c); //正确，如果用显示指定类型，可以发生隐式类型转换
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p>
<h4 id="125-普通函数与函数模板的调用规则">1.2.5 普通函数与函数模板的调用规则</h4>
<p>调用规则如下：</p>
<ol>
<li>如果函数模板和普通函数都可以实现，优先调用普通函数</li>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以发生重载</li>
<li>如果函数模板可以产生更好的匹配,优先调用函数模板</li>
</ol>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//普通函数与函数模板调用规则
void myPrint(int a, int b)
{
	cout &lt;&lt; &quot;调用的普通函数&quot; &lt;&lt; endl;
}

template&lt;typename T&gt;
void myPrint(T a, T b) 
{ 
	cout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl;
}

template&lt;typename T&gt;
void myPrint(T a, T b, T c) 
{ 
	cout &lt;&lt; &quot;调用重载的模板&quot; &lt;&lt; endl; 
}

void test01()
{
	//1、如果函数模板和普通函数都可以实现，优先调用普通函数
	// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到
	int a = 10;
	int b = 20;
	myPrint(a, b); //调用普通函数

	//2、可以通过空模板参数列表来强制调用函数模板
	myPrint&lt;&gt;(a, b); //调用函数模板

	//3、函数模板也可以发生重载
	int c = 30;
	myPrint(a, b, c); //调用重载的函数模板

	//4、 如果函数模板可以产生更好的匹配,优先调用函数模板
	char c1 = 'a';
	char c2 = 'b';
	myPrint(c1, c2); //调用函数模板
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p>
<h4 id="126-模板的局限性">1.2.6 模板的局限性</h4>
<p><strong>局限性：</strong></p>
<ul>
<li>模板的通用性并不是万能的</li>
</ul>
<p><strong>例如：</strong></p>
<pre><code class="language-C++">	template&lt;class T&gt;
	void f(T a, T b)
	{ 
    	a = b;
    }
</code></pre>
<p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p>
<p>再例如：</p>
<pre><code class="language-C++">	template&lt;class T&gt;
	void f(T a, T b)
	{ 
    	if(a &gt; b) { ... }
    }
</code></pre>
<p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p>
<p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include&lt;iostream&gt;
using namespace std;

#include &lt;string&gt;

class Person
{
public:
	Person(string name, int age)
	{
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	}
	string m_Name;
	int m_Age;
};

//普通函数模板
template&lt;class T&gt;
bool myCompare(T&amp; a, T&amp; b)
{
	if (a == b)
	{
		return true;
	}
	else
	{
		return false;
	}
}


//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型
//具体化优先于常规模板
template&lt;&gt; bool myCompare(Person &amp;p1, Person &amp;p2)
{
	if ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)
	{
		return true;
	}
	else
	{
		return false;
	}
}

void test01()
{
	int a = 10;
	int b = 20;
	//内置数据类型可以直接使用通用的函数模板
	bool ret = myCompare(a, b);
	if (ret)
	{
		cout &lt;&lt; &quot;a == b &quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;a != b &quot; &lt;&lt; endl;
	}
}

void test02()
{
	Person p1(&quot;Tom&quot;, 10);
	Person p2(&quot;Tom&quot;, 10);
	//自定义数据类型，不会调用普通的函数模板
	//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型
	bool ret = myCompare(p1, p2);
	if (ret)
	{
		cout &lt;&lt; &quot;p1 == p2 &quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;p1 != p2 &quot; &lt;&lt; endl;
	}
}

int main() {

	test01();

	test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>利用具体化的模板，可以解决自定义类型的通用化</li>
<li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li>
</ul>
<h3 id="13-类模板">1.3 类模板</h3>
<h4 id="131-类模板语法">1.3.1 类模板语法</h4>
<p>类模板作用：</p>
<ul>
<li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li>
</ul>
<p><strong>语法：</strong></p>
<pre><code class="language-c++">template&lt;typename T&gt;
类
</code></pre>
<p><strong>解释：</strong></p>
<p>template  ---  声明创建模板</p>
<p>typename  --- 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T    ---   通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;string&gt;
//类模板
template&lt;class NameType, class AgeType&gt; 
class Person
{
public:
	Person(NameType name, AgeType age)
	{
		this-&gt;mName = name;
		this-&gt;mAge = age;
	}
	void showPerson()
	{
		cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;
	}
public:
	NameType mName;
	AgeType mAge;
};

void test01()
{
	// 指定NameType 为string类型，AgeType 为 int类型
	Person&lt;string, int&gt;P1(&quot;孙悟空&quot;, 999);
	P1.showPerson();
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p>
<h4 id="132-类模板与函数模板区别">1.3.2 类模板与函数模板区别</h4>
<p>类模板与函数模板区别主要有两点：</p>
<ol>
<li>类模板没有自动类型推导的使用方式</li>
<li>类模板在模板参数列表中可以有默认参数</li>
</ol>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;string&gt;
//类模板
template&lt;class NameType, class AgeType = int&gt; 
class Person
{
public:
	Person(NameType name, AgeType age)
	{
		this-&gt;mName = name;
		this-&gt;mAge = age;
	}
	void showPerson()
	{
		cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;
	}
public:
	NameType mName;
	AgeType mAge;
};

//1、类模板没有自动类型推导的使用方式
void test01()
{
	// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导
	Person &lt;string ,int&gt;p(&quot;孙悟空&quot;, 1000); //必须使用显示指定类型的方式，使用类模板
	p.showPerson();
}

//2、类模板在模板参数列表中可以有默认参数
void test02()
{
	Person &lt;string&gt; p(&quot;猪八戒&quot;, 999); //类模板中的模板参数列表 可以指定默认参数
	p.showPerson();
}

int main() {

	test01();

	test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>类模板使用只能用显示指定类型方式</li>
<li>类模板中的模板参数列表可以有默认参数</li>
</ul>
<h4 id="133-类模板中成员函数创建时机">1.3.3 类模板中成员函数创建时机</h4>
<p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Person1
{
public:
	void showPerson1()
	{
		cout &lt;&lt; &quot;Person1 show&quot; &lt;&lt; endl;
	}
};

class Person2
{
public:
	void showPerson2()
	{
		cout &lt;&lt; &quot;Person2 show&quot; &lt;&lt; endl;
	}
};

template&lt;class T&gt;
class MyClass
{
public:
	T obj;

	//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成

	void fun1() { obj.showPerson1(); }
	void fun2() { obj.showPerson2(); }

};

void test01()
{
	MyClass&lt;Person1&gt; m;
	
	m.fun1();

	//m.fun2();//编译会出错，说明函数调用才会去创建成员函数
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p>
<h4 id="134-类模板对象做函数参数">1.3.4 类模板对象做函数参数</h4>
<p>学习目标：</p>
<ul>
<li>类模板实例化出的对象，向函数传参的方式</li>
</ul>
<p>一共有三种传入方式：</p>
<ol>
<li>指定传入的类型   --- 直接显示对象的数据类型</li>
<li>参数模板化           --- 将对象中的参数变为模板进行传递</li>
<li>整个类模板化       --- 将这个对象类型 模板化进行传递</li>
</ol>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;string&gt;
//类模板
template&lt;class NameType, class AgeType = int&gt; 
class Person
{
public:
	Person(NameType name, AgeType age)
	{
		this-&gt;mName = name;
		this-&gt;mAge = age;
	}
	void showPerson()
	{
		cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;
	}
public:
	NameType mName;
	AgeType mAge;
};

//1、指定传入的类型
void printPerson1(Person&lt;string, int&gt; &amp;p) 
{
	p.showPerson();
}
void test01()
{
	Person &lt;string, int &gt;p(&quot;孙悟空&quot;, 100);
	printPerson1(p);
}

//2、参数模板化
template &lt;class T1, class T2&gt;
void printPerson2(Person&lt;T1, T2&gt;&amp;p)
{
	p.showPerson();
	cout &lt;&lt; &quot;T1的类型为： &quot; &lt;&lt; typeid(T1).name() &lt;&lt; endl;
	cout &lt;&lt; &quot;T2的类型为： &quot; &lt;&lt; typeid(T2).name() &lt;&lt; endl;
}
void test02()
{
	Person &lt;string, int &gt;p(&quot;猪八戒&quot;, 90);
	printPerson2(p);
}

//3、整个类模板化
template&lt;class T&gt;
void printPerson3(T &amp; p)
{
	cout &lt;&lt; &quot;T的类型为： &quot; &lt;&lt; typeid(T).name() &lt;&lt; endl;
	p.showPerson();

}
void test03()
{
	Person &lt;string, int &gt;p(&quot;唐僧&quot;, 30);
	printPerson3(p);
}

int main() {

	test01();
	test02();
	test03();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li>
<li>使用比较广泛是第一种：指定传入的类型</li>
</ul>
<h4 id="135-类模板与继承">1.3.5 类模板与继承</h4>
<p>当类模板碰到继承时，需要注意一下几点：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">template&lt;class T&gt;
class Base
{
	T m;
};

//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承
class Son :public Base&lt;int&gt; //必须指定一个类型
{
};
void test01()
{
	Son c;
}

//类模板继承类模板 ,可以用T2指定父类中的T类型
template&lt;class T1, class T2&gt;
class Son2 :public Base&lt;T2&gt;
{
public:
	Son2()
	{
		cout &lt;&lt; typeid(T1).name() &lt;&lt; endl;
		cout &lt;&lt; typeid(T2).name() &lt;&lt; endl;
	}
};

void test02()
{
	Son2&lt;int, char&gt; child1;
}


int main() {

	test01();

	test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型</p>
<h4 id="136-类模板成员函数类外实现">1.3.6 类模板成员函数类外实现</h4>
<p>学习目标：能够掌握类模板中的成员函数类外实现</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;string&gt;

//类模板中成员函数类外实现
template&lt;class T1, class T2&gt;
class Person {
public:
	//成员函数类内声明
	Person(T1 name, T2 age);
	void showPerson();

public:
	T1 m_Name;
	T2 m_Age;
};

//构造函数 类外实现
template&lt;class T1, class T2&gt;
Person&lt;T1, T2&gt;::Person(T1 name, T2 age) {
	this-&gt;m_Name = name;
	this-&gt;m_Age = age;
}

//成员函数 类外实现
template&lt;class T1, class T2&gt;
void Person&lt;T1, T2&gt;::showPerson() {
	cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;
}

void test01()
{
	Person&lt;string, int&gt; p(&quot;Tom&quot;, 20);
	p.showPerson();
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p>
<h4 id="137-类模板分文件编写">1.3.7 类模板分文件编写</h4>
<p>学习目标：</p>
<ul>
<li>掌握类模板成员函数分文件编写产生的问题以及解决方式</li>
</ul>
<p>问题：</p>
<ul>
<li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li>
</ul>
<p>解决：</p>
<ul>
<li>解决方式1：直接包含.cpp源文件</li>
<li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li>
</ul>
<p><strong>示例：</strong></p>
<p>person.hpp中代码：</p>
<pre><code class="language-C++">#pragma once
#include &lt;iostream&gt;
using namespace std;
#include &lt;string&gt;

template&lt;class T1, class T2&gt;
class Person {
public:
	Person(T1 name, T2 age);
	void showPerson();
public:
	T1 m_Name;
	T2 m_Age;
};

//构造函数 类外实现
template&lt;class T1, class T2&gt;
Person&lt;T1, T2&gt;::Person(T1 name, T2 age) {
	this-&gt;m_Name = name;
	this-&gt;m_Age = age;
}

//成员函数 类外实现
template&lt;class T1, class T2&gt;
void Person&lt;T1, T2&gt;::showPerson() {
	cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;
}
</code></pre>
<p>类模板分文件编写.cpp中代码</p>
<pre><code class="language-C++">#include&lt;iostream&gt;
using namespace std;

//#include &quot;person.h&quot;
#include &quot;person.cpp&quot; //解决方式1，包含cpp源文件

//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp
#include &quot;person.hpp&quot;
void test01()
{
	Person&lt;string, int&gt; p(&quot;Tom&quot;, 10);
	p.showPerson();
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p>
<h4 id="138-类模板与友元">1.3.8 类模板与友元</h4>
<p>学习目标：</p>
<ul>
<li>掌握类模板配合友元函数的类内和类外实现</li>
</ul>
<p>全局函数类内实现 - 直接在类内声明友元即可</p>
<p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;string&gt;

//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元
template&lt;class T1, class T2&gt; class Person;

//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到
//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); 

template&lt;class T1, class T2&gt;
void printPerson2(Person&lt;T1, T2&gt; &amp; p)
{
	cout &lt;&lt; &quot;类外实现 ---- 姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;
}

template&lt;class T1, class T2&gt;
class Person
{
	//1、全局函数配合友元   类内实现
	friend void printPerson(Person&lt;T1, T2&gt; &amp; p)
	{
		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;
	}


	//全局函数配合友元  类外实现
	friend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);

public:

	Person(T1 name, T2 age)
	{
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	}


private:
	T1 m_Name;
	T2 m_Age;

};

//1、全局函数在类内实现
void test01()
{
	Person &lt;string, int &gt;p(&quot;Tom&quot;, 20);
	printPerson(p);
}


//2、全局函数在类外实现
void test02()
{
	Person &lt;string, int &gt;p(&quot;Jerry&quot;, 30);
	printPerson2(p);
}

int main() {

	//test01();

	test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p>
<h4 id="139-类模板案例">1.3.9 类模板案例</h4>
<p>案例描述:  实现一个通用的数组类，要求如下：</p>
<ul>
<li>可以对内置数据类型以及自定义数据类型的数据进行存储</li>
<li>将数组中的数据存储到堆区</li>
<li>构造函数中可以传入数组的容量</li>
<li>提供对应的拷贝构造函数以及operator=防止浅拷贝问题</li>
<li>提供尾插法和尾删法对数组中的数据进行增加和删除</li>
<li>可以通过下标的方式访问数组中的元素</li>
<li>可以获取数组中当前元素个数和数组的容量</li>
</ul>
<p><strong>示例：</strong></p>
<p>myArray.hpp中代码</p>
<pre><code class="language-C++">#pragma once
#include &lt;iostream&gt;
using namespace std;

template&lt;class T&gt;
class MyArray
{
public:
    
	//构造函数
	MyArray(int capacity)
	{
		this-&gt;m_Capacity = capacity;
		this-&gt;m_Size = 0;
		pAddress = new T[this-&gt;m_Capacity];
	}

	//拷贝构造
	MyArray(const MyArray &amp; arr)
	{
		this-&gt;m_Capacity = arr.m_Capacity;
		this-&gt;m_Size = arr.m_Size;
		this-&gt;pAddress = new T[this-&gt;m_Capacity];
		for (int i = 0; i &lt; this-&gt;m_Size; i++)
		{
			//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，
			// 普通类型可以直接= 但是指针类型需要深拷贝
			this-&gt;pAddress[i] = arr.pAddress[i];
		}
	}

	//重载= 操作符  防止浅拷贝问题
	MyArray&amp; operator=(const MyArray&amp; myarray) {

		if (this-&gt;pAddress != NULL) {
			delete[] this-&gt;pAddress;
			this-&gt;m_Capacity = 0;
			this-&gt;m_Size = 0;
		}

		this-&gt;m_Capacity = myarray.m_Capacity;
		this-&gt;m_Size = myarray.m_Size;
		this-&gt;pAddress = new T[this-&gt;m_Capacity];
		for (int i = 0; i &lt; this-&gt;m_Size; i++) {
			this-&gt;pAddress[i] = myarray[i];
		}
		return *this;
	}

	//重载[] 操作符  arr[0]
	T&amp; operator [](int index)
	{
		return this-&gt;pAddress[index]; //不考虑越界，用户自己去处理
	}

	//尾插法
	void Push_back(const T &amp; val)
	{
		if (this-&gt;m_Capacity == this-&gt;m_Size)
		{
			return;
		}
		this-&gt;pAddress[this-&gt;m_Size] = val;
		this-&gt;m_Size++;
	}

	//尾删法
	void Pop_back()
	{
		if (this-&gt;m_Size == 0)
		{
			return;
		}
		this-&gt;m_Size--;
	}

	//获取数组容量
	int getCapacity()
	{
		return this-&gt;m_Capacity;
	}

	//获取数组大小
	int	getSize()
	{
		return this-&gt;m_Size;
	}


	//析构
	~MyArray()
	{
		if (this-&gt;pAddress != NULL)
		{
			delete[] this-&gt;pAddress;
			this-&gt;pAddress = NULL;
			this-&gt;m_Capacity = 0;
			this-&gt;m_Size = 0;
		}
	}

private:
	T * pAddress;  //指向一个堆空间，这个空间存储真正的数据
	int m_Capacity; //容量
	int m_Size;   // 大小
};
</code></pre>
<p>类模板案例—数组类封装.cpp中</p>
<pre><code class="language-C++">#include &quot;myArray.hpp&quot;
#include &lt;string&gt;

void printIntArray(MyArray&lt;int&gt;&amp; arr) {
	for (int i = 0; i &lt; arr.getSize(); i++) {
		cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

//测试内置数据类型
void test01()
{
	MyArray&lt;int&gt; array1(10);
	for (int i = 0; i &lt; 10; i++)
	{
		array1.Push_back(i);
	}
	cout &lt;&lt; &quot;array1打印输出：&quot; &lt;&lt; endl;
	printIntArray(array1);
	cout &lt;&lt; &quot;array1的大小：&quot; &lt;&lt; array1.getSize() &lt;&lt; endl;
	cout &lt;&lt; &quot;array1的容量：&quot; &lt;&lt; array1.getCapacity() &lt;&lt; endl;

	cout &lt;&lt; &quot;--------------------------&quot; &lt;&lt; endl;

	MyArray&lt;int&gt; array2(array1);
	array2.Pop_back();
	cout &lt;&lt; &quot;array2打印输出：&quot; &lt;&lt; endl;
	printIntArray(array2);
	cout &lt;&lt; &quot;array2的大小：&quot; &lt;&lt; array2.getSize() &lt;&lt; endl;
	cout &lt;&lt; &quot;array2的容量：&quot; &lt;&lt; array2.getCapacity() &lt;&lt; endl;
}

//测试自定义数据类型
class Person {
public:
	Person() {} 
		Person(string name, int age) {
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	}
public:
	string m_Name;
	int m_Age;
};

void printPersonArray(MyArray&lt;Person&gt;&amp; personArr)
{
	for (int i = 0; i &lt; personArr.getSize(); i++) {
		cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; personArr[i].m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; personArr[i].m_Age &lt;&lt; endl;
	}

}

void test02()
{
	//创建数组
	MyArray&lt;Person&gt; pArray(10);
	Person p1(&quot;孙悟空&quot;, 30);
	Person p2(&quot;韩信&quot;, 20);
	Person p3(&quot;妲己&quot;, 18);
	Person p4(&quot;王昭君&quot;, 15);
	Person p5(&quot;赵云&quot;, 24);

	//插入数据
	pArray.Push_back(p1);
	pArray.Push_back(p2);
	pArray.Push_back(p3);
	pArray.Push_back(p4);
	pArray.Push_back(p5);

	printPersonArray(pArray);

	cout &lt;&lt; &quot;pArray的大小：&quot; &lt;&lt; pArray.getSize() &lt;&lt; endl;
	cout &lt;&lt; &quot;pArray的容量：&quot; &lt;&lt; pArray.getCapacity() &lt;&lt; endl;

}

int main() {

	//test01();

	test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<p>能够利用所学知识点实现通用的数组</p>
<h2 id="2-stl初识">2 STL初识</h2>
<h3 id="21-stl的诞生">2.1 STL的诞生</h3>
<ul>
<li>
<p>长久以来，软件界一直希望建立一种可重复利用的东西</p>
</li>
<li>
<p>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p>
</li>
<li>
<p>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</p>
</li>
<li>
<p>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></p>
<p>​</p>
</li>
</ul>
<h3 id="22-stl基本概念">2.2 STL基本概念</h3>
<ul>
<li>STL(Standard Template Library,<strong>标准模板库</strong>)</li>
<li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li>
<li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li>
<li>STL 几乎所有的代码都采用了模板类或者模板函数</li>
</ul>
<h3 id="23-stl六大组件">2.3 STL六大组件</h3>
<p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p>
<ol>
<li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li>
<li>算法：各种常用的算法，如sort、find、copy、for_each等</li>
<li>迭代器：扮演了容器与算法之间的胶合剂。</li>
<li>仿函数：行为类似函数，可作为算法的某种策略。</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li>
<li>空间配置器：负责空间的配置与管理。</li>
</ol>
<h3 id="24-stl中容器-算法-迭代器">2.4  STL中容器、算法、迭代器</h3>
<p>**容器：**置物之所也</p>
<p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p>
<p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p>
<p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p>
<p>​	<strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。<br>
<strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系</p>
<p>**算法：**问题之解法也</p>
<p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p>
<p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p>
<p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p>
<p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p>
<p>**迭代器：**容器和算法之间粘合剂</p>
<p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p>
<p>每个容器都有自己专属的迭代器</p>
<p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p>
<p>迭代器种类：</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
<th>支持运算</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入迭代器</td>
<td>对数据的只读访问</td>
<td>只读，支持++、==、！=</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>读写操作，并能向前推进迭代器</td>
<td>读写，支持++、==、！=</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>读写操作，并能向前和向后操作</td>
<td>读写，支持++、--，</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td>
<td>读写，支持++、--、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td>
</tr>
</tbody>
</table>
<p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p>
<h3 id="25-容器算法迭代器初识">2.5 容器算法迭代器初识</h3>
<p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p>
<p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p>
<h4 id="251-vector存放内置数据类型">2.5.1 vector存放内置数据类型</h4>
<p>容器：     <code>vector</code></p>
<p>算法：     <code>for_each</code></p>
<p>迭代器： <code>vector&lt;int&gt;::iterator</code></p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;vector&gt;
#include &lt;algorithm&gt;

void MyPrint(int val)
{
	cout &lt;&lt; val &lt;&lt; endl;
}

void test01() {

	//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型
	vector&lt;int&gt; v;
	//向容器中放数据
	v.push_back(10);
	v.push_back(20);
	v.push_back(30);
	v.push_back(40);

	//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素
	//v.begin()返回迭代器，这个迭代器指向容器中第一个数据
	//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置
	//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型

	vector&lt;int&gt;::iterator pBegin = v.begin();
	vector&lt;int&gt;::iterator pEnd = v.end();

	//第一种遍历方式：
	while (pBegin != pEnd) {
		cout &lt;&lt; *pBegin &lt;&lt; endl;
		pBegin++;
	}

	
	//第二种遍历方式：
	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; endl;
	}
	cout &lt;&lt; endl;

	//第三种遍历方式：
	//使用STL提供标准遍历算法  头文件 algorithm
	for_each(v.begin(), v.end(), MyPrint);
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="252-vector存放自定义数据类型">2.5.2 Vector存放自定义数据类型</h4>
<p>学习目标：vector中存放自定义数据类型，并打印输出</p>
<p><strong>示例：</strong></p>
<pre><code class="language-c++">#include &lt;vector&gt;
#include &lt;string&gt;

//自定义数据类型
class Person {
public:
	Person(string name, int age) {
		mName = name;
		mAge = age;
	}
public:
	string mName;
	int mAge;
};
//存放对象
void test01() {

	vector&lt;Person&gt; v;

	//创建数据
	Person p1(&quot;aaa&quot;, 10);
	Person p2(&quot;bbb&quot;, 20);
	Person p3(&quot;ccc&quot;, 30);
	Person p4(&quot;ddd&quot;, 40);
	Person p5(&quot;eee&quot;, 50);

	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);
	v.push_back(p4);
	v.push_back(p5);

	for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) {
		cout &lt;&lt; &quot;Name:&quot; &lt;&lt; (*it).mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it).mAge &lt;&lt; endl;

	}
}


//放对象指针
void test02() {

	vector&lt;Person*&gt; v;

	//创建数据
	Person p1(&quot;aaa&quot;, 10);
	Person p2(&quot;bbb&quot;, 20);
	Person p3(&quot;ccc&quot;, 30);
	Person p4(&quot;ddd&quot;, 40);
	Person p5(&quot;eee&quot;, 50);

	v.push_back(&amp;p1);
	v.push_back(&amp;p2);
	v.push_back(&amp;p3);
	v.push_back(&amp;p4);
	v.push_back(&amp;p5);

	for (vector&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) {
		Person * p = (*it);
		cout &lt;&lt; &quot;Name:&quot; &lt;&lt; p-&gt;mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;
	}
}


int main() {

	test01();
    
	test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="253-vector容器嵌套容器">2.5.3 Vector容器嵌套容器</h4>
<p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;vector&gt;

//容器嵌套容器
void test01() {

	vector&lt; vector&lt;int&gt; &gt;  v;

	vector&lt;int&gt; v1;
	vector&lt;int&gt; v2;
	vector&lt;int&gt; v3;
	vector&lt;int&gt; v4;

	for (int i = 0; i &lt; 4; i++) {
		v1.push_back(i + 1);
		v2.push_back(i + 2);
		v3.push_back(i + 3);
		v4.push_back(i + 4);
	}

	//将容器元素插入到vector v中
	v.push_back(v1);
	v.push_back(v2);
	v.push_back(v3);
	v.push_back(v4);


	for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++) {

		for (vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) {
			cout &lt;&lt; *vit &lt;&lt; &quot; &quot;;
		}
		cout &lt;&lt; endl;
	}

}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h2 id="3-stl-常用容器">3 STL- 常用容器</h2>
<h3 id="31-string容器">3.1 string容器</h3>
<h4 id="311-string基本概念">3.1.1 string基本概念</h4>
<p><strong>本质：</strong></p>
<ul>
<li>string是C++风格的字符串，而string本质上是一个类</li>
</ul>
<p><strong>string和char * 区别：</strong></p>
<ul>
<li>char * 是一个指针</li>
<li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li>
</ul>
<p><strong>特点：</strong></p>
<p>string 类内部封装了很多成员方法</p>
<p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p>
<p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p>
<h4 id="312-string构造函数">3.1.2 string构造函数</h4>
<p>构造函数原型：</p>
<ul>
<li><code>string();</code>          				//创建一个空的字符串 例如: string str;<br>
<code>string(const char* s);</code>	        //使用字符串s初始化</li>
<li><code>string(const string&amp; str);</code>    //使用一个string对象初始化另一个string对象</li>
<li><code>string(int n, char c);</code>           //使用n个字符c初始化</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;string&gt;
//string构造
void test01()
{
	string s1; //创建空字符串，调用无参构造函数
	cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; s1 &lt;&lt; endl;

	const char* str = &quot;hello world&quot;;
	string s2(str); //把c_string转换成了string

	cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; s2 &lt;&lt; endl;

	string s3(s2); //调用拷贝构造函数
	cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; s3 &lt;&lt; endl;

	string s4(10, 'a');
	cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; s3 &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：string的多种构造方式没有可比性，灵活使用即可</p>
<h4 id="313-string赋值操作">3.1.3 string赋值操作</h4>
<p>功能描述：</p>
<ul>
<li>给string字符串进行赋值</li>
</ul>
<p>赋值的函数原型：</p>
<ul>
<li><code>string&amp; operator=(const char* s);</code>             //char*类型字符串 赋值给当前的字符串</li>
<li><code>string&amp; operator=(const string &amp;s);</code>         //把字符串s赋给当前的字符串</li>
<li><code>string&amp; operator=(char c);</code>                          //字符赋值给当前的字符串</li>
<li><code>string&amp; assign(const char *s);</code>                  //把字符串s赋给当前的字符串</li>
<li><code>string&amp; assign(const char *s, int n);</code>     //把字符串s的前n个字符赋给当前的字符串</li>
<li><code>string&amp; assign(const string &amp;s);</code>              //把字符串s赋给当前字符串</li>
<li><code>string&amp; assign(int n, char c);</code>                  //用n个字符c赋给当前字符串</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//赋值
void test01()
{
	string str1;
	str1 = &quot;hello world&quot;;
	cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;

	string str2;
	str2 = str1;
	cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; str2 &lt;&lt; endl;

	string str3;
	str3 = 'a';
	cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;

	string str4;
	str4.assign(&quot;hello c++&quot;);
	cout &lt;&lt; &quot;str4 = &quot; &lt;&lt; str4 &lt;&lt; endl;

	string str5;
	str5.assign(&quot;hello c++&quot;,5);
	cout &lt;&lt; &quot;str5 = &quot; &lt;&lt; str5 &lt;&lt; endl;


	string str6;
	str6.assign(str5);
	cout &lt;&lt; &quot;str6 = &quot; &lt;&lt; str6 &lt;&lt; endl;

	string str7;
	str7.assign(5, 'x');
	cout &lt;&lt; &quot;str7 = &quot; &lt;&lt; str7 &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<p>​	string的赋值方式很多，<code>operator=</code>  这种方式是比较实用的</p>
<h4 id="314-string字符串拼接">3.1.4 string字符串拼接</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>实现在字符串末尾拼接字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string&amp; operator+=(const char* str);</code>                   //重载+=操作符</li>
<li><code>string&amp; operator+=(const char c);</code>                         //重载+=操作符</li>
<li><code>string&amp; operator+=(const string&amp; str);</code>                //重载+=操作符</li>
<li><code>string&amp; append(const char *s); </code>                               //把字符串s连接到当前字符串结尾</li>
<li><code>string&amp; append(const char *s, int n);</code>                 //把字符串s的前n个字符连接到当前字符串结尾</li>
<li><code>string&amp; append(const string &amp;s);</code>                           //同operator+=(const string&amp; str)</li>
<li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//字符串拼接
void test01()
{
	string str1 = &quot;我&quot;;

	str1 += &quot;爱玩游戏&quot;;

	cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;
	
	str1 += ':';

	cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;

	string str2 = &quot;LOL DNF&quot;;

	str1 += str2;

	cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;

	string str3 = &quot;I&quot;;
	str3.append(&quot; love &quot;);
	str3.append(&quot;game abcde&quot;, 4);
	//str3.append(str2);
	str3.append(str2, 4, 3); // 从下标4位置开始 ，截取3个字符，拼接到字符串末尾
	cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;
}
int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：字符串拼接的重载版本很多，初学阶段记住几种即可</p>
<h4 id="315-string查找和替换">3.1.5 string查找和替换</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>查找：查找指定字符串是否存在</li>
<li>替换：在指定的位置替换字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>int find(const string&amp; str, int pos = 0) const;</code>              //查找str第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos = 0) const; </code>                     //查找s第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos, int n) const; </code>               //从pos位置查找s的前n个字符第一次位置</li>
<li><code>int find(const char c, int pos = 0) const; </code>                       //查找字符c第一次出现位置</li>
<li><code>int rfind(const string&amp; str, int pos = npos) const;</code>      //查找str最后一次位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos = npos) const;</code>              //查找s最后一次出现位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos, int n) const;</code>              //从pos查找s的前n个字符最后一次位置</li>
<li><code>int rfind(const char c, int pos = 0) const;  </code>                      //查找字符c最后一次出现位置</li>
<li><code>string&amp; replace(int pos, int n, const string&amp; str); </code>       //替换从pos开始n个字符为字符串str</li>
<li><code>string&amp; replace(int pos, int n,const char* s); </code>                 //替换从pos开始的n个字符为字符串s</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//查找和替换
void test01()
{
	//查找
	string str1 = &quot;abcdefgde&quot;;

	int pos = str1.find(&quot;de&quot;);

	if (pos == -1)
	{
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;
	}
	

	pos = str1.rfind(&quot;de&quot;);

	cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;

}

void test02()
{
	//替换
	string str1 = &quot;abcdefgde&quot;;
	str1.replace(1, 3, &quot;1111&quot;);

	cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;
}

int main() {

	//test01();
	//test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>find查找是从左往后，rfind从右往左</li>
<li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li>
<li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li>
</ul>
<h4 id="316-string字符串比较">3.1.6 string字符串比较</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>字符串之间的比较</li>
</ul>
<p><strong>比较方式：</strong></p>
<ul>
<li>字符串比较是按字符的ASCII码进行对比</li>
</ul>
<p>= 返回   0</p>
<p>&gt; 返回   1</p>
<p>&lt; 返回  -1</p>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>int compare(const string &amp;s) const; </code>  //与字符串s比较</li>
<li><code>int compare(const char *s) const;</code>      //与字符串s比较</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//字符串比较
void test01()
{

	string s1 = &quot;hello&quot;;
	string s2 = &quot;aello&quot;;

	int ret = s1.compare(s2);

	if (ret == 0) {
		cout &lt;&lt; &quot;s1 等于 s2&quot; &lt;&lt; endl;
	}
	else if (ret &gt; 0)
	{
		cout &lt;&lt; &quot;s1 大于 s2&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;s1 小于 s2&quot; &lt;&lt; endl;
	}

}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p>
<h4 id="317-string字符存取">3.1.7 string字符存取</h4>
<p>string中单个字符存取方式有两种</p>
<ul>
<li><code>char&amp; operator[](int n); </code>     //通过[]方式取字符</li>
<li><code>char&amp; at(int n);   </code>                    //通过at方法获取字符</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">void test01()
{
	string str = &quot;hello world&quot;;

	for (int i = 0; i &lt; str.size(); i++)
	{
		cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;

	for (int i = 0; i &lt; str.size(); i++)
	{
		cout &lt;&lt; str.at(i) &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;


	//字符修改
	str[0] = 'x';
	str.at(1) = 'x';
	cout &lt;&lt; str &lt;&lt; endl;
	
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p>
<h4 id="318-string插入和删除">3.1.8 string插入和删除</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对string字符串进行插入和删除字符操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string&amp; insert(int pos, const char* s);  </code>                //插入字符串</li>
<li><code>string&amp; insert(int pos, const string&amp; str); </code>        //插入字符串</li>
<li><code>string&amp; insert(int pos, int n, char c);</code>                //在指定位置插入n个字符c</li>
<li><code>string&amp; erase(int pos, int n = npos);</code>                    //删除从Pos开始的n个字符</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//字符串插入和删除
void test01()
{
	string str = &quot;hello&quot;;
	str.insert(1, &quot;111&quot;);
	cout &lt;&lt; str &lt;&lt; endl;

	str.erase(1, 3);  //从1号位置开始3个字符
	cout &lt;&lt; str &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>**总结：**插入和删除的起始下标都是从0开始</p>
<h4 id="319-string子串">3.1.9 string子串</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>从字符串中获取想要的子串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string substr(int pos = 0, int n = npos) const;</code>   //返回由pos开始的n个字符组成的字符串</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//子串
void test01()
{

	string str = &quot;abcdefg&quot;;
	string subStr = str.substr(1, 3);
	cout &lt;&lt; &quot;subStr = &quot; &lt;&lt; subStr &lt;&lt; endl;

	string email = &quot;hello@sina.com&quot;;
	int pos = email.find(&quot;@&quot;);
	string username = email.substr(0, pos);
	cout &lt;&lt; &quot;username: &quot; &lt;&lt; username &lt;&lt; endl;

}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>**总结：**灵活的运用求子串功能，可以在实际开发中获取有效的信息</p>
<h3 id="32-vector容器">3.2 vector容器</h3>
<h4 id="321-vector基本概念">3.2.1 vector基本概念</h4>
<p><strong>功能：</strong></p>
<ul>
<li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li>
</ul>
<p><strong>vector与普通数组区别：</strong></p>
<ul>
<li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li>
</ul>
<p><strong>动态扩展：</strong></p>
<ul>
<li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li>
</ul>
<figure data-type="image" tabindex="4"><img src="assets/clip_image002.jpg" alt="说明: 2015-11-10_151152" loading="lazy"></figure>
<ul>
<li>vector容器的迭代器是支持随机访问的迭代器</li>
</ul>
<h4 id="322-vector构造函数">3.2.2 vector构造函数</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>创建vector容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>vector&lt;T&gt; v; </code>               		     //采用模板实现类实现，默认构造函数</li>
<li><code>vector(v.begin(), v.end());   </code>       //将v[begin(), end())区间中的元素拷贝给本身。</li>
<li><code>vector(n, elem);</code>                            //构造函数将n个elem拷贝给本身。</li>
<li><code>vector(const vector &amp;vec);</code>         //拷贝构造函数。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;vector&gt;

void printVector(vector&lt;int&gt;&amp; v) {

	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

void test01()
{
	vector&lt;int&gt; v1; //无参构造
	for (int i = 0; i &lt; 10; i++)
	{
		v1.push_back(i);
	}
	printVector(v1);

	vector&lt;int&gt; v2(v1.begin(), v1.end());
	printVector(v2);

	vector&lt;int&gt; v3(10, 100);
	printVector(v3);
	
	vector&lt;int&gt; v4(v3);
	printVector(v4);
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>**总结：**vector的多种构造方式没有可比性，灵活使用即可</p>
<h4 id="323-vector赋值操作">3.2.3 vector赋值操作</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>给vector容器进行赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</p>
</li>
<li>
<p><code>assign(beg, end);</code>       //将[beg, end)区间中的数据拷贝赋值给本身。</p>
</li>
<li>
<p><code>assign(n, elem);</code>        //将n个elem拷贝赋值给本身。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;vector&gt;

void printVector(vector&lt;int&gt;&amp; v) {

	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

//赋值操作
void test01()
{
	vector&lt;int&gt; v1; //无参构造
	for (int i = 0; i &lt; 10; i++)
	{
		v1.push_back(i);
	}
	printVector(v1);

	vector&lt;int&gt;v2;
	v2 = v1;
	printVector(v2);

	vector&lt;int&gt;v3;
	v3.assign(v1.begin(), v1.end());
	printVector(v3);

	vector&lt;int&gt;v4;
	v4.assign(10, 100);
	printVector(v4);
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}

</code></pre>
<p>总结： vector赋值方式比较简单，使用operator=，或者assign都可以</p>
<h4 id="324-vector容量和大小">3.2.4  vector容量和大小</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对vector容器的容量和大小操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>empty(); </code>                            //判断容器是否为空</p>
</li>
<li>
<p><code>capacity();</code>                      //容器的容量</p>
</li>
<li>
<p><code>size();</code>                              //返回容器中元素的个数</p>
</li>
<li>
<p><code>resize(int num);</code>             //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p>
<p>​					      //如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li>
<p><code>resize(int num, elem);</code>  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p>
<p>​				              //如果容器变短，则末尾超出容器长度的元素被删除</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;vector&gt;

void printVector(vector&lt;int&gt;&amp; v) {

	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

void test01()
{
	vector&lt;int&gt; v1;
	for (int i = 0; i &lt; 10; i++)
	{
		v1.push_back(i);
	}
	printVector(v1);
	if (v1.empty())
	{
		cout &lt;&lt; &quot;v1为空&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;v1不为空&quot; &lt;&lt; endl;
		cout &lt;&lt; &quot;v1的容量 = &quot; &lt;&lt; v1.capacity() &lt;&lt; endl;
		cout &lt;&lt; &quot;v1的大小 = &quot; &lt;&lt; v1.size() &lt;&lt; endl;
	}

	//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充
	v1.resize(15,10);
	printVector(v1);

	//resize 重新指定大小 ，若指定的更小，超出部分元素被删除
	v1.resize(5);
	printVector(v1);
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}

</code></pre>
<p>总结：</p>
<ul>
<li>判断是否为空  --- empty</li>
<li>返回元素个数  --- size</li>
<li>返回容器容量  --- capacity</li>
<li>重新指定大小  ---  resize</li>
</ul>
<h4 id="325-vector插入和删除">3.2.5 vector插入和删除</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对vector容器进行插入、删除操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>push_back(ele);</code>                                         //尾部插入元素ele</li>
<li><code>pop_back();</code>                                                //删除最后一个元素</li>
<li><code>insert(const_iterator pos, ele);</code>        //迭代器指向位置pos插入元素ele</li>
<li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li>
<li><code>erase(const_iterator pos);</code>                     //删除迭代器指向的元素</li>
<li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li>
<li><code>clear();</code>                                                        //删除容器中所有元素</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">
#include &lt;vector&gt;

void printVector(vector&lt;int&gt;&amp; v) {

	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

//插入和删除
void test01()
{
	vector&lt;int&gt; v1;
	//尾插
	v1.push_back(10);
	v1.push_back(20);
	v1.push_back(30);
	v1.push_back(40);
	v1.push_back(50);
	printVector(v1);
	//尾删
	v1.pop_back();
	printVector(v1);
	//插入
	v1.insert(v1.begin(), 100);
	printVector(v1);

	v1.insert(v1.begin(), 2, 1000);
	printVector(v1);

	//删除
	v1.erase(v1.begin());
	printVector(v1);

	//清空
	v1.erase(v1.begin(), v1.end());
	v1.clear();
	printVector(v1);
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>尾插  --- push_back</li>
<li>尾删  --- pop_back</li>
<li>插入  --- insert    (位置迭代器)</li>
<li>删除  --- erase  （位置迭代器）</li>
<li>清空  ---  clear</li>
</ul>
<h4 id="326-vector数据存取">3.2.6 vector数据存取</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对vector中的数据的存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>at(int idx); </code>     //返回索引idx所指的数据</li>
<li><code>operator[]; </code>       //返回索引idx所指的数据</li>
<li><code>front(); </code>            //返回容器中第一个数据元素</li>
<li><code>back();</code>              //返回容器中最后一个数据元素</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;vector&gt;

void test01()
{
	vector&lt;int&gt;v1;
	for (int i = 0; i &lt; 10; i++)
	{
		v1.push_back(i);
	}

	for (int i = 0; i &lt; v1.size(); i++)
	{
		cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;

	for (int i = 0; i &lt; v1.size(); i++)
	{
		cout &lt;&lt; v1.at(i) &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;

	cout &lt;&lt; &quot;v1的第一个元素为： &quot; &lt;&lt; v1.front() &lt;&lt; endl;
	cout &lt;&lt; &quot;v1的最后一个元素为： &quot; &lt;&lt; v1.back() &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h4 id="327-vector互换容器">3.2.7 vector互换容器</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>实现两个容器内元素进行互换</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>swap(vec);</code>  // 将vec与本身的元素互换</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;vector&gt;

void printVector(vector&lt;int&gt;&amp; v) {

	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

void test01()
{
	vector&lt;int&gt;v1;
	for (int i = 0; i &lt; 10; i++)
	{
		v1.push_back(i);
	}
	printVector(v1);

	vector&lt;int&gt;v2;
	for (int i = 10; i &gt; 0; i--)
	{
		v2.push_back(i);
	}
	printVector(v2);

	//互换容器
	cout &lt;&lt; &quot;互换后&quot; &lt;&lt; endl;
	v1.swap(v2);
	printVector(v1);
	printVector(v2);
}

void test02()
{
	vector&lt;int&gt; v;
	for (int i = 0; i &lt; 100000; i++) {
		v.push_back(i);
	}

	cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;
	cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;

	v.resize(3);

	cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;
	cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;

	//收缩内存
	vector&lt;int&gt;(v).swap(v); //匿名对象

	cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;
	cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;
}

int main() {

	test01();

	test02();

	system(&quot;pause&quot;);

	return 0;
}

</code></pre>
<p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p>
<h4 id="328-vector预留空间">3.2.8 vector预留空间</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>减少vector在动态扩展容量时的扩展次数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</p>
<p>​</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;vector&gt;

void test01()
{
	vector&lt;int&gt; v;

	//预留空间
	v.reserve(100000);

	int num = 0;
	int* p = NULL;
	for (int i = 0; i &lt; 100000; i++) {
		v.push_back(i);
		if (p != &amp;v[0]) {
			p = &amp;v[0];
			num++;
		}
	}

	cout &lt;&lt; &quot;num:&quot; &lt;&lt; num &lt;&lt; endl;
}

int main() {

	test01();
    
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：如果数据量较大，可以一开始利用reserve预留空间</p>
<h3 id="33-deque容器">3.3 deque容器</h3>
<h4 id="331-deque容器基本概念">3.3.1 deque容器基本概念</h4>
<p><strong>功能：</strong></p>
<ul>
<li>双端数组，可以对头端进行插入删除操作</li>
</ul>
<p><strong>deque与vector区别：</strong></p>
<ul>
<li>vector对于头部的插入删除效率低，数据量越大，效率越低</li>
<li>deque相对而言，对头部的插入删除速度回比vector快</li>
<li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li>
</ul>
<figure data-type="image" tabindex="5"><img src="assets/clip_image002-1547547642923.jpg" alt="说明: 2015-11-19_204101" loading="lazy"></figure>
<p>deque内部工作原理:</p>
<p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p>
<p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p>
<figure data-type="image" tabindex="6"><img src="assets/clip_image002-1547547896341.jpg" alt="clip_image002-1547547896341" loading="lazy"></figure>
<ul>
<li>deque容器的迭代器也是支持随机访问的</li>
</ul>
<h4 id="332-deque构造函数">3.3.2 deque构造函数</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>deque容器构造</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>deque&lt;T&gt;</code> deqT;                      //默认构造形式</li>
<li><code>deque(beg, end);</code>                  //构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>deque(n, elem);</code>                    //构造函数将n个elem拷贝给本身。</li>
<li><code>deque(const deque &amp;deq);</code>   //拷贝构造函数</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;deque&gt;

void printDeque(const deque&lt;int&gt;&amp; d) 
{
	for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;

	}
	cout &lt;&lt; endl;
}
//deque构造
void test01() {

	deque&lt;int&gt; d1; //无参构造函数
	for (int i = 0; i &lt; 10; i++)
	{
		d1.push_back(i);
	}
	printDeque(d1);
	deque&lt;int&gt; d2(d1.begin(),d1.end());
	printDeque(d2);

	deque&lt;int&gt;d3(10,100);
	printDeque(d3);

	deque&lt;int&gt;d4 = d3;
	printDeque(d4);
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>**总结：**deque容器和vector容器的构造方式几乎一致，灵活使用即可</p>
<h4 id="333-deque赋值操作">3.3.3 deque赋值操作</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>给deque容器进行赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>deque&amp; operator=(const deque &amp;deq); </code>         //重载等号操作符</p>
</li>
<li>
<p><code>assign(beg, end);</code>                                           //将[beg, end)区间中的数据拷贝赋值给本身。</p>
</li>
<li>
<p><code>assign(n, elem);</code>                                             //将n个elem拷贝赋值给本身。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;deque&gt;

void printDeque(const deque&lt;int&gt;&amp; d) 
{
	for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;

	}
	cout &lt;&lt; endl;
}
//赋值操作
void test01()
{
	deque&lt;int&gt; d1;
	for (int i = 0; i &lt; 10; i++)
	{
		d1.push_back(i);
	}
	printDeque(d1);

	deque&lt;int&gt;d2;
	d2 = d1;
	printDeque(d2);

	deque&lt;int&gt;d3;
	d3.assign(d1.begin(), d1.end());
	printDeque(d3);

	deque&lt;int&gt;d4;
	d4.assign(10, 100);
	printDeque(d4);

}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：deque赋值操作也与vector相同，需熟练掌握</p>
<h4 id="334-deque大小操作">3.3.4 deque大小操作</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对deque容器的大小进行操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>deque.empty();</code>                       //判断容器是否为空</p>
</li>
<li>
<p><code>deque.size();</code>                         //返回容器中元素的个数</p>
</li>
<li>
<p><code>deque.resize(num);</code>                //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</p>
<p>​			                             //如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li>
<p><code>deque.resize(num, elem);</code>     //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</p>
<p>​                                                     //如果容器变短，则末尾超出容器长度的元素被删除。</p>
<p>​</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;deque&gt;

void printDeque(const deque&lt;int&gt;&amp; d) 
{
	for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;

	}
	cout &lt;&lt; endl;
}

//大小操作
void test01()
{
	deque&lt;int&gt; d1;
	for (int i = 0; i &lt; 10; i++)
	{
		d1.push_back(i);
	}
	printDeque(d1);

	//判断容器是否为空
	if (d1.empty()) {
		cout &lt;&lt; &quot;d1为空!&quot; &lt;&lt; endl;
	}
	else {
		cout &lt;&lt; &quot;d1不为空!&quot; &lt;&lt; endl;
		//统计大小
		cout &lt;&lt; &quot;d1的大小为：&quot; &lt;&lt; d1.size() &lt;&lt; endl;
	}

	//重新指定大小
	d1.resize(15, 1);
	printDeque(d1);

	d1.resize(5);
	printDeque(d1);
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>deque没有容量的概念</li>
<li>判断是否为空   --- empty</li>
<li>返回元素个数   --- size</li>
<li>重新指定个数   --- resize</li>
</ul>
<h4 id="335-deque-插入和删除">3.3.5 deque 插入和删除</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>向deque容器中插入和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<p>两端插入操作：</p>
<ul>
<li><code>push_back(elem);</code>          //在容器尾部添加一个数据</li>
<li><code>push_front(elem);</code>        //在容器头部插入一个数据</li>
<li><code>pop_back();</code>                   //删除容器最后一个数据</li>
<li><code>pop_front();</code>                 //删除容器第一个数据</li>
</ul>
<p>指定位置操作：</p>
<ul>
<li>
<p><code>insert(pos,elem);</code>         //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p>
</li>
<li>
<p><code>insert(pos,n,elem);</code>     //在pos位置插入n个elem数据，无返回值。</p>
</li>
<li>
<p><code>insert(pos,beg,end);</code>    //在pos位置插入[beg,end)区间的数据，无返回值。</p>
</li>
<li>
<p><code>clear();</code>                           //清空容器的所有数据</p>
</li>
<li>
<p><code>erase(beg,end);</code>             //删除[beg,end)区间的数据，返回下一个数据的位置。</p>
</li>
<li>
<p><code>erase(pos);</code>                    //删除pos位置的数据，返回下一个数据的位置。</p>
<p>​</p>
<p>​</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;deque&gt;

void printDeque(const deque&lt;int&gt;&amp; d) 
{
	for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;

	}
	cout &lt;&lt; endl;
}
//两端操作
void test01()
{
	deque&lt;int&gt; d;
	//尾插
	d.push_back(10);
	d.push_back(20);
	//头插
	d.push_front(100);
	d.push_front(200);

	printDeque(d);

	//尾删
	d.pop_back();
	//头删
	d.pop_front();
	printDeque(d);
}

//插入
void test02()
{
	deque&lt;int&gt; d;
	d.push_back(10);
	d.push_back(20);
	d.push_front(100);
	d.push_front(200);
	printDeque(d);

	d.insert(d.begin(), 1000);
	printDeque(d);

	d.insert(d.begin(), 2,10000);
	printDeque(d);

	deque&lt;int&gt;d2;
	d2.push_back(1);
	d2.push_back(2);
	d2.push_back(3);

	d.insert(d.begin(), d2.begin(), d2.end());
	printDeque(d);

}

//删除
void test03()
{
	deque&lt;int&gt; d;
	d.push_back(10);
	d.push_back(20);
	d.push_front(100);
	d.push_front(200);
	printDeque(d);

	d.erase(d.begin());
	printDeque(d);

	d.erase(d.begin(), d.end());
	d.clear();
	printDeque(d);
}

int main() {

	//test01();

	//test02();

    test03();
    
	system(&quot;pause&quot;);

	return 0;
}

</code></pre>
<p>总结：</p>
<ul>
<li>插入和删除提供的位置是迭代器！</li>
<li>尾插   ---  push_back</li>
<li>尾删   ---  pop_back</li>
<li>头插   ---  push_front</li>
<li>头删   ---  pop_front</li>
</ul>
<h4 id="336-deque-数据存取">3.3.6 deque 数据存取</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对deque 中的数据的存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>at(int idx); </code>     //返回索引idx所指的数据</li>
<li><code>operator[]; </code>      //返回索引idx所指的数据</li>
<li><code>front(); </code>            //返回容器中第一个数据元素</li>
<li><code>back();</code>              //返回容器中最后一个数据元素</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;deque&gt;

void printDeque(const deque&lt;int&gt;&amp; d) 
{
	for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;

	}
	cout &lt;&lt; endl;
}

//数据存取
void test01()
{

	deque&lt;int&gt; d;
	d.push_back(10);
	d.push_back(20);
	d.push_front(100);
	d.push_front(200);

	for (int i = 0; i &lt; d.size(); i++) {
		cout &lt;&lt; d[i] &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;


	for (int i = 0; i &lt; d.size(); i++) {
		cout &lt;&lt; d.at(i) &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;

	cout &lt;&lt; &quot;front:&quot; &lt;&lt; d.front() &lt;&lt; endl;

	cout &lt;&lt; &quot;back:&quot; &lt;&lt; d.back() &lt;&lt; endl;

}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h4 id="337-deque-排序">3.3.7  deque 排序</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>利用算法实现对deque容器进行排序</li>
</ul>
<p><strong>算法：</strong></p>
<ul>
<li><code>sort(iterator beg, iterator end)</code>  //对beg和end区间内元素进行排序</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;deque&gt;
#include &lt;algorithm&gt;

void printDeque(const deque&lt;int&gt;&amp; d) 
{
	for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;

	}
	cout &lt;&lt; endl;
}

void test01()
{

	deque&lt;int&gt; d;
	d.push_back(10);
	d.push_back(20);
	d.push_front(100);
	d.push_front(200);

	printDeque(d);
	sort(d.begin(), d.end());
	printDeque(d);

}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p>
<h3 id="34-案例-评委打分">3.4 案例-评委打分</h3>
<h4 id="341-案例描述">3.4.1 案例描述</h4>
<p>有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</p>
<h4 id="342-实现步骤">3.4.2 实现步骤</h4>
<ol>
<li>创建五名选手，放到vector中</li>
<li>遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中</li>
<li>sort算法对deque容器中分数排序，去除最高和最低分</li>
<li>deque容器遍历一遍，累加总分</li>
<li>获取平均分</li>
</ol>
<p><strong>示例代码：</strong></p>
<pre><code class="language-C++">//选手类
class Person
{
public:
	Person(string name, int score)
	{
		this-&gt;m_Name = name;
		this-&gt;m_Score = score;
	}

	string m_Name; //姓名
	int m_Score;  //平均分
};

void createPerson(vector&lt;Person&gt;&amp;v)
{
	string nameSeed = &quot;ABCDE&quot;;
	for (int i = 0; i &lt; 5; i++)
	{
		string name = &quot;选手&quot;;
		name += nameSeed[i];

		int score = 0;

		Person p(name, score);

		//将创建的person对象 放入到容器中
		v.push_back(p);
	}
}

//打分
void setScore(vector&lt;Person&gt;&amp;v)
{
	for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)
	{
		//将评委的分数 放入到deque容器中
		deque&lt;int&gt;d;
		for (int i = 0; i &lt; 10; i++)
		{
			int score = rand() % 41 + 60;  // 60 ~ 100
			d.push_back(score);
		}

		//cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl;
		//for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)
		//{
		//	cout &lt;&lt; *dit &lt;&lt; &quot; &quot;;
		//}
		//cout &lt;&lt; endl;

		//排序
		sort(d.begin(), d.end());

		//去除最高和最低分
		d.pop_back();
		d.pop_front();

		//取平均分
		int sum = 0;
		for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)
		{
			sum += *dit; //累加每个评委的分数
		}

		int avg = sum / d.size();

		//将平均分 赋值给选手身上
		it-&gt;m_Score = avg;
	}

}

void showScore(vector&lt;Person&gt;&amp;v)
{
	for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)
	{
		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 平均分： &quot; &lt;&lt; it-&gt;m_Score &lt;&lt; endl;
	}
}

int main() {

	//随机数种子
	srand((unsigned int)time(NULL));

	//1、创建5名选手
	vector&lt;Person&gt;v;  //存放选手容器
	createPerson(v);

	//测试
	//for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)
	//{
	//	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl;
	//}

	//2、给5名选手打分
	setScore(v);

	//3、显示最后得分
	showScore(v);

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>总结：</strong> 选取不同的容器操作数据，可以提升代码的效率</p>
<h3 id="35-stack容器">3.5 stack容器</h3>
<h4 id="351-stack-基本概念">3.5.1 stack 基本概念</h4>
<p><strong>概念：<strong>stack是一种</strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口</p>
<figure data-type="image" tabindex="7"><img src="assets/clip_image002-1547604555425.jpg" alt="说明: 2015-11-15_195707" loading="lazy"></figure>
<p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p>
<p>栈中进入数据称为  --- <strong>入栈</strong>  <code>push</code></p>
<p>栈中弹出数据称为  --- <strong>出栈</strong>  <code>pop</code></p>
<p>生活中的栈：</p>
<figure data-type="image" tabindex="8"><img src="assets/clip_image002.png" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="assets/clip_image002-1547605111510.jpg" alt="img" loading="lazy"></figure>
<h4 id="352-stack-常用接口">3.5.2 stack 常用接口</h4>
<p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul>
<li><code>stack&lt;T&gt; stk;</code>                                 //stack采用模板类实现， stack对象的默认构造形式</li>
<li><code>stack(const stack &amp;stk);</code>            //拷贝构造函数</li>
</ul>
<p>赋值操作：</p>
<ul>
<li><code>stack&amp; operator=(const stack &amp;stk);</code>           //重载等号操作符</li>
</ul>
<p>数据存取：</p>
<ul>
<li><code>push(elem);</code>      //向栈顶添加元素</li>
<li><code>pop();</code>                //从栈顶移除第一个元素</li>
<li><code>top(); </code>                //返回栈顶元素</li>
</ul>
<p>大小操作：</p>
<ul>
<li><code>empty();</code>            //判断堆栈是否为空</li>
<li><code>size(); </code>              //返回栈的大小</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;stack&gt;

//栈容器常用接口
void test01()
{
	//创建栈容器 栈容器必须符合先进后出
	stack&lt;int&gt; s;

	//向栈中添加元素，叫做 压栈 入栈
	s.push(10);
	s.push(20);
	s.push(30);

	while (!s.empty()) {
		//输出栈顶元素
		cout &lt;&lt; &quot;栈顶元素为： &quot; &lt;&lt; s.top() &lt;&lt; endl;
		//弹出栈顶元素
		s.pop();
	}
	cout &lt;&lt; &quot;栈的大小为：&quot; &lt;&lt; s.size() &lt;&lt; endl;

}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>入栈   --- push</li>
<li>出栈   --- pop</li>
<li>返回栈顶   --- top</li>
<li>判断栈是否为空   --- empty</li>
<li>返回栈大小   --- size</li>
</ul>
<h3 id="36-queue-容器">3.6 queue 容器</h3>
<h4 id="361-queue-基本概念">3.6.1 queue 基本概念</h4>
<p><strong>概念：<strong>Queue是一种</strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口</p>
<figure data-type="image" tabindex="10"><img src="assets/clip_image002-1547606475892.jpg" alt="说明: 2015-11-15_214429" loading="lazy"></figure>
<p>队列容器允许从一端新增元素，从另一端移除元素</p>
<p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p>
<p>队列中进数据称为 --- <strong>入队</strong>    <code>push</code></p>
<p>队列中出数据称为 --- <strong>出队</strong>    <code>pop</code></p>
<p>生活中的队列：</p>
<figure data-type="image" tabindex="11"><img src="assets/1547606785041.png" alt="1547606785041" loading="lazy"></figure>
<h4 id="362-queue-常用接口">3.6.2 queue 常用接口</h4>
<p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul>
<li><code>queue&lt;T&gt; que;</code>                                 //queue采用模板类实现，queue对象的默认构造形式</li>
<li><code>queue(const queue &amp;que);</code>            //拷贝构造函数</li>
</ul>
<p>赋值操作：</p>
<ul>
<li><code>queue&amp; operator=(const queue &amp;que);</code>           //重载等号操作符</li>
</ul>
<p>数据存取：</p>
<ul>
<li><code>push(elem);</code>                             //往队尾添加元素</li>
<li><code>pop();</code>                                      //从队头移除第一个元素</li>
<li><code>back();</code>                                    //返回最后一个元素</li>
<li><code>front(); </code>                                  //返回第一个元素</li>
</ul>
<p>大小操作：</p>
<ul>
<li><code>empty();</code>            //判断堆栈是否为空</li>
<li><code>size(); </code>              //返回栈的大小</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;queue&gt;
#include &lt;string&gt;
class Person
{
public:
	Person(string name, int age)
	{
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	}

	string m_Name;
	int m_Age;
};

void test01() {

	//创建队列
	queue&lt;Person&gt; q;

	//准备数据
	Person p1(&quot;唐僧&quot;, 30);
	Person p2(&quot;孙悟空&quot;, 1000);
	Person p3(&quot;猪八戒&quot;, 900);
	Person p4(&quot;沙僧&quot;, 800);

	//向队列中添加元素  入队操作
	q.push(p1);
	q.push(p2);
	q.push(p3);
	q.push(p4);

	//队列不提供迭代器，更不支持随机访问	
	while (!q.empty()) {
		//输出队头元素
		cout &lt;&lt; &quot;队头元素-- 姓名： &quot; &lt;&lt; q.front().m_Name 
              &lt;&lt; &quot; 年龄： &quot;&lt;&lt; q.front().m_Age &lt;&lt; endl;
        
		cout &lt;&lt; &quot;队尾元素-- 姓名： &quot; &lt;&lt; q.back().m_Name  
              &lt;&lt; &quot; 年龄： &quot; &lt;&lt; q.back().m_Age &lt;&lt; endl;
        
		cout &lt;&lt; endl;
		//弹出队头元素
		q.pop();
	}

	cout &lt;&lt; &quot;队列大小为：&quot; &lt;&lt; q.size() &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>入队   --- push</li>
<li>出队   --- pop</li>
<li>返回队头元素   --- front</li>
<li>返回队尾元素   --- back</li>
<li>判断队是否为空   --- empty</li>
<li>返回队列大小   --- size</li>
</ul>
<h3 id="37-list容器">3.7 list容器</h3>
<h4 id="371-list基本概念">3.7.1 list基本概念</h4>
<p>**功能：**将数据进行链式存储</p>
<p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p>
<p>链表的组成：链表由一系列<strong>结点</strong>组成</p>
<p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p>
<p>STL中的链表是一个双向循环链表</p>
<figure data-type="image" tabindex="12"><img src="assets/clip_image002-1547608564071.jpg" alt="说明: 2015-11-15_225145" loading="lazy"></figure>
<p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p>
<p>list的优点：</p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
</ul>
<p>list的缺点：</p>
<ul>
<li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li>
</ul>
<p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p>
<p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p>
<h4 id="372-list构造函数">3.7.2  list构造函数</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>创建list容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>list&lt;T&gt; lst;</code>                               //list采用采用模板类实现,对象的默认构造形式：</li>
<li><code>list(beg,end);</code>                           //构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>list(n,elem);</code>                             //构造函数将n个elem拷贝给本身。</li>
<li><code>list(const list &amp;lst);</code>            //拷贝构造函数。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;list&gt;

void printList(const list&lt;int&gt;&amp; L) {

	for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

void test01()
{
	list&lt;int&gt;L1;
	L1.push_back(10);
	L1.push_back(20);
	L1.push_back(30);
	L1.push_back(40);

	printList(L1);

	list&lt;int&gt;L2(L1.begin(),L1.end());
	printList(L2);

	list&lt;int&gt;L3(L2);
	printList(L3);

	list&lt;int&gt;L4(10, 1000);
	printList(L4);
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：list构造方式同其他几个STL常用容器，熟练掌握即可</p>
<h4 id="373-list-赋值和交换">3.7.3 list 赋值和交换</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>给list容器进行赋值，以及交换list容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>assign(beg, end);</code>            //将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>              //将n个elem拷贝赋值给本身。</li>
<li><code>list&amp; operator=(const list &amp;lst);</code>         //重载等号操作符</li>
<li><code>swap(lst);</code>                         //将lst与本身的元素互换。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;list&gt;

void printList(const list&lt;int&gt;&amp; L) {

	for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

//赋值和交换
void test01()
{
	list&lt;int&gt;L1;
	L1.push_back(10);
	L1.push_back(20);
	L1.push_back(30);
	L1.push_back(40);
	printList(L1);

	//赋值
	list&lt;int&gt;L2;
	L2 = L1;
	printList(L2);

	list&lt;int&gt;L3;
	L3.assign(L2.begin(), L2.end());
	printList(L3);

	list&lt;int&gt;L4;
	L4.assign(10, 100);
	printList(L4);

}

//交换
void test02()
{

	list&lt;int&gt;L1;
	L1.push_back(10);
	L1.push_back(20);
	L1.push_back(30);
	L1.push_back(40);

	list&lt;int&gt;L2;
	L2.assign(10, 100);

	cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;
	printList(L1);
	printList(L2);

	cout &lt;&lt; endl;

	L1.swap(L2);

	cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;
	printList(L1);
	printList(L2);

}

int main() {

	//test01();

	test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：list赋值和交换操作能够灵活运用即可</p>
<h4 id="374-list-大小操作">3.7.4 list 大小操作</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对list容器的大小进行操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>size(); </code>                             //返回容器中元素的个数</p>
</li>
<li>
<p><code>empty(); </code>                           //判断容器是否为空</p>
</li>
<li>
<p><code>resize(num);</code>                   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p>
<p>​					    //如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li>
<p><code>resize(num, elem); </code>       //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p>
<pre><code>  	 	 	​					    //如果容器变短，则末尾超出容器长度的元素被删除。
</code></pre>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;list&gt;

void printList(const list&lt;int&gt;&amp; L) {

	for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

//大小操作
void test01()
{
	list&lt;int&gt;L1;
	L1.push_back(10);
	L1.push_back(20);
	L1.push_back(30);
	L1.push_back(40);

	if (L1.empty())
	{
		cout &lt;&lt; &quot;L1为空&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;L1不为空&quot; &lt;&lt; endl;
		cout &lt;&lt; &quot;L1的大小为： &quot; &lt;&lt; L1.size() &lt;&lt; endl;
	}

	//重新指定大小
	L1.resize(10);
	printList(L1);

	L1.resize(2);
	printList(L1);
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>判断是否为空   --- empty</li>
<li>返回元素个数   --- size</li>
<li>重新指定个数   --- resize</li>
</ul>
<h4 id="375-list-插入和删除">3.7.5 list 插入和删除</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对list容器进行数据的插入和删除</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>push_back(elem);//在容器尾部加入一个元素</li>
<li>pop_back();//删除容器中最后一个元素</li>
<li>push_front(elem);//在容器开头插入一个元素</li>
<li>pop_front();//从容器开头移除第一个元素</li>
<li>insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</li>
<li>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</li>
<li>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</li>
<li>clear();//移除容器的所有数据</li>
<li>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</li>
<li>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</li>
<li>remove(elem);//删除容器中所有与elem值匹配的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;list&gt;

void printList(const list&lt;int&gt;&amp; L) {

	for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

//插入和删除
void test01()
{
	list&lt;int&gt; L;
	//尾插
	L.push_back(10);
	L.push_back(20);
	L.push_back(30);
	//头插
	L.push_front(100);
	L.push_front(200);
	L.push_front(300);

	printList(L);

	//尾删
	L.pop_back();
	printList(L);

	//头删
	L.pop_front();
	printList(L);

	//插入
	list&lt;int&gt;::iterator it = L.begin();
	L.insert(++it, 1000);
	printList(L);

	//删除
	it = L.begin();
	L.erase(++it);
	printList(L);

	//移除
	L.push_back(10000);
	L.push_back(10000);
	L.push_back(10000);
	printList(L);
	L.remove(10000);
	printList(L);
    
    //清空
	L.clear();
	printList(L);
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>尾插   --- push_back</li>
<li>尾删   --- pop_back</li>
<li>头插   --- push_front</li>
<li>头删   --- pop_front</li>
<li>插入   --- insert</li>
<li>删除   --- erase</li>
<li>移除   --- remove</li>
<li>清空   --- clear</li>
</ul>
<h4 id="376-list-数据存取">3.7.6 list 数据存取</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对list容器中数据进行存取</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>front();</code>        //返回第一个元素。</li>
<li><code>back();</code>         //返回最后一个元素。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;list&gt;

//数据存取
void test01()
{
	list&lt;int&gt;L1;
	L1.push_back(10);
	L1.push_back(20);
	L1.push_back(30);
	L1.push_back(40);

	
	//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据
	//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据
	cout &lt;&lt; &quot;第一个元素为： &quot; &lt;&lt; L1.front() &lt;&lt; endl;
	cout &lt;&lt; &quot;最后一个元素为： &quot; &lt;&lt; L1.back() &lt;&lt; endl;

	//list容器的迭代器是双向迭代器，不支持随机访问
	list&lt;int&gt;::iterator it = L1.begin();
	//it = it + 1;//错误，不可以跳跃访问，即使是+1
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}

</code></pre>
<p>总结：</p>
<ul>
<li>list容器中不可以通过[]或者at方式访问数据</li>
<li>返回第一个元素   --- front</li>
<li>返回最后一个元素   --- back</li>
</ul>
<h4 id="377-list-反转和排序">3.7.7 list 反转和排序</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>将容器中的元素反转，以及将容器中的数据进行排序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>reverse();</code>   //反转链表</li>
<li><code>sort();</code>        //链表排序</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">void printList(const list&lt;int&gt;&amp; L) {

	for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

bool myCompare(int val1 , int val2)
{
	return val1 &gt; val2;
}

//反转和排序
void test01()
{
	list&lt;int&gt; L;
	L.push_back(90);
	L.push_back(30);
	L.push_back(20);
	L.push_back(70);
	printList(L);

	//反转容器的元素
	L.reverse();
	printList(L);

	//排序
	L.sort(); //默认的排序规则 从小到大
	printList(L);

	L.sort(myCompare); //指定规则，从大到小
	printList(L);
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>反转   --- reverse</li>
<li>排序   --- sort （成员函数）</li>
</ul>
<h4 id="378-排序案例">3.7.8 排序案例</h4>
<p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</p>
<p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;list&gt;
#include &lt;string&gt;
class Person {
public:
	Person(string name, int age , int height) {
		m_Name = name;
		m_Age = age;
		m_Height = height;
	}

public:
	string m_Name;  //姓名
	int m_Age;      //年龄
	int m_Height;   //身高
};


bool ComparePerson(Person&amp; p1, Person&amp; p2) {

	if (p1.m_Age == p2.m_Age) {
		return p1.m_Height  &gt; p2.m_Height;
	}
	else
	{
		return  p1.m_Age &lt; p2.m_Age;
	}

}

void test01() {

	list&lt;Person&gt; L;

	Person p1(&quot;刘备&quot;, 35 , 175);
	Person p2(&quot;曹操&quot;, 45 , 180);
	Person p3(&quot;孙权&quot;, 40 , 170);
	Person p4(&quot;赵云&quot;, 25 , 190);
	Person p5(&quot;张飞&quot;, 35 , 160);
	Person p6(&quot;关羽&quot;, 35 , 200);

	L.push_back(p1);
	L.push_back(p2);
	L.push_back(p3);
	L.push_back(p4);
	L.push_back(p5);
	L.push_back(p6);

	for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) {
		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age 
              &lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;
	}

	cout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl;
	L.sort(ComparePerson); //排序

	for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) {
		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age 
              &lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;
	}
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>
<p>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</p>
</li>
<li>
<p>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</p>
</li>
</ul>
<h3 id="38-set-multiset-容器">3.8 set/ multiset 容器</h3>
<h4 id="381-set基本概念">3.8.1 set基本概念</h4>
<p><strong>简介：</strong></p>
<ul>
<li>所有元素都会在插入时自动被排序</li>
</ul>
<p><strong>本质：</strong></p>
<ul>
<li>set/multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li>
</ul>
<p><strong>set和multiset区别</strong>：</p>
<ul>
<li>set不允许容器中有重复的元素</li>
<li>multiset允许容器中有重复的元素</li>
</ul>
<h4 id="382-set构造和赋值">3.8.2 set构造和赋值</h4>
<p>功能描述：创建set容器以及赋值</p>
<p>构造：</p>
<ul>
<li><code>set&lt;T&gt; st;</code>                        //默认构造函数：</li>
<li><code>set(const set &amp;st);</code>       //拷贝构造函数</li>
</ul>
<p>赋值：</p>
<ul>
<li><code>set&amp; operator=(const set &amp;st);</code>    //重载等号操作符</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;set&gt;

void printSet(set&lt;int&gt; &amp; s)
{
	for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)
	{
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

//构造和赋值
void test01()
{
	set&lt;int&gt; s1;

	s1.insert(10);
	s1.insert(30);
	s1.insert(20);
	s1.insert(40);
	printSet(s1);

	//拷贝构造
	set&lt;int&gt;s2(s1);
	printSet(s2);

	//赋值
	set&lt;int&gt;s3;
	s3 = s2;
	printSet(s3);
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>set容器插入数据时用insert</li>
<li>set容器插入数据的数据会自动排序</li>
</ul>
<h4 id="383-set大小和交换">3.8.3 set大小和交换</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>统计set容器大小以及交换set容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>size();</code>          //返回容器中元素的数目</li>
<li><code>empty();</code>        //判断容器是否为空</li>
<li><code>swap(st);</code>      //交换两个集合容器</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;set&gt;

void printSet(set&lt;int&gt; &amp; s)
{
	for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)
	{
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

//大小
void test01()
{

	set&lt;int&gt; s1;
	
	s1.insert(10);
	s1.insert(30);
	s1.insert(20);
	s1.insert(40);

	if (s1.empty())
	{
		cout &lt;&lt; &quot;s1为空&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;s1不为空&quot; &lt;&lt; endl;
		cout &lt;&lt; &quot;s1的大小为： &quot; &lt;&lt; s1.size() &lt;&lt; endl;
	}

}

//交换
void test02()
{
	set&lt;int&gt; s1;

	s1.insert(10);
	s1.insert(30);
	s1.insert(20);
	s1.insert(40);

	set&lt;int&gt; s2;

	s2.insert(100);
	s2.insert(300);
	s2.insert(200);
	s2.insert(400);

	cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;
	printSet(s1);
	printSet(s2);
	cout &lt;&lt; endl;

	cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;
	s1.swap(s2);
	printSet(s1);
	printSet(s2);
}

int main() {

	//test01();

	test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>统计大小   --- size</li>
<li>判断是否为空   --- empty</li>
<li>交换容器   --- swap</li>
</ul>
<h4 id="384-set插入和删除">3.8.4 set插入和删除</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>set容器进行插入数据和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>insert(elem);</code>           //在容器中插入元素。</li>
<li><code>clear();</code>                    //清除所有元素</li>
<li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li><code>erase(elem);</code>            //删除容器中值为elem的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;set&gt;

void printSet(set&lt;int&gt; &amp; s)
{
	for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)
	{
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

//插入和删除
void test01()
{
	set&lt;int&gt; s1;
	//插入
	s1.insert(10);
	s1.insert(30);
	s1.insert(20);
	s1.insert(40);
	printSet(s1);

	//删除
	s1.erase(s1.begin());
	printSet(s1);

	s1.erase(30);
	printSet(s1);

	//清空
	//s1.erase(s1.begin(), s1.end());
	s1.clear();
	printSet(s1);
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>插入   --- insert</li>
<li>删除   --- erase</li>
<li>清空   --- clear</li>
</ul>
<h4 id="385-set查找和统计">3.8.5 set查找和统计</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对set容器进行查找数据以及统计数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li><code>count(key);</code>                //统计key的元素个数</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;set&gt;

//查找和统计
void test01()
{
	set&lt;int&gt; s1;
	//插入
	s1.insert(10);
	s1.insert(30);
	s1.insert(20);
	s1.insert(40);
	
	//查找
	set&lt;int&gt;::iterator pos = s1.find(30);

	if (pos != s1.end())
	{
		cout &lt;&lt; &quot;找到了元素 ： &quot; &lt;&lt; *pos &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;
	}

	//统计
	int num = s1.count(30);
	cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>查找   ---  find    （返回的是迭代器）</li>
<li>统计   ---  count  （对于set，结果为0或者1）</li>
</ul>
<h4 id="386-set和multiset区别">3.8.6 set和multiset区别</h4>
<p><strong>学习目标：</strong></p>
<ul>
<li>掌握set和multiset的区别</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>set不可以插入重复数据，而multiset可以</li>
<li>set插入数据的同时会返回插入结果，表示插入是否成功</li>
<li>multiset不会检测数据，因此可以插入重复数据</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;set&gt;

//set和multiset区别
void test01()
{
	set&lt;int&gt; s;
	pair&lt;set&lt;int&gt;::iterator, bool&gt;  ret = s.insert(10);
	if (ret.second) {
		cout &lt;&lt; &quot;第一次插入成功!&quot; &lt;&lt; endl;
	}
	else {
		cout &lt;&lt; &quot;第一次插入失败!&quot; &lt;&lt; endl;
	}

	ret = s.insert(10);
	if (ret.second) {
		cout &lt;&lt; &quot;第二次插入成功!&quot; &lt;&lt; endl;
	}
	else {
		cout &lt;&lt; &quot;第二次插入失败!&quot; &lt;&lt; endl;
	}
    
	//multiset
	multiset&lt;int&gt; ms;
	ms.insert(10);
	ms.insert(10);

	for (multiset&lt;int&gt;::iterator it = ms.begin(); it != ms.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>如果不允许插入重复数据可以利用set</li>
<li>如果需要插入重复数据利用multiset</li>
</ul>
<h4 id="387-pair对组创建">3.8.7 pair对组创建</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>成对出现的数据，利用对组可以返回两个数据</li>
</ul>
<p><strong>两种创建方式：</strong></p>
<ul>
<li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li>
<li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;string&gt;

//对组创建
void test01()
{
	pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 20);
	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt;  p.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.second &lt;&lt; endl;

	pair&lt;string, int&gt; p2 = make_pair(&quot;Jerry&quot;, 10);
	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p2.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p2.second &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<p>两种方式都可以创建对组，记住一种即可</p>
<h4 id="388-set容器排序">3.8.8 set容器排序</h4>
<p>学习目标：</p>
<ul>
<li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li>
</ul>
<p>主要技术点：</p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p><strong>示例一</strong>   set存放内置数据类型</p>
<pre><code class="language-C++">#include &lt;set&gt;

class MyCompare 
{
public:
	bool operator()(int v1, int v2) {
		return v1 &gt; v2;
	}
};
void test01() 
{    
	set&lt;int&gt; s1;
	s1.insert(10);
	s1.insert(40);
	s1.insert(20);
	s1.insert(30);
	s1.insert(50);

	//默认从小到大
	for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;

	//指定排序规则
	set&lt;int,MyCompare&gt; s2;
	s2.insert(10);
	s2.insert(40);
	s2.insert(20);
	s2.insert(30);
	s2.insert(50);

	for (set&lt;int, MyCompare&gt;::iterator it = s2.begin(); it != s2.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：利用仿函数可以指定set容器的排序规则</p>
<p><strong>示例二</strong> set存放自定义数据类型</p>
<pre><code class="language-C++">#include &lt;set&gt;
#include &lt;string&gt;

class Person
{
public:
	Person(string name, int age)
	{
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	}

	string m_Name;
	int m_Age;

};
class comparePerson
{
public:
	bool operator()(const Person&amp; p1, const Person &amp;p2)
	{
		//按照年龄进行排序  降序
		return p1.m_Age &gt; p2.m_Age;
	}
};

void test01()
{
	set&lt;Person, comparePerson&gt; s;

	Person p1(&quot;刘备&quot;, 23);
	Person p2(&quot;关羽&quot;, 27);
	Person p3(&quot;张飞&quot;, 25);
	Person p4(&quot;赵云&quot;, 21);

	s.insert(p1);
	s.insert(p2);
	s.insert(p3);
	s.insert(p4);

	for (set&lt;Person, comparePerson&gt;::iterator it = s.begin(); it != s.end(); it++)
	{
		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;
	}
}
int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<p>对于自定义数据类型，set必须指定排序规则才可以插入数据</p>
<h3 id="39-map-multimap容器">3.9 map/ multimap容器</h3>
<h4 id="391-map基本概念">3.9.1 map基本概念</h4>
<p><strong>简介：</strong></p>
<ul>
<li>map中所有元素都是pair</li>
<li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li>
<li>所有元素都会根据元素的键值自动排序</li>
</ul>
<p><strong>本质：</strong></p>
<ul>
<li>map/multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>可以根据key值快速找到value值</li>
</ul>
<p>map和multimap<strong>区别</strong>：</p>
<ul>
<li>map不允许容器中有重复key值元素</li>
<li>multimap允许容器中有重复key值元素</li>
</ul>
<h4 id="392-map构造和赋值">3.9.2  map构造和赋值</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对map容器进行构造和赋值操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<p><strong>构造：</strong></p>
<ul>
<li><code>map&lt;T1, T2&gt; mp;</code>                     //map默认构造函数:</li>
<li><code>map(const map &amp;mp);</code>             //拷贝构造函数</li>
</ul>
<p><strong>赋值：</strong></p>
<ul>
<li><code>map&amp; operator=(const map &amp;mp);</code>    //重载等号操作符</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;map&gt;

void printMap(map&lt;int,int&gt;&amp;m)
{
	for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)
	{
		cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
	}
	cout &lt;&lt; endl;
}

void test01()
{
	map&lt;int,int&gt;m; //默认构造
	m.insert(pair&lt;int, int&gt;(1, 10));
	m.insert(pair&lt;int, int&gt;(2, 20));
	m.insert(pair&lt;int, int&gt;(3, 30));
	printMap(m);

	map&lt;int, int&gt;m2(m); //拷贝构造
	printMap(m2);

	map&lt;int, int&gt;m3;
	m3 = m2; //赋值
	printMap(m3);
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p>
<h4 id="393-map大小和交换">3.9.3 map大小和交换</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>统计map容器大小以及交换map容器</li>
</ul>
<p>函数原型：</p>
<ul>
<li><code>size();</code>          //返回容器中元素的数目</li>
<li><code>empty();</code>        //判断容器是否为空</li>
<li><code>swap(st);</code>      //交换两个集合容器</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;map&gt;

void printMap(map&lt;int,int&gt;&amp;m)
{
	for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)
	{
		cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
	}
	cout &lt;&lt; endl;
}

void test01()
{
	map&lt;int, int&gt;m;
	m.insert(pair&lt;int, int&gt;(1, 10));
	m.insert(pair&lt;int, int&gt;(2, 20));
	m.insert(pair&lt;int, int&gt;(3, 30));

	if (m.empty())
	{
		cout &lt;&lt; &quot;m为空&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;m不为空&quot; &lt;&lt; endl;
		cout &lt;&lt; &quot;m的大小为： &quot; &lt;&lt; m.size() &lt;&lt; endl;
	}
}


//交换
void test02()
{
	map&lt;int, int&gt;m;
	m.insert(pair&lt;int, int&gt;(1, 10));
	m.insert(pair&lt;int, int&gt;(2, 20));
	m.insert(pair&lt;int, int&gt;(3, 30));

	map&lt;int, int&gt;m2;
	m2.insert(pair&lt;int, int&gt;(4, 100));
	m2.insert(pair&lt;int, int&gt;(5, 200));
	m2.insert(pair&lt;int, int&gt;(6, 300));

	cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;
	printMap(m);
	printMap(m2);

	cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;
	m.swap(m2);
	printMap(m);
	printMap(m2);
}

int main() {

	test01();

	test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>统计大小   --- size</li>
<li>判断是否为空   --- empty</li>
<li>交换容器   --- swap</li>
</ul>
<h4 id="394-map插入和删除">3.9.4 map插入和删除</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>map容器进行插入数据和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>insert(elem);</code>           //在容器中插入元素。</li>
<li><code>clear();</code>                    //清除所有元素</li>
<li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li><code>erase(key);</code>            //删除容器中值为key的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;map&gt;

void printMap(map&lt;int,int&gt;&amp;m)
{
	for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)
	{
		cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
	}
	cout &lt;&lt; endl;
}

void test01()
{
	//插入
	map&lt;int, int&gt; m;
	//第一种插入方式
	m.insert(pair&lt;int, int&gt;(1, 10));
	//第二种插入方式
	m.insert(make_pair(2, 20));
	//第三种插入方式
	m.insert(map&lt;int, int&gt;::value_type(3, 30));
	//第四种插入方式
	m[4] = 40; 
	printMap(m);

	//删除
	m.erase(m.begin());
	printMap(m);

	m.erase(3);
	printMap(m);

	//清空
	m.erase(m.begin(),m.end());
	m.clear();
	printMap(m);
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>map插入方式很多，记住其一即可</li>
</ul>
<ul>
<li>插入   --- insert</li>
<li>删除   --- erase</li>
<li>清空   --- clear</li>
</ul>
<h4 id="395-map查找和统计">3.9.5 map查找和统计</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对map容器进行查找数据以及统计数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li><code>count(key);</code>                //统计key的元素个数</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;map&gt;

//查找和统计
void test01()
{
	map&lt;int, int&gt;m; 
	m.insert(pair&lt;int, int&gt;(1, 10));
	m.insert(pair&lt;int, int&gt;(2, 20));
	m.insert(pair&lt;int, int&gt;(3, 30));

	//查找
	map&lt;int, int&gt;::iterator pos = m.find(3);

	if (pos != m.end())
	{
		cout &lt;&lt; &quot;找到了元素 key = &quot; &lt;&lt; (*pos).first &lt;&lt; &quot; value = &quot; &lt;&lt; (*pos).second &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;
	}

	//统计
	int num = m.count(3);
	cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>查找   ---  find    （返回的是迭代器）</li>
<li>统计   ---  count  （对于map，结果为0或者1）</li>
</ul>
<h4 id="396-map容器排序">3.9.6 map容器排序</h4>
<p><strong>学习目标：</strong></p>
<ul>
<li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li>
</ul>
<p><strong>主要技术点:</strong></p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;map&gt;

class MyCompare {
public:
	bool operator()(int v1, int v2) {
		return v1 &gt; v2;
	}
};

void test01() 
{
	//默认从小到大排序
	//利用仿函数实现从大到小排序
	map&lt;int, int, MyCompare&gt; m;

	m.insert(make_pair(1, 10));
	m.insert(make_pair(2, 20));
	m.insert(make_pair(3, 30));
	m.insert(make_pair(4, 40));
	m.insert(make_pair(5, 50));

	for (map&lt;int, int, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++) {
		cout &lt;&lt; &quot;key:&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value:&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
	}
}
int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>利用仿函数可以指定map容器的排序规则</li>
<li>对于自定义数据类型，map必须要指定排序规则,同set容器</li>
</ul>
<h3 id="310-案例-员工分组">3.10 案例-员工分组</h3>
<h4 id="3101-案例描述">3.10.1 案例描述</h4>
<ul>
<li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li>
<li>员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</li>
<li>随机给10名员工分配部门和工资</li>
<li>通过multimap进行信息的插入  key(部门编号) value(员工)</li>
<li>分部门显示员工信息</li>
</ul>
<h4 id="3102-实现步骤">3.10.2 实现步骤</h4>
<ol>
<li>创建10名员工，放到vector中</li>
<li>遍历vector容器，取出每个员工，进行随机分组</li>
<li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li>
<li>分部门显示员工信息</li>
</ol>
<p><strong>案例代码：</strong></p>
<pre><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;ctime&gt;

/*
- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作
- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发
- 随机给10名员工分配部门和工资
- 通过multimap进行信息的插入  key(部门编号) value(员工)
- 分部门显示员工信息
*/

#define CEHUA  0
#define MEISHU 1
#define YANFA  2

class Worker
{
public:
	string m_Name;
	int m_Salary;
};

void createWorker(vector&lt;Worker&gt;&amp;v)
{
	string nameSeed = &quot;ABCDEFGHIJ&quot;;
	for (int i = 0; i &lt; 10; i++)
	{
		Worker worker;
		worker.m_Name = &quot;员工&quot;;
		worker.m_Name += nameSeed[i];

		worker.m_Salary = rand() % 10000 + 10000; // 10000 ~ 19999
		//将员工放入到容器中
		v.push_back(worker);
	}
}

//员工分组
void setGroup(vector&lt;Worker&gt;&amp;v,multimap&lt;int,Worker&gt;&amp;m)
{
	for (vector&lt;Worker&gt;::iterator it = v.begin(); it != v.end(); it++)
	{
		//产生随机部门编号
		int deptId = rand() % 3; // 0 1 2 

		//将员工插入到分组中
		//key部门编号，value具体员工
		m.insert(make_pair(deptId, *it));
	}
}

void showWorkerByGourp(multimap&lt;int,Worker&gt;&amp;m)
{
	// 0  A  B  C   1  D  E   2  F G ...
	cout &lt;&lt; &quot;策划部门：&quot; &lt;&lt; endl;

	multimap&lt;int,Worker&gt;::iterator pos = m.find(CEHUA);
	int count = m.count(CEHUA); // 统计具体人数
	int index = 0;
	for (; pos != m.end() &amp;&amp; index &lt; count; pos++ , index++)
	{
		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;
	}

	cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;美术部门： &quot; &lt;&lt; endl;
	pos = m.find(MEISHU);
	count = m.count(MEISHU); // 统计具体人数
	index = 0;
	for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)
	{
		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;
	}

	cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;研发部门： &quot; &lt;&lt; endl;
	pos = m.find(YANFA);
	count = m.count(YANFA); // 统计具体人数
	index = 0;
	for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)
	{
		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;
	}

}

int main() {

	srand((unsigned int)time(NULL));

	//1、创建员工
	vector&lt;Worker&gt;vWorker;
	createWorker(vWorker);

	//2、员工分组
	multimap&lt;int, Worker&gt;mWorker;
	setGroup(vWorker, mWorker);


	//3、分组显示员工
	showWorkerByGourp(mWorker);

	////测试
	//for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)
	//{
	//	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;
	//}

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>当数据以键值对形式存在，可以考虑用map 或 multimap</li>
</ul>
<h2 id="4-stl-函数对象">4 STL- 函数对象</h2>
<h3 id="41-函数对象">4.1 函数对象</h3>
<h4 id="411-函数对象概念">4.1.1 函数对象概念</h4>
<p><strong>概念：</strong></p>
<ul>
<li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li>
<li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li>
</ul>
<p><strong>本质：</strong></p>
<p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p>
<h4 id="412-函数对象使用">4.1.2  函数对象使用</h4>
<p><strong>特点：</strong></p>
<ul>
<li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li>
<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>
<li>函数对象可以作为参数传递</li>
</ul>
<p><strong>示例:</strong></p>
<pre><code class="language-C++">#include &lt;string&gt;

//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值
class MyAdd
{
public :
	int operator()(int v1,int v2)
	{
		return v1 + v2;
	}
};

void test01()
{
	MyAdd myAdd;
	cout &lt;&lt; myAdd(10, 10) &lt;&lt; endl;
}

//2、函数对象可以有自己的状态
class MyPrint
{
public:
	MyPrint()
	{
		count = 0;
	}
	void operator()(string test)
	{
		cout &lt;&lt; test &lt;&lt; endl;
		count++; //统计使用次数
	}

	int count; //内部自己的状态
};
void test02()
{
	MyPrint myPrint;
	myPrint(&quot;hello world&quot;);
	myPrint(&quot;hello world&quot;);
	myPrint(&quot;hello world&quot;);
	cout &lt;&lt; &quot;myPrint调用次数为： &quot; &lt;&lt; myPrint.count &lt;&lt; endl;
}

//3、函数对象可以作为参数传递
void doPrint(MyPrint &amp;mp , string test)
{
	mp(test);
}

void test03()
{
	MyPrint myPrint;
	doPrint(myPrint, &quot;Hello C++&quot;);
}

int main() {

	//test01();
	//test02();
	test03();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>仿函数写法非常灵活，可以作为参数进行传递。</li>
</ul>
<h3 id="42-谓词">4.2  谓词</h3>
<h4 id="421-谓词概念">4.2.1 谓词概念</h4>
<p><strong>概念：</strong></p>
<ul>
<li>返回bool类型的仿函数称为<strong>谓词</strong></li>
<li>如果operator()接受一个参数，那么叫做一元谓词</li>
<li>如果operator()接受两个参数，那么叫做二元谓词</li>
</ul>
<h4 id="422-一元谓词">4.2.2 一元谓词</h4>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;vector&gt;
#include &lt;algorithm&gt;

//1.一元谓词
struct GreaterFive{
	bool operator()(int val) {
		return val &gt; 5;
	}
};

void test01() {

	vector&lt;int&gt; v;
	for (int i = 0; i &lt; 10; i++)
	{
		v.push_back(i);
	}

	vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());
	if (it == v.end()) {
		cout &lt;&lt; &quot;没找到!&quot; &lt;&lt; endl;
	}
	else {
		cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;
	}

}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：参数只有一个的谓词，称为一元谓词</p>
<h4 id="423-二元谓词">4.2.3 二元谓词</h4>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;vector&gt;
#include &lt;algorithm&gt;
//二元谓词
class MyCompare
{
public:
	bool operator()(int num1, int num2)
	{
		return num1 &gt; num2;
	}
};

void test01()
{
	vector&lt;int&gt; v;
	v.push_back(10);
	v.push_back(40);
	v.push_back(20);
	v.push_back(30);
	v.push_back(50);

	//默认从小到大
	sort(v.begin(), v.end());
	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)
	{
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
	cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl;

	//使用函数对象改变算法策略，排序从大到小
	sort(v.begin(), v.end(), MyCompare());
	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)
	{
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：参数只有两个的谓词，称为二元谓词</p>
<h3 id="43-内建函数对象">4.3 内建函数对象</h3>
<h4 id="431-内建函数对象意义">4.3.1 内建函数对象意义</h4>
<p><strong>概念：</strong></p>
<ul>
<li>STL内建了一些函数对象</li>
</ul>
<p><strong>分类:</strong></p>
<ul>
<li>
<p>算术仿函数</p>
</li>
<li>
<p>关系仿函数</p>
</li>
<li>
<p>逻辑仿函数</p>
</li>
</ul>
<p><strong>用法：</strong></p>
<ul>
<li>这些仿函数所产生的对象，用法和一般函数完全相同</li>
<li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li>
</ul>
<h4 id="432-算术仿函数">4.3.2 算术仿函数</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>实现四则运算</li>
<li>其中negate是一元运算，其他都是二元运算</li>
</ul>
<p><strong>仿函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>                //加法仿函数</li>
<li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>              //减法仿函数</li>
<li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>    //乘法仿函数</li>
<li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>         //除法仿函数</li>
<li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>         //取模仿函数</li>
<li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>           //取反仿函数</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;functional&gt;
//negate
void test01()
{
	negate&lt;int&gt; n;
	cout &lt;&lt; n(50) &lt;&lt; endl;
}

//plus
void test02()
{
	plus&lt;int&gt; p;
	cout &lt;&lt; p(10, 20) &lt;&lt; endl;
}

int main() {

	test01();
	test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></p>
<h4 id="433-关系仿函数">4.3.3 关系仿函数</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>实现关系对比</li>
</ul>
<p><strong>仿函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>                    //等于</li>
<li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>            //不等于</li>
<li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>                      //大于</li>
<li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>          //大于等于</li>
<li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>                           //小于</li>
<li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>               //小于等于</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;functional&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

class MyCompare
{
public:
	bool operator()(int v1,int v2)
	{
		return v1 &gt; v2;
	}
};
void test01()
{
	vector&lt;int&gt; v;

	v.push_back(10);
	v.push_back(30);
	v.push_back(50);
	v.push_back(40);
	v.push_back(20);

	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;

	//自己实现仿函数
	//sort(v.begin(), v.end(), MyCompare());
	//STL内建仿函数  大于仿函数
	sort(v.begin(), v.end(), greater&lt;int&gt;());

	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</p>
<h4 id="434-逻辑仿函数">4.3.4 逻辑仿函数</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>实现逻辑运算</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>              //逻辑与</li>
<li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>                //逻辑或</li>
<li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>              //逻辑非</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;vector&gt;
#include &lt;functional&gt;
#include &lt;algorithm&gt;
void test01()
{
	vector&lt;bool&gt; v;
	v.push_back(true);
	v.push_back(false);
	v.push_back(true);
	v.push_back(false);

	for (vector&lt;bool&gt;::iterator it = v.begin();it!= v.end();it++)
	{
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;

	//逻辑非  将v容器搬运到v2中，并执行逻辑非运算
	vector&lt;bool&gt; v2;
	v2.resize(v.size());
	transform(v.begin(), v.end(),  v2.begin(), logical_not&lt;bool&gt;());
	for (vector&lt;bool&gt;::iterator it = v2.begin(); it != v2.end(); it++)
	{
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：逻辑仿函数实际应用较少，了解即可</p>
<h2 id="5-stl-常用算法">5 STL- 常用算法</h2>
<p><strong>概述</strong>:</p>
<ul>
<li>
<p>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</p>
</li>
<li>
<p><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</p>
</li>
<li>
<p><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</p>
</li>
<li>
<p><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</p>
</li>
</ul>
<h3 id="51-常用遍历算法">5.1 常用遍历算法</h3>
<p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的遍历算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>for_each</code>     //遍历容器</li>
<li><code>transform</code>   //搬运容器到另一个容器中</li>
</ul>
<h4 id="511-for_each">5.1.1 for_each</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>实现遍历容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>for_each(iterator beg, iterator end, _func);  </code></p>
<p>// 遍历算法 遍历容器元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _func 函数或者函数对象</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

//普通函数
void print01(int val) 
{
	cout &lt;&lt; val &lt;&lt; &quot; &quot;;
}
//函数对象
class print02 
{
 public:
	void operator()(int val) 
	{
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	}
};

//for_each算法基本用法
void test01() {

	vector&lt;int&gt; v;
	for (int i = 0; i &lt; 10; i++) 
	{
		v.push_back(i);
	}

	//遍历算法
	for_each(v.begin(), v.end(), print01);
	cout &lt;&lt; endl;

	for_each(v.begin(), v.end(), print02());
	cout &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>**总结：**for_each在实际开发中是最常用遍历算法，需要熟练掌握</p>
<h4 id="512-transform">5.1.2 transform</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>搬运容器到另一个容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></li>
</ul>
<p>//beg1 源容器开始迭代器</p>
<p>//end1 源容器结束迭代器</p>
<p>//beg2 目标容器开始迭代器</p>
<p>//_func 函数或者函数对象</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include&lt;vector&gt;
#include&lt;algorithm&gt;

//常用遍历算法  搬运 transform

class TransForm
{
public:
	int operator()(int val)
	{
		return val;
	}

};

class MyPrint
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	}
};

void test01()
{
	vector&lt;int&gt;v;
	for (int i = 0; i &lt; 10; i++)
	{
		v.push_back(i);
	}

	vector&lt;int&gt;vTarget; //目标容器

	vTarget.resize(v.size()); // 目标容器需要提前开辟空间

	transform(v.begin(), v.end(), vTarget.begin(), TransForm());

	for_each(vTarget.begin(), vTarget.end(), MyPrint());
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p>
<h3 id="52-常用查找算法">5.2 常用查找算法</h3>
<p>学习目标：</p>
<ul>
<li>掌握常用的查找算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>find</code>                     //查找元素</li>
<li><code>find_if</code>               //按条件查找元素</li>
<li><code>adjacent_find</code>    //查找相邻重复元素</li>
<li><code>binary_search</code>    //二分查找法</li>
<li><code>count</code>                   //统计元素个数</li>
<li><code>count_if</code>             //按条件统计元素个数</li>
</ul>
<h4 id="521-find">5.2.1 find</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>find(iterator beg, iterator end, value);  </code></p>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 查找的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
void test01() {

	vector&lt;int&gt; v;
	for (int i = 0; i &lt; 10; i++) {
		v.push_back(i + 1);
	}
	//查找容器中是否有 5 这个元素
	vector&lt;int&gt;::iterator it = find(v.begin(), v.end(), 5);
	if (it == v.end()) 
	{
		cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;
	}
	else 
	{
		cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;
	}
}

class Person {
public:
	Person(string name, int age) 
	{
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	}
	//重载==
	bool operator==(const Person&amp; p) 
	{
		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) 
		{
			return true;
		}
		return false;
	}

public:
	string m_Name;
	int m_Age;
};

void test02() {

	vector&lt;Person&gt; v;

	//创建数据
	Person p1(&quot;aaa&quot;, 10);
	Person p2(&quot;bbb&quot;, 20);
	Person p3(&quot;ccc&quot;, 30);
	Person p4(&quot;ddd&quot;, 40);

	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);
	v.push_back(p4);

	vector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2);
	if (it == v.end()) 
	{
		cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;
	}
	else 
	{
		cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;
	}
}
</code></pre>
<p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p>
<h4 id="522-find_if">5.2.2 find_if</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>按条件查找元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>find_if(iterator beg, iterator end, _Pred);  </code></p>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _Pred 函数或者谓词（返回bool类型的仿函数）</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

//内置数据类型
class GreaterFive
{
public:
	bool operator()(int val)
	{
		return val &gt; 5;
	}
};

void test01() {

	vector&lt;int&gt; v;
	for (int i = 0; i &lt; 10; i++) {
		v.push_back(i + 1);
	}

	vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());
	if (it == v.end()) {
		cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;
	}
	else {
		cout &lt;&lt; &quot;找到大于5的数字:&quot; &lt;&lt; *it &lt;&lt; endl;
	}
}

//自定义数据类型
class Person {
public:
	Person(string name, int age)
	{
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	}
public:
	string m_Name;
	int m_Age;
};

class Greater20
{
public:
	bool operator()(Person &amp;p)
	{
		return p.m_Age &gt; 20;
	}

};

void test02() {

	vector&lt;Person&gt; v;

	//创建数据
	Person p1(&quot;aaa&quot;, 10);
	Person p2(&quot;bbb&quot;, 20);
	Person p3(&quot;ccc&quot;, 30);
	Person p4(&quot;ddd&quot;, 40);

	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);
	v.push_back(p4);

	vector&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20());
	if (it == v.end())
	{
		cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;
	}
}

int main() {

	//test01();

	test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p>
<h4 id="523-adjacent_find">5.2.3 adjacent_find</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>查找相邻重复元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>adjacent_find(iterator beg, iterator end);  </code></p>
<p>// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>​</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

void test01()
{
	vector&lt;int&gt; v;
	v.push_back(1);
	v.push_back(2);
	v.push_back(5);
	v.push_back(2);
	v.push_back(4);
	v.push_back(4);
	v.push_back(3);

	//查找相邻重复元素
	vector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end());
	if (it == v.end()) {
		cout &lt;&lt; &quot;找不到!&quot; &lt;&lt; endl;
	}
	else {
		cout &lt;&lt; &quot;找到相邻重复元素为:&quot; &lt;&lt; *it &lt;&lt; endl;
	}
}
</code></pre>
<p>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p>
<h4 id="524-binary_search">5.2.4 binary_search</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>查找指定元素是否存在</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>bool binary_search(iterator beg, iterator end, value);  </code></p>
<p>// 查找指定的元素，查到 返回true  否则false</p>
<p>// 注意: 在<strong>无序序列中不可用</strong></p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 查找的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

void test01()
{
	vector&lt;int&gt;v;

	for (int i = 0; i &lt; 10; i++)
	{
		v.push_back(i);
	}
	//二分查找
	bool ret = binary_search(v.begin(), v.end(),2);
	if (ret)
	{
		cout &lt;&lt; &quot;找到了&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
	}
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>**总结：**二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p>
<h4 id="525-count">5.2.5 count</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>统计元素个数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>count(iterator beg, iterator end, value);  </code></p>
<p>// 统计元素出现次数</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 统计的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

//内置数据类型
void test01()
{
	vector&lt;int&gt; v;
	v.push_back(1);
	v.push_back(2);
	v.push_back(4);
	v.push_back(5);
	v.push_back(3);
	v.push_back(4);
	v.push_back(4);

	int num = count(v.begin(), v.end(), 4);

	cout &lt;&lt; &quot;4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;
}

//自定义数据类型
class Person
{
public:
	Person(string name, int age)
	{
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	}
	bool operator==(const Person &amp; p)
	{
		if (this-&gt;m_Age == p.m_Age)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	string m_Name;
	int m_Age;
};

void test02()
{
	vector&lt;Person&gt; v;

	Person p1(&quot;刘备&quot;, 35);
	Person p2(&quot;关羽&quot;, 35);
	Person p3(&quot;张飞&quot;, 35);
	Person p4(&quot;赵云&quot;, 30);
	Person p5(&quot;曹操&quot;, 25);

	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);
	v.push_back(p4);
	v.push_back(p5);
    
    Person p(&quot;诸葛亮&quot;,35);

	int num = count(v.begin(), v.end(), p);
	cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;
}
int main() {

	//test01();

	test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p>
<h4 id="526-count_if">5.2.6 count_if</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>按条件统计元素个数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>count_if(iterator beg, iterator end, _Pred);  </code></p>
<p>// 按条件统计元素出现次数</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _Pred 谓词</p>
<p>​</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class Greater4
{
public:
	bool operator()(int val)
	{
		return val &gt;= 4;
	}
};

//内置数据类型
void test01()
{
	vector&lt;int&gt; v;
	v.push_back(1);
	v.push_back(2);
	v.push_back(4);
	v.push_back(5);
	v.push_back(3);
	v.push_back(4);
	v.push_back(4);

	int num = count_if(v.begin(), v.end(), Greater4());

	cout &lt;&lt; &quot;大于4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;
}

//自定义数据类型
class Person
{
public:
	Person(string name, int age)
	{
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	}

	string m_Name;
	int m_Age;
};

class AgeLess35
{
public:
	bool operator()(const Person &amp;p)
	{
		return p.m_Age &lt; 35;
	}
};
void test02()
{
	vector&lt;Person&gt; v;

	Person p1(&quot;刘备&quot;, 35);
	Person p2(&quot;关羽&quot;, 35);
	Person p3(&quot;张飞&quot;, 35);
	Person p4(&quot;赵云&quot;, 30);
	Person p5(&quot;曹操&quot;, 25);

	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);
	v.push_back(p4);
	v.push_back(p5);

	int num = count_if(v.begin(), v.end(), AgeLess35());
	cout &lt;&lt; &quot;小于35岁的个数：&quot; &lt;&lt; num &lt;&lt; endl;
}


int main() {

	//test01();

	test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>**总结：**按值统计用count，按条件统计用count_if</p>
<h3 id="53-常用排序算法">5.3 常用排序算法</h3>
<p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的排序算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>sort</code>             //对容器内元素进行排序</li>
<li><code>random_shuffle</code>   //洗牌   指定范围内的元素随机调整次序</li>
<li><code>merge </code>           // 容器元素合并，并存储到另一容器中</li>
<li><code>reverse</code>       // 反转指定范围的元素</li>
</ul>
<h4 id="531-sort">5.3.1 sort</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对容器内元素进行排序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>sort(iterator beg, iterator end, _Pred);  </code></p>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>//  beg    开始迭代器</p>
<p>//  end    结束迭代器</p>
<p>// _Pred  谓词</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

void myPrint(int val)
{
	cout &lt;&lt; val &lt;&lt; &quot; &quot;;
}

void test01() {
	vector&lt;int&gt; v;
	v.push_back(10);
	v.push_back(30);
	v.push_back(50);
	v.push_back(20);
	v.push_back(40);

	//sort默认从小到大排序
	sort(v.begin(), v.end());
	for_each(v.begin(), v.end(), myPrint);
	cout &lt;&lt; endl;

	//从大到小排序
	sort(v.begin(), v.end(), greater&lt;int&gt;());
	for_each(v.begin(), v.end(), myPrint);
	cout &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>**总结：**sort属于开发中最常用的算法之一，需熟练掌握</p>
<h4 id="532-random_shuffle">5.3.2 random_shuffle</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>洗牌   指定范围内的元素随机调整次序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>random_shuffle(iterator beg, iterator end);  </code></p>
<p>// 指定范围内的元素随机调整次序</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>​</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;ctime&gt;

class myPrint
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	}
};

void test01()
{
	srand((unsigned int)time(NULL));
	vector&lt;int&gt; v;
	for(int i = 0 ; i &lt; 10;i++)
	{
		v.push_back(i);
	}
	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;

	//打乱顺序
	random_shuffle(v.begin(), v.end());
	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>**总结：**random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p>
<h4 id="533-merge">5.3.3 merge</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>两个容器元素合并，并存储到另一容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>// 容器元素合并，并存储到另一容器中</p>
<p>// 注意: 两个容器必须是<strong>有序的</strong></p>
<p>// beg1   容器1开始迭代器<br>
// end1   容器1结束迭代器<br>
// beg2   容器2开始迭代器<br>
// end2   容器2结束迭代器<br>
// dest    目标容器开始迭代器</p>
<p>​</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class myPrint
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	}
};

void test01()
{
	vector&lt;int&gt; v1;
	vector&lt;int&gt; v2;
	for (int i = 0; i &lt; 10 ; i++) 
    {
		v1.push_back(i);
		v2.push_back(i + 1);
	}

	vector&lt;int&gt; vtarget;
	//目标容器需要提前开辟空间
	vtarget.resize(v1.size() + v2.size());
	//合并  需要两个有序序列
	merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin());
	for_each(vtarget.begin(), vtarget.end(), myPrint());
	cout &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>**总结：**merge合并的两个容器必须的有序序列</p>
<h4 id="534-reverse">5.3.4 reverse</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>将容器内元素进行反转</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>reverse(iterator beg, iterator end);  </code></p>
<p>// 反转指定范围的元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>​</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class myPrint
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	}
};

void test01()
{
	vector&lt;int&gt; v;
	v.push_back(10);
	v.push_back(30);
	v.push_back(50);
	v.push_back(20);
	v.push_back(40);

	cout &lt;&lt; &quot;反转前： &quot; &lt;&lt; endl;
	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;

	cout &lt;&lt; &quot;反转后： &quot; &lt;&lt; endl;

	reverse(v.begin(), v.end());
	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>**总结：**reverse反转区间内元素，面试题可能涉及到</p>
<h3 id="54-常用拷贝和替换算法">5.4 常用拷贝和替换算法</h3>
<p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的拷贝和替换算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>copy</code>                      // 容器内指定范围的元素拷贝到另一容器中</li>
<li><code>replace</code>                // 将容器内指定范围的旧元素修改为新元素</li>
<li><code>replace_if </code>          // 容器内指定范围满足条件的元素替换为新元素</li>
<li><code>swap</code>                     // 互换两个容器的元素</li>
</ul>
<h4 id="541-copy">5.4.1 copy</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>容器内指定范围的元素拷贝到另一容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>copy(iterator beg, iterator end, iterator dest);  </code></p>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>// beg  开始迭代器</p>
<p>// end  结束迭代器</p>
<p>// dest 目标起始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class myPrint
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	}
};

void test01()
{
	vector&lt;int&gt; v1;
	for (int i = 0; i &lt; 10; i++) {
		v1.push_back(i + 1);
	}
	vector&lt;int&gt; v2;
	v2.resize(v1.size());
	copy(v1.begin(), v1.end(), v2.begin());

	for_each(v2.begin(), v2.end(), myPrint());
	cout &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>**总结：**利用copy算法在拷贝时，目标容器记得提前开辟空间</p>
<h4 id="542-replace">5.4.2 replace</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>将容器内指定范围的旧元素修改为新元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>replace(iterator beg, iterator end, oldvalue, newvalue);  </code></p>
<p>// 将区间内旧元素 替换成 新元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// oldvalue 旧元素</p>
<p>// newvalue 新元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class myPrint
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	}
};

void test01()
{
	vector&lt;int&gt; v;
	v.push_back(20);
	v.push_back(30);
	v.push_back(20);
	v.push_back(40);
	v.push_back(50);
	v.push_back(10);
	v.push_back(20);

	cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;
	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;

	//将容器中的20 替换成 2000
	cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;
	replace(v.begin(), v.end(), 20,2000);
	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>**总结：**replace会替换区间内满足条件的元素</p>
<h4 id="543-replace_if">5.4.3 replace_if</h4>
<p><strong>功能描述:</strong></p>
<ul>
<li>将区间内满足条件的元素，替换成指定元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>replace_if(iterator beg, iterator end, _pred, newvalue);  </code></p>
<p>// 按条件替换元素，满足条件的替换成指定元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _pred 谓词</p>
<p>// newvalue 替换的新元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class myPrint
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	}
};

class ReplaceGreater30
{
public:
	bool operator()(int val)
	{
		return val &gt;= 30;
	}

};

void test01()
{
	vector&lt;int&gt; v;
	v.push_back(20);
	v.push_back(30);
	v.push_back(20);
	v.push_back(40);
	v.push_back(50);
	v.push_back(10);
	v.push_back(20);

	cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;
	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;

	//将容器中大于等于的30 替换成 3000
	cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;
	replace_if(v.begin(), v.end(), ReplaceGreater30(), 3000);
	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>**总结：**replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p>
<h4 id="544-swap">5.4.4 swap</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>互换两个容器的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>swap(container c1, container c2);  </code></p>
<p>// 互换两个容器的元素</p>
<p>// c1容器1</p>
<p>// c2容器2</p>
<p>​</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class myPrint
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	}
};

void test01()
{
	vector&lt;int&gt; v1;
	vector&lt;int&gt; v2;
	for (int i = 0; i &lt; 10; i++) {
		v1.push_back(i);
		v2.push_back(i+100);
	}

	cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;
	for_each(v1.begin(), v1.end(), myPrint());
	cout &lt;&lt; endl;
	for_each(v2.begin(), v2.end(), myPrint());
	cout &lt;&lt; endl;

	cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;
	swap(v1, v2);
	for_each(v1.begin(), v1.end(), myPrint());
	cout &lt;&lt; endl;
	for_each(v2.begin(), v2.end(), myPrint());
	cout &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>**总结：**swap交换容器时，注意交换的容器要同种类型</p>
<h3 id="55-常用算术生成算法">5.5 常用算术生成算法</h3>
<p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的算术生成算法</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li>
<p><code>accumulate</code>      // 计算容器元素累计总和</p>
</li>
<li>
<p><code>fill</code>                 // 向容器中添加元素</p>
<p>​</p>
</li>
</ul>
<h4 id="551-accumulate">5.5.1 accumulate</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>计算区间内 容器元素累计总和</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>accumulate(iterator beg, iterator end, value);  </code></p>
<p>// 计算容器元素累计总和</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 起始值</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-c++">#include &lt;numeric&gt;
#include &lt;vector&gt;
void test01()
{
	vector&lt;int&gt; v;
	for (int i = 0; i &lt;= 100; i++) {
		v.push_back(i);
	}

	int total = accumulate(v.begin(), v.end(), 0);

	cout &lt;&lt; &quot;total = &quot; &lt;&lt; total &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>**总结：**accumulate使用时头文件注意是 numeric，这个算法很实用</p>
<h4 id="552-fill">5.5.2 fill</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>向容器中填充指定的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>fill(iterator beg, iterator end, value);  </code></p>
<p>// 向容器中填充元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 填充的值</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-c++">#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

class myPrint
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	}
};

void test01()
{

	vector&lt;int&gt; v;
	v.resize(10);
	//填充
	fill(v.begin(), v.end(), 100);

	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>**总结：**利用fill可以将容器区间内元素填充为 指定的值</p>
<h3 id="56-常用集合算法">5.6 常用集合算法</h3>
<p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的集合算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li>
<p><code>set_intersection</code>          // 求两个容器的交集</p>
</li>
<li>
<p><code>set_union</code>                       // 求两个容器的并集</p>
</li>
<li>
<p><code>set_difference </code>              // 求两个容器的差集</p>
<p>​</p>
</li>
</ul>
<h4 id="561-set_intersection">5.6.1 set_intersection</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>求两个容器的交集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>// 求两个集合的交集</p>
<p>// <strong>注意:两个集合必须是有序序列</strong></p>
<p>// beg1 容器1开始迭代器<br>
// end1 容器1结束迭代器<br>
// beg2 容器2开始迭代器<br>
// end2 容器2结束迭代器<br>
// dest 目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;vector&gt;
#include &lt;algorithm&gt;

class myPrint
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	}
};

void test01()
{
	vector&lt;int&gt; v1;
	vector&lt;int&gt; v2;
	for (int i = 0; i &lt; 10; i++)
    {
		v1.push_back(i);
		v2.push_back(i+5);
	}

	vector&lt;int&gt; vTarget;
	//取两个里面较小的值给目标容器开辟空间
	vTarget.resize(min(v1.size(), v2.size()));

	//返回目标容器的最后一个元素的迭代器地址
	vector&lt;int&gt;::iterator itEnd = 
        set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());

	for_each(vTarget.begin(), itEnd, myPrint());
	cout &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>总结：</strong></p>
<ul>
<li>求交集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li>
<li>set_intersection返回值既是交集中最后一个元素的位置</li>
</ul>
<h4 id="562-set_union">5.6.2 set_union</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的并集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>// 求两个集合的并集</p>
<p>// <strong>注意:两个集合必须是有序序列</strong></p>
<p>// beg1 容器1开始迭代器<br>
// end1 容器1结束迭代器<br>
// beg2 容器2开始迭代器<br>
// end2 容器2结束迭代器<br>
// dest 目标容器开始迭代器</p>
<p>​</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;vector&gt;
#include &lt;algorithm&gt;

class myPrint
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	}
};

void test01()
{
	vector&lt;int&gt; v1;
	vector&lt;int&gt; v2;
	for (int i = 0; i &lt; 10; i++) {
		v1.push_back(i);
		v2.push_back(i+5);
	}

	vector&lt;int&gt; vTarget;
	//取两个容器的和给目标容器开辟空间
	vTarget.resize(v1.size() + v2.size());

	//返回目标容器的最后一个元素的迭代器地址
	vector&lt;int&gt;::iterator itEnd = 
        set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());

	for_each(vTarget.begin(), itEnd, myPrint());
	cout &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>总结：</strong></p>
<ul>
<li>求并集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要<strong>两个容器相加</strong></li>
<li>set_union返回值既是并集中最后一个元素的位置</li>
</ul>
<h4 id="563-set_difference">5.6.3  set_difference</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的差集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>// 求两个集合的差集</p>
<p>// <strong>注意:两个集合必须是有序序列</strong></p>
<p>// beg1 容器1开始迭代器<br>
// end1 容器1结束迭代器<br>
// beg2 容器2开始迭代器<br>
// end2 容器2结束迭代器<br>
// dest 目标容器开始迭代器</p>
<p>​</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;vector&gt;
#include &lt;algorithm&gt;

class myPrint
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
	}
};

void test01()
{
	vector&lt;int&gt; v1;
	vector&lt;int&gt; v2;
	for (int i = 0; i &lt; 10; i++) {
		v1.push_back(i);
		v2.push_back(i+5);
	}

	vector&lt;int&gt; vTarget;
	//取两个里面较大的值给目标容器开辟空间
	vTarget.resize( max(v1.size() , v2.size()));

	//返回目标容器的最后一个元素的迭代器地址
	cout &lt;&lt; &quot;v1与v2的差集为： &quot; &lt;&lt; endl;
	vector&lt;int&gt;::iterator itEnd = 
        set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());
	for_each(vTarget.begin(), itEnd, myPrint());
	cout &lt;&lt; endl;


	cout &lt;&lt; &quot;v2与v1的差集为： &quot; &lt;&lt; endl;
	itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());
	for_each(vTarget.begin(), itEnd, myPrint());
	cout &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>总结：</strong></p>
<ul>
<li>求差集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li>
<li>set_difference返回值既是差集中最后一个元素的位置</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转自黑马】C++核心编程笔记]]></title>
        <id>https://Ilosyi.github.io/post/zhuan-zi-hei-ma-che-xin-bian-cheng-bi-ji/</id>
        <link href="https://Ilosyi.github.io/post/zhuan-zi-hei-ma-che-xin-bian-cheng-bi-ji/">
        </link>
        <updated>2024-08-07T14:31:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c核心编程">C++核心编程</h1>
<p><ul class="markdownIt-TOC">
<li><a href="#c%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B">C++核心编程</a>
<ul>
<li><a href="#1-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B">1 内存分区模型</a>
<ul>
<li><a href="#11-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%89%8D">1.1 程序运行前</a></li>
<li><a href="#12-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%90%8E">1.2 程序运行后</a></li>
<li><a href="#13-new%E6%93%8D%E4%BD%9C%E7%AC%A6">1.3 new操作符</a></li>
</ul>
</li>
<li><a href="#2-%E5%BC%95%E7%94%A8">2 引用</a>
<ul>
<li><a href="#21-%E5%BC%95%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">2.1 引用的基本使用</a></li>
<li><a href="#22-%E5%BC%95%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">2.2 引用注意事项</a></li>
<li><a href="#23-%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">2.3 引用做函数参数</a></li>
<li><a href="#24-%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC">2.4 引用做函数返回值</a></li>
<li><a href="#25-%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8">2.5 引用的本质</a></li>
<li><a href="#26-%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8">2.6 常量引用</a></li>
</ul>
</li>
<li><a href="#3-%E5%87%BD%E6%95%B0%E6%8F%90%E9%AB%98">3 函数提高</a>
<ul>
<li><a href="#31-%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0">3.1 函数默认参数</a></li>
<li><a href="#32-%E5%87%BD%E6%95%B0%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0">3.2 函数占位参数</a></li>
<li><a href="#33-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">3.3 函数重载</a>
<ul>
<li><a href="#331-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%A6%82%E8%BF%B0">3.3.1 函数重载概述</a></li>
<li><a href="#332-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">3.3.2 函数重载注意事项</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><strong>4</strong> 类和对象</a>
<ul>
<li><a href="#41-%E5%B0%81%E8%A3%85">4.1 封装</a>
<ul>
<li><a href="#411-%E5%B0%81%E8%A3%85%E7%9A%84%E6%84%8F%E4%B9%89">4.1.1  封装的意义</a></li>
<li><a href="#412-struct%E5%92%8Cclass%E5%8C%BA%E5%88%AB">4.1.2 struct和class区别</a></li>
<li><a href="#413-%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%A7%81%E6%9C%89">4.1.3 成员属性设置为私有</a></li>
</ul>
</li>
<li><a href="#42-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86">4.2 对象的初始化和清理</a>
<ul>
<li><a href="#421-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">4.2.1 构造函数和析构函数</a></li>
<li><a href="#422-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E8%B0%83%E7%94%A8">4.2.2 构造函数的分类及调用</a></li>
<li><a href="#423-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA">4.2.3 拷贝构造函数调用时机</a></li>
<li><a href="#424-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99">4.2.4 构造函数调用规则</a></li>
<li><a href="#425-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D">4.2.5 深拷贝与浅拷贝</a></li>
<li><a href="#426-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8">4.2.6 初始化列表</a></li>
<li><a href="#427-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98">4.2.7 类对象作为类成员</a></li>
<li><a href="#428-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98">4.2.8 静态成员</a></li>
</ul>
</li>
<li><a href="#43-c%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E9%92%88">4.3 C++对象模型和this指针</a>
<ul>
<li><a href="#431-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%86%E5%BC%80%E5%AD%98%E5%82%A8">4.3.1 成员变量和成员函数分开存储</a></li>
<li><a href="#432-this%E6%8C%87%E9%92%88%E6%A6%82%E5%BF%B5">4.3.2 this指针概念</a></li>
<li><a href="#433-%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">4.3.3 空指针访问成员函数</a></li>
<li><a href="#434-const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">4.3.4 const修饰成员函数</a></li>
</ul>
</li>
<li><a href="#44-%E5%8F%8B%E5%85%83">4.4 友元</a>
<ul>
<li><a href="#441-%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83">4.4.1 全局函数做友元</a></li>
<li><a href="#442-%E7%B1%BB%E5%81%9A%E5%8F%8B%E5%85%83">4.4.2 类做友元</a></li>
<li><a href="#443-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83">4.4.3 成员函数做友元</a></li>
</ul>
</li>
<li><a href="#45-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">4.5 运算符重载</a>
<ul>
<li><a href="#451-%E5%8A%A0%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">4.5.1 加号运算符重载</a></li>
<li><a href="#452-%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">4.5.2 左移运算符重载</a></li>
<li><a href="#453-%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">4.5.3 递增运算符重载</a></li>
<li><a href="#454-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">4.5.4 赋值运算符重载</a></li>
<li><a href="#455-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">4.5.5 关系运算符重载</a></li>
<li><a href="#456-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">4.5.6 函数调用运算符重载</a></li>
</ul>
</li>
<li><a href="#46-%E7%BB%A7%E6%89%BF">4.6  继承</a>
<ul>
<li><a href="#461-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">4.6.1 继承的基本语法</a></li>
<li><a href="#462-%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F">4.6.2 继承方式</a></li>
<li><a href="#463-%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">4.6.3 继承中的对象模型</a></li>
<li><a href="#464-%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F">4.6.4 继承中构造和析构顺序</a></li>
<li><a href="#465-%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F">4.6.5 继承同名成员处理方式</a></li>
<li><a href="#466-%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F">4.6.6 继承同名静态成员处理方式</a></li>
<li><a href="#467-%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95">4.6.7 多继承语法</a></li>
<li><a href="#468-%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF">4.6.8 菱形继承</a></li>
</ul>
</li>
<li><a href="#47-%E5%A4%9A%E6%80%81">4.7  多态</a>
<ul>
<li><a href="#471-%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">4.7.1 多态的基本概念</a></li>
<li><a href="#472-%E5%A4%9A%E6%80%81%E6%A1%88%E4%BE%8B%E4%B8%80-%E8%AE%A1%E7%AE%97%E5%99%A8%E7%B1%BB">4.7.2 多态案例一-计算器类</a></li>
<li><a href="#473-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB">4.7.3 纯虚函数和抽象类</a></li>
<li><a href="#474-%E5%A4%9A%E6%80%81%E6%A1%88%E4%BE%8B%E4%BA%8C-%E5%88%B6%E4%BD%9C%E9%A5%AE%E5%93%81">4.7.4 多态案例二-制作饮品</a></li>
<li><a href="#475-%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84">4.7.5 虚析构和纯虚析构</a></li>
<li><a href="#476-%E5%A4%9A%E6%80%81%E6%A1%88%E4%BE%8B%E4%B8%89-%E7%94%B5%E8%84%91%E7%BB%84%E8%A3%85">4.7.6 多态案例三-电脑组装</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C">5 文件操作</a>
<ul>
<li><a href="#51%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6">5.1文本文件</a>
<ul>
<li><a href="#511%E5%86%99%E6%96%87%E4%BB%B6">5.1.1写文件</a></li>
<li><a href="#512%E8%AF%BB%E6%96%87%E4%BB%B6">5.1.2读文件</a></li>
</ul>
</li>
<li><a href="#52-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6">5.2 二进制文件</a>
<ul>
<li><a href="#521-%E5%86%99%E6%96%87%E4%BB%B6">5.2.1 写文件</a></li>
<li><a href="#522-%E8%AF%BB%E6%96%87%E4%BB%B6">5.2.2 读文件</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>
本阶段主要针对C++<mark>面向对象</mark>编程技术做详细讲解，探讨C++中的核心和精髓。</p>
<h2 id="1-内存分区模型">1 内存分区模型</h2>
<p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li>
<li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li>
</ul>
<p><strong>内存四区意义：</strong></p>
<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>
<h3 id="11-程序运行前">1.1 程序运行前</h3>
<p>​	在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p>
<p>​	<strong>代码区：</strong></p>
<p>​		存放 CPU 执行的机器指令</p>
<p>​		代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>
<p>​		代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p>
<p>​	<strong>全局区：</strong></p>
<p>​		全局变量和静态变量存放在此.</p>
<p>​		全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p>
<p>​		<mark>该区域的数据在程序结束后由操作系统释放</mark>.</p>
<p><strong>示例：</strong></p>
<pre><code class="language-c++">//全局变量
int g_a = 10;
int g_b = 10;

//全局常量
const int c_g_a = 10;
const int c_g_b = 10;

int main() {

	//局部变量
	int a = 10;
	int b = 10;

	//打印地址
	cout &lt;&lt; &quot;局部变量a地址为： &quot; &lt;&lt; (int)&amp;a &lt;&lt; endl;
	cout &lt;&lt; &quot;局部变量b地址为： &quot; &lt;&lt; (int)&amp;b &lt;&lt; endl;

	cout &lt;&lt; &quot;全局变量g_a地址为： &quot; &lt;&lt;  (int)&amp;g_a &lt;&lt; endl;
	cout &lt;&lt; &quot;全局变量g_b地址为： &quot; &lt;&lt;  (int)&amp;g_b &lt;&lt; endl;

	//静态变量
	static int s_a = 10;
	static int s_b = 10;

	cout &lt;&lt; &quot;静态变量s_a地址为： &quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl;
	cout &lt;&lt; &quot;静态变量s_b地址为： &quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl;

	cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world1&quot; &lt;&lt; endl;

	cout &lt;&lt; &quot;全局常量c_g_a地址为： &quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl;
	cout &lt;&lt; &quot;全局常量c_g_b地址为： &quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl;

	const int c_l_a = 10;
	const int c_l_b = 10;
	cout &lt;&lt; &quot;局部常量c_l_a地址为： &quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl;
	cout &lt;&lt; &quot;局部常量c_l_b地址为： &quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>打印结果：</p>
<figure data-type="image" tabindex="1"><img src="assets/1545017602518.png" alt="1545017602518" loading="lazy"></figure>
<p>总结：</p>
<ul>
<li>C++中在程序运行前分为全局区和代码区</li>
<li>代码区特点是共享和只读</li>
<li>全局区中存放全局变量、静态变量、常量</li>
<li>常量区中存放 const修饰的全局常量  和 字符串常量</li>
</ul>
<h3 id="12-程序运行后">1.2 程序运行后</h3>
<p>​	<strong>栈区：</strong></p>
<p>​		由编译器自动分配释放, 存放函数的参数值,局部变量等</p>
<p>​		注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>
<p><strong>示例：</strong></p>
<pre><code class="language-c++">int * func()
{
	int a = 10;
	return &amp;a;
}

int main() {

	int *p = func();

	cout &lt;&lt; *p &lt;&lt; endl;
	cout &lt;&lt; *p &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>​	<strong>堆区：</strong></p>
<p>​		由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p>
<p>​		在C++中主要利用new在堆区开辟内存</p>
<p><strong>示例：</strong></p>
<pre><code class="language-c++">int* func()
{
	int* a = new int(10);
	return a;
}

int main() {

	int *p = func();

	cout &lt;&lt; *p &lt;&lt; endl;
	cout &lt;&lt; *p &lt;&lt; endl;
    
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>总结：</strong></p>
<p>堆区数据由程序员管理开辟和释放</p>
<p>堆区数据利用new关键字进行开辟内存</p>
<h3 id="13-new操作符">1.3 new操作符</h3>
<p>​	C++中利用<mark>new</mark>操作符在堆区开辟数据</p>
<p>​	堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 <mark>delete</mark></p>
<p>​	语法：<code> new 数据类型</code></p>
<p>​	利用new创建的数据，会返回该数据对应的类型的指针</p>
<p><strong>示例1： 基本语法</strong></p>
<pre><code class="language-c++">int* func()
{
	int* a = new int(10);
	return a;
}

int main() {

	int *p = func();

	cout &lt;&lt; *p &lt;&lt; endl;
	cout &lt;&lt; *p &lt;&lt; endl;

	//利用delete释放堆区数据
	delete p;

	//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>示例2：开辟数组</strong></p>
<pre><code class="language-c++">//堆区开辟数组
int main() {

	int* arr = new int[10];

	for (int i = 0; i &lt; 10; i++)
	{
		arr[i] = i + 100;
	}

	for (int i = 0; i &lt; 10; i++)
	{
		cout &lt;&lt; arr[i] &lt;&lt; endl;
	}
	//释放数组 delete 后加 []
	delete[] arr;

	system(&quot;pause&quot;);

	return 0;
}

</code></pre>
<h2 id="2-引用">2 引用</h2>
<h3 id="21-引用的基本使用">2.1 引用的基本使用</h3>
<p>**作用： **给变量起别名</p>
<p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">int main() {

	int a = 10;
	int &amp;b = a;

	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;

	b = 100;

	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h3 id="22-引用注意事项">2.2 引用注意事项</h3>
<ul>
<li>引用必须初始化</li>
<li>引用在初始化后，不可以改变</li>
</ul>
<p>示例：</p>
<pre><code class="language-C++">int main() {

	int a = 10;
	int b = 20;
	//int &amp;c; //错误，引用必须初始化
	int &amp;c = a; //一旦初始化后，就不可以更改
	c = b; //这是赋值操作，不是更改引用

	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h3 id="23-引用做函数参数">2.3 引用做函数参数</h3>
<p>**作用：**函数传参时，可以利用引用的技术让形参修饰实参</p>
<p>**优点：**可以简化指针修改实参</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//1. 值传递
void mySwap01(int a, int b) {
	int temp = a;
	a = b;
	b = temp;
}

//2. 地址传递
void mySwap02(int* a, int* b) {
	int temp = *a;
	*a = *b;
	*b = temp;
}

//3. 引用传递
void mySwap03(int&amp; a, int&amp; b) {
	int temp = a;
	a = b;
	b = temp;
}

int main() {

	int a = 10;
	int b = 20;

	mySwap01(a, b);
	cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;

	mySwap02(&amp;a, &amp;b);
	cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;

	mySwap03(a, b);
	cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}

</code></pre>
<blockquote>
<p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>
</blockquote>
<h3 id="24-引用做函数返回值">2.4 引用做函数返回值</h3>
<p>作用：引用是可以作为函数的返回值存在的</p>
<p>注意：<strong>不要返回局部变量引用</strong></p>
<p>用法：函数调用作为左值</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//返回局部变量引用
int&amp; test01() {
	int a = 10; //局部变量
	return a;
}

//返回静态变量引用
int&amp; test02() {
	static int a = 20;
	return a;
}

int main() {

	//不能返回局部变量的引用
	int&amp; ref = test01();
	cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;
	cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;

	//如果函数做左值，那么必须返回引用
	int&amp; ref2 = test02();
	cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;
	cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;

	test02() = 1000;

	cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;
	cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>​</p>
<h3 id="25-引用的本质">2.5 引用的本质</h3>
<p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p>
<p>讲解示例：</p>
<pre><code class="language-C++">//发现是引用，转换为 int* const ref = &amp;a;
void func(int&amp; ref){
	ref = 100; // ref是引用，转换为*ref = 100
}
int main(){
	int a = 10;
    
    //自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改
	int&amp; ref = a; 
	ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;
    
	cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl;
    
	func(a);
	return 0;
}
</code></pre>
<p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>
<h3 id="26-常量引用">2.6 常量引用</h3>
<p>**作用：**常量引用主要用来修饰形参，防止误操作</p>
<p>在函数形参列表中，可以加<mark>const修饰形参</mark>，防止形参改变实参</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//引用使用的场景，通常用来修饰形参
void showValue(const int&amp; v) {
	//v += 10;
	cout &lt;&lt; v &lt;&lt; endl;
}

int main() {

	//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误
	//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;
	const int&amp; ref = 10;

	//ref = 100;  //加入const后不可以修改变量
	cout &lt;&lt; ref &lt;&lt; endl;

	//函数中利用常量引用防止误操作修改实参
	int a = 10;
	showValue(a);

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h2 id="3-函数提高">3 函数提高</h2>
<h3 id="31-函数默认参数">3.1 函数默认参数</h3>
<p>在C++中，函数的形参列表中的形参是可以有默认值的。</p>
<p>语法：<code> 返回值类型  函数名 （参数= 默认值）{}</code></p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">int func(int a, int b = 10, int c = 10) {
	return a + b + c;
}

//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值
//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数
int func2(int a = 10, int b = 10);
int func2(int a, int b) {
	return a + b;
}

int main() {

	cout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(20, 20) &lt;&lt; endl;
	cout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(100) &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h3 id="32-函数占位参数">3.2 函数占位参数</h3>
<p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
<p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型){}</code></p>
<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//函数占位参数 ，占位参数也可以有默认参数
void func(int a, int) {
	cout &lt;&lt; &quot;this is func&quot; &lt;&lt; endl;
}

int main() {

	func(10,10); //占位参数必须填补

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h3 id="33-函数重载">3.3 函数重载</h3>
<h4 id="331-函数重载概述">3.3.1 函数重载概述</h4>
<p>**作用：**函数名可以相同，提高复用性</p>
<p><strong>函数重载满足条件：</strong></p>
<ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li>
</ul>
<p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//函数重载需要函数都在同一个作用域下
void func()
{
	cout &lt;&lt; &quot;func 的调用！&quot; &lt;&lt; endl;
}
void func(int a)
{
	cout &lt;&lt; &quot;func (int a) 的调用！&quot; &lt;&lt; endl;
}
void func(double a)
{
	cout &lt;&lt; &quot;func (double a)的调用！&quot; &lt;&lt; endl;
}
void func(int a ,double b)
{
	cout &lt;&lt; &quot;func (int a ,double b) 的调用！&quot; &lt;&lt; endl;
}
void func(double a ,int b)
{
	cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;
}

//函数返回值不可以作为函数重载条件
//int func(double a, int b)
//{
//	cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;
//}


int main() {

	func();
	func(10);
	func(3.14);
	func(10,3.14);
	func(3.14 , 10);
	
	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="332-函数重载注意事项">3.3.2 函数重载注意事项</h4>
<ul>
<li>引用作为重载条件</li>
<li>函数重载碰到函数默认参数</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//函数重载注意事项
//1、引用作为重载条件

void func(int &amp;a)
{
	cout &lt;&lt; &quot;func (int &amp;a) 调用 &quot; &lt;&lt; endl;
}

void func(const int &amp;a)
{
	cout &lt;&lt; &quot;func (const int &amp;a) 调用 &quot; &lt;&lt; endl;
}


//2、函数重载碰到函数默认参数

void func2(int a, int b = 10)
{
	cout &lt;&lt; &quot;func2(int a, int b = 10) 调用&quot; &lt;&lt; endl;
}

void func2(int a)
{
	cout &lt;&lt; &quot;func2(int a) 调用&quot; &lt;&lt; endl;
}

int main() {
	
	int a = 10;
	func(a); //调用无const
	func(10);//调用有const


	//func2(10); //碰到默认参数产生歧义，需要避免

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h2 id="4-类和对象"><strong>4</strong> 类和对象</h2>
<p>C++面向对象的三大特性为：<mark>封装、继承、多态</mark></p>
<p>C++认为<mark>万事万物都皆为对象</mark>，对象上有其属性和行为</p>
<p><strong>例如：</strong></p>
<p>​	人可以作为对象，属性有姓名、年龄、身高、体重...，行为有走、跑、跳、吃饭、唱歌...</p>
<p>​	车也可以作为对象，属性有轮胎、方向盘、车灯...,行为有载人、放音乐、放空调...</p>
<p>​	具有相同性质的<mark>对象</mark>，我们可以抽象称为<mark>类</mark>，人属于人类，车属于车类</p>
<h3 id="41-封装">4.1 封装</h3>
<h4 id="411-封装的意义">4.1.1  封装的意义</h4>
<p>封装是C++面向对象三大特性之一</p>
<p>封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<p><strong>封装意义一：</strong></p>
<p>​	在设计类的时候，属性和行为写在一起，表现事物</p>
<p><strong>语法：</strong> <code>class 类名{   访问权限： 属性  / 行为  };</code></p>
<p>**示例1：**设计一个圆类，求圆的周长</p>
<p><strong>示例代码：</strong></p>
<pre><code class="language-C++">//圆周率
const double PI = 3.14;

//1、封装的意义
//将属性和行为作为一个整体，用来表现生活中的事物

//封装一个圆类，求圆的周长
//class代表设计一个类，后面跟着的是类名
class Circle
{
public:  //访问权限  公共的权限

	//属性
	int m_r;//半径

	//行为
	//获取到圆的周长
	double calculateZC()
	{
		//2 * pi  * r
		//获取圆的周长
		return  2 * PI * m_r;
	}
};

int main() {

	//通过圆类，创建圆的对象
	// c1就是一个具体的圆
	Circle c1;
	c1.m_r = 10; //给圆对象的半径 进行赋值操作

	//2 * pi * 10 = = 62.8
	cout &lt;&lt; &quot;圆的周长为： &quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>**示例2：**设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p>
<p><strong>示例2代码：</strong></p>
<pre><code class="language-C++">//学生类
class Student {
public:
	void setName(string name) {
		m_name = name;
	}
	void setID(int id) {
		m_id = id;
	}

	void showStudent() {
		cout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name &lt;&lt; &quot; ID:&quot; &lt;&lt; m_id &lt;&lt; endl;
	}
public:
	string m_name;
	int m_id;
};

int main() {

	Student stu;
	stu.setName(&quot;德玛西亚&quot;);
	stu.setID(250);
	stu.showStudent();

	system(&quot;pause&quot;);

	return 0;
}

</code></pre>
<p><strong>封装意义二：</strong></p>
<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>
<p>访问权限有三种：</p>
<ol>
<li>public        公共权限</li>
<li>protected 保护权限</li>
<li>private      私有权限</li>
</ol>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//三种权限
//公共权限  public     类内可以访问  类外可以访问
//保护权限  protected  类内可以访问  类外不可以访问
//私有权限  private    类内可以访问  类外不可以访问

class Person
{
	//姓名  公共权限
public:
	string m_Name;

	//汽车  保护权限
protected:
	string m_Car;

	//银行卡密码  私有权限
private:
	int m_Password;

public:
	void func()
	{
		m_Name = &quot;张三&quot;;
		m_Car = &quot;拖拉机&quot;;
		m_Password = 123456;
	}
};

int main() {

	Person p;
	p.m_Name = &quot;李四&quot;;
	//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到
	//p.m_Password = 123; //私有权限类外访问不到

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="412-struct和class区别">4.1.2 struct和class区别</h4>
<p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p>
<p>区别：</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class   默认权限为私有</li>
</ul>
<pre><code class="language-C++">class C1
{
	int  m_A; //默认是私有权限
};

struct C2
{
	int m_A;  //默认是公共权限
};

int main() {

	C1 c1;
	c1.m_A = 10; //错误，访问权限是私有

	C2 c2;
	c2.m_A = 10; //正确，访问权限是公共

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="413-成员属性设置为私有">4.1.3 成员属性设置为私有</h4>
<p>**优点1：**将所有成员属性设置为私有，可以自己控制读写权限</p>
<p>**优点2：**对于写权限，我们可以检测数据的有效性</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Person {
public:

	//姓名设置可读可写
	void setName(string name) {
		m_Name = name;
	}
	string getName()
	{
		return m_Name;
	}


	//获取年龄 
	int getAge() {
		return m_Age;
	}
	//设置年龄
	void setAge(int age) {
		if (age &lt; 0 || age &gt; 150) {
			cout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl;
			return;
		}
		m_Age = age;
	}

	//情人设置为只写
	void setLover(string lover) {
		m_Lover = lover;
	}

private:
	string m_Name; //可读可写  姓名
	
	int m_Age; //只读  年龄

	string m_Lover; //只写  情人
};


int main() {

	Person p;
	//姓名设置
	p.setName(&quot;张三&quot;);
	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl;

	//年龄设置
	p.setAge(50);
	cout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl;

	//情人设置
	p.setLover(&quot;苍井&quot;);
	//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>练习案例1：设计立方体类</strong></p>
<p>设计立方体类(Cube)</p>
<p>求出立方体的面积和体积</p>
<p>分别用全局函数和成员函数判断两个立方体是否相等。</p>
<figure data-type="image" tabindex="2"><img src="assets/1545533548532.png" alt="1545533548532" loading="lazy"></figure>
<p><strong>练习案例2：点和圆的关系</strong></p>
<p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p>
<figure data-type="image" tabindex="3"><img src="assets/1545533829184.png" alt="1545533829184" loading="lazy"></figure>
<h3 id="42-对象的初始化和清理">4.2 对象的初始化和清理</h3>
<ul>
<li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li>
<li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li>
</ul>
<h4 id="421-构造函数和析构函数">4.2.1 构造函数和析构函数</h4>
<p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>
<p>​	一个对象或者变量没有初始状态，对其使用后果是未知</p>
<p>​	同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p>
<p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li>
</ul>
<p><strong>构造函数语法：</strong><code>类名(){}</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p><strong>析构函数语法：</strong> <code>~类名(){}</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号  ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
</ol>
<pre><code class="language-C++">class Person
{
public:
	//构造函数
	Person()
	{
		cout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl;
	}
	//析构函数
	~Person()
	{
		cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl;
	}

};

void test01()
{
	Person p;
}

int main() {
	
	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="422-构造函数的分类及调用">4.2.2 构造函数的分类及调用</h4>
<p>两种分类方式：</p>
<p>​	按参数分为： 有参构造和无参构造</p>
<p>​	按类型分为： 普通构造和拷贝构造</p>
<p>三种调用方式：</p>
<p>​	括号法</p>
<p>​	显示法</p>
<p>​	隐式转换法</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//1、构造函数分类
// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数
// 按照类型分类分为 普通构造和拷贝构造

class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;
	}
	//有参构造函数
	Person(int a) {
		age = a;
		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;
	}
	//拷贝构造函数
	Person(const Person&amp; p) {
		age = p.age;
		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;
	}
	//析构函数
	~Person() {
		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;
	}
public:
	int age;
};

//2、构造函数的调用
//调用无参构造函数
void test01() {
	Person p; //调用无参构造函数
}

//调用有参的构造函数
void test02() {

	//2.1  括号法，常用
	Person p1(10);
	//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明
	//Person p2();

	//2.2 显式法
	Person p2 = Person(10); 
	Person p3 = Person(p2);
	//Person(10)单独写就是匿名对象  当前行结束之后，马上析构

	//2.3 隐式转换法
	Person p4 = 10; // Person p4 = Person(10); 
	Person p5 = p4; // Person p5 = Person(p4); 

	//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明
	//Person p5(p4);
}

int main() {

	test01();
	//test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="423-拷贝构造函数调用时机">4.2.3 拷贝构造函数调用时机</h4>
<p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Person {
public:
	Person() {
		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;
		mAge = 0;
	}
	Person(int age) {
		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;
		mAge = age;
	}
	Person(const Person&amp; p) {
		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;
		mAge = p.mAge;
	}
	//析构函数在释放内存之前调用
	~Person() {
		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;
	}
public:
	int mAge;
};

//1. 使用一个已经创建完毕的对象来初始化一个新对象
void test01() {

	Person man(100); //p对象已经创建完毕
	Person newman(man); //调用拷贝构造函数
	Person newman2 = man; //拷贝构造

	//Person newman3;
	//newman3 = man; //不是调用拷贝构造函数，赋值操作
}

//2. 值传递的方式给函数参数传值
//相当于Person p1 = p;
void doWork(Person p1) {}
void test02() {
	Person p; //无参构造函数
	doWork(p);
}

//3. 以值方式返回局部对象
Person doWork2()
{
	Person p1;
	cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;
	return p1;
}

void test03()
{
	Person p = doWork2();
	cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;
}


int main() {

	//test01();
	//test02();
	test03();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="424-构造函数调用规则">4.2.4 构造函数调用规则</h4>
<p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下：</p>
<ul>
<li>
<p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</p>
</li>
<li>
<p>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</p>
</li>
</ul>
<p>示例：</p>
<pre><code class="language-C++">class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;
	}
	//有参构造函数
	Person(int a) {
		age = a;
		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;
	}
	//拷贝构造函数
	Person(const Person&amp; p) {
		age = p.age;
		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;
	}
	//析构函数
	~Person() {
		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;
	}
public:
	int age;
};

void test01()
{
	Person p1(18);
	//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作
	Person p2(p1);

	cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;
}

void test02()
{
	//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造
	Person p1; //此时如果用户自己没有提供默认构造，会出错
	Person p2(10); //用户提供的有参
	Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供

	//如果用户提供拷贝构造，编译器不会提供其他构造函数
	Person p4; //此时如果用户自己没有提供默认构造，会出错
	Person p5(10); //此时如果用户自己没有提供有参，会出错
	Person p6(p5); //用户自己提供拷贝构造
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="425-深拷贝与浅拷贝">4.2.5 深拷贝与浅拷贝</h4>
<p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;
	}
	//有参构造函数
	Person(int age ,int height) {
		
		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;

		m_age = age;
		m_height = new int(height);
		
	}
	//拷贝构造函数  
	Person(const Person&amp; p) {
		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;
		//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题
		m_age = p.m_age;
		m_height = new int(*p.m_height);
		
	}

	//析构函数
	~Person() {
		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;
		if (m_height != NULL)
		{
			delete m_height;
		}
	}
public:
	int m_age;
	int* m_height;
};

void test01()
{
	Person p1(18, 180);

	Person p2(p1);

	cout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl;

	cout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>
</blockquote>
<h4 id="426-初始化列表">4.2.6 初始化列表</h4>
<p><strong>作用：</strong></p>
<p>C++提供了初始化列表语法，用来初始化属性</p>
<p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... {}</code></p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Person {
public:

	////传统方式初始化
	//Person(int a, int b, int c) {
	//	m_A = a;
	//	m_B = b;
	//	m_C = c;
	//}

	//初始化列表方式初始化
	Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}
	void PrintPerson() {
		cout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl;
		cout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl;
		cout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl;
	}
private:
	int m_A;
	int m_B;
	int m_C;
};

int main() {

	Person p(1, 2, 3);
	p.PrintPerson();


	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="427-类对象作为类成员">4.2.7 类对象作为类成员</h4>
<p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>
<p>例如：</p>
<pre><code class="language-C++">class A {}
class B
{
    A a；
}
</code></pre>
<p>B类中有对象A作为成员，A为对象成员</p>
<p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Phone
{
public:
	Phone(string name)
	{
		m_PhoneName = name;
		cout &lt;&lt; &quot;Phone构造&quot; &lt;&lt; endl;
	}

	~Phone()
	{
		cout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl;
	}

	string m_PhoneName;

};


class Person
{
public:

	//初始化列表可以告诉编译器调用哪一个构造函数
	Person(string name, string pName) :m_Name(name), m_Phone(pName)
	{
		cout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl;
	}

	~Person()
	{
		cout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl;
	}

	void playGame()
	{
		cout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl;
	}

	string m_Name;
	Phone m_Phone;

};
void test01()
{
	//当类中成员是其他类对象时，我们称该成员为 对象成员
	//构造的顺序是 ：先调用对象成员的构造，再调用本类构造
	//析构顺序与构造相反
	Person p(&quot;张三&quot; , &quot;苹果X&quot;);
	p.playGame();

}


int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="428-静态成员">4.2.8 静态成员</h4>
<p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为：</p>
<ul>
<li>静态成员变量
<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul>
</li>
<li>静态成员函数
<ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<p>**示例1 ：**静态成员变量</p>
<pre><code class="language-C++">class Person
{
	
public:

	static int m_A; //静态成员变量

	//静态成员变量特点：
	//1 在编译阶段分配内存
	//2 类内声明，类外初始化
	//3 所有对象共享同一份数据

private:
	static int m_B; //静态成员变量也是有访问权限的
};
int Person::m_A = 10;
int Person::m_B = 10;

void test01()
{
	//静态成员变量两种访问方式

	//1、通过对象
	Person p1;
	p1.m_A = 100;
	cout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl;

	Person p2;
	p2.m_A = 200;
	cout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl; //共享同一份数据
	cout &lt;&lt; &quot;p2.m_A = &quot; &lt;&lt; p2.m_A &lt;&lt; endl;

	//2、通过类名
	cout &lt;&lt; &quot;m_A = &quot; &lt;&lt; Person::m_A &lt;&lt; endl;


	//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>**示例2：**静态成员函数</p>
<pre><code class="language-C++">class Person
{

public:

	//静态成员函数特点：
	//1 程序共享一个函数
	//2 静态成员函数只能访问静态成员变量
	
	static void func()
	{
		cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;
		m_A = 100;
		//m_B = 100; //错误，不可以访问非静态成员变量
	}

	static int m_A; //静态成员变量
	int m_B; // 
private:

	//静态成员函数也是有访问权限的
	static void func2()
	{
		cout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl;
	}
};
int Person::m_A = 10;


void test01()
{
	//静态成员变量两种访问方式

	//1、通过对象
	Person p1;
	p1.func();

	//2、通过类名
	Person::func();


	//Person::func2(); //私有权限访问不到
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h3 id="43-c对象模型和this指针">4.3 C++对象模型和this指针</h3>
<h4 id="431-成员变量和成员函数分开存储">4.3.1 成员变量和成员函数分开存储</h4>
<p>在C++中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上</p>
<pre><code class="language-C++">class Person {
public:
	Person() {
		mA = 0;
	}
	//非静态成员变量占对象空间
	int mA;
	//静态成员变量不占对象空间
	static int mB; 
	//函数也不占对象空间，所有函数共享一个函数实例
	void func() {
		cout &lt;&lt; &quot;mA:&quot; &lt;&lt; this-&gt;mA &lt;&lt; endl;
	}
	//静态成员函数也不占对象空间
	static void sfunc() {
	}
};

int main() {

	cout &lt;&lt; sizeof(Person) &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="432-this指针概念">4.3.2 this指针概念</h4>
<p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>
<p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li>当形参和成员变量同名时，可用this指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<pre><code class="language-C++">class Person
{
public:

	Person(int age)
	{
		//1、当形参和成员变量同名时，可用this指针来区分
		this-&gt;age = age;
	}

	Person&amp; PersonAddPerson(Person p)
	{
		this-&gt;age += p.age;
		//返回对象本身
		return *this;
	}

	int age;
};

void test01()
{
	Person p1(10);
	cout &lt;&lt; &quot;p1.age = &quot; &lt;&lt; p1.age &lt;&lt; endl;

	Person p2(10);
	p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);
	cout &lt;&lt; &quot;p2.age = &quot; &lt;&lt; p2.age &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="433-空指针访问成员函数">4.3.3 空指针访问成员函数</h4>
<p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//空指针访问成员函数
class Person {
public:

	void ShowClassName() {
		cout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl;
	}

	void ShowPerson() {
		if (this == NULL) {
			return;
		}
		cout &lt;&lt; mAge &lt;&lt; endl;
	}

public:
	int mAge;
};

void test01()
{
	Person * p = NULL;
	p-&gt;ShowClassName(); //空指针，可以调用成员函数
	p-&gt;ShowPerson();  //但是如果成员函数中用到了this指针，就不可以了
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="434-const修饰成员函数">4.3.4 const修饰成员函数</h4>
<p><strong>常函数：</strong></p>
<ul>
<li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p><strong>常对象：</strong></p>
<ul>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Person {
public:
	Person() {
		m_A = 0;
		m_B = 0;
	}

	//this指针的本质是一个指针常量，指针的指向不可修改
	//如果想让指针指向的值也不可以修改，需要声明常函数
	void ShowPerson() const {
		//const Type* const pointer;
		//this = NULL; //不能修改指针的指向 Person* const this;
		//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的

		//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量
		this-&gt;m_B = 100;
	}

	void MyFunc() const {
		//mA = 10000;
	}

public:
	int m_A;
	mutable int m_B; //可修改 可变的
};


//const修饰对象  常对象
void test01() {

	const Person person; //常量对象  
	cout &lt;&lt; person.m_A &lt;&lt; endl;
	//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问
	person.m_B = 100; //但是常对象可以修改mutable修饰成员变量

	//常对象访问成员函数
	person.MyFunc(); //常对象不能调用const的函数

}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h3 id="44-友元">4.4 友元</h3>
<p>生活中你的家有客厅(Public)，有你的卧室(Private)</p>
<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>
<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>
<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>
<p>友元的关键字为  <mark>friend</mark></p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h4 id="441-全局函数做友元">4.4.1 全局函数做友元</h4>
<pre><code class="language-C++">class Building
{
	//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容
	friend void goodGay(Building * building);

public:

	Building()
	{
		this-&gt;m_SittingRoom = &quot;客厅&quot;;
		this-&gt;m_BedRoom = &quot;卧室&quot;;
	}


public:
	string m_SittingRoom; //客厅

private:
	string m_BedRoom; //卧室
};


void goodGay(Building * building)
{
	cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;
	cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;
}


void test01()
{
	Building b;
	goodGay(&amp;b);
}

int main(){

	test01();

	system(&quot;pause&quot;);
	return 0;
}
</code></pre>
<h4 id="442-类做友元">4.4.2 类做友元</h4>
<pre><code class="language-C++">class Building;
class goodGay
{
public:

	goodGay();
	void visit();

private:
	Building *building;
};


class Building
{
	//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容
	friend class goodGay;

public:
	Building();

public:
	string m_SittingRoom; //客厅
private:
	string m_BedRoom;//卧室
};

Building::Building()
{
	this-&gt;m_SittingRoom = &quot;客厅&quot;;
	this-&gt;m_BedRoom = &quot;卧室&quot;;
}

goodGay::goodGay()
{
	building = new Building;
}

void goodGay::visit()
{
	cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;
	cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;
}

void test01()
{
	goodGay gg;
	gg.visit();

}

int main(){

	test01();

	system(&quot;pause&quot;);
	return 0;
}
</code></pre>
<h4 id="443-成员函数做友元">4.4.3 成员函数做友元</h4>
<pre><code class="language-C++">
class Building;
class goodGay
{
public:

	goodGay();
	void visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容
	void visit2(); 

private:
	Building *building;
};


class Building
{
	//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容
	friend void goodGay::visit();

public:
	Building();

public:
	string m_SittingRoom; //客厅
private:
	string m_BedRoom;//卧室
};

Building::Building()
{
	this-&gt;m_SittingRoom = &quot;客厅&quot;;
	this-&gt;m_BedRoom = &quot;卧室&quot;;
}

goodGay::goodGay()
{
	building = new Building;
}

void goodGay::visit()
{
	cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;
	cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;
}

void goodGay::visit2()
{
	cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;
	//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;
}

void test01()
{
	goodGay  gg;
	gg.visit();

}

int main(){
    
	test01();

	system(&quot;pause&quot;);
	return 0;
}
</code></pre>
<h3 id="45-运算符重载">4.5 运算符重载</h3>
<p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h4 id="451-加号运算符重载">4.5.1 加号运算符重载</h4>
<p>作用：实现两个自定义数据类型相加的运算</p>
<pre><code class="language-C++">class Person {
public:
	Person() {};
	Person(int a, int b)
	{
		this-&gt;m_A = a;
		this-&gt;m_B = b;
	}
	//成员函数实现 + 号运算符重载
	Person operator+(const Person&amp; p) {
		Person temp;
		temp.m_A = this-&gt;m_A + p.m_A;
		temp.m_B = this-&gt;m_B + p.m_B;
		return temp;
	}


public:
	int m_A;
	int m_B;
};

//全局函数实现 + 号运算符重载
//Person operator+(const Person&amp; p1, const Person&amp; p2) {
//	Person temp(0, 0);
//	temp.m_A = p1.m_A + p2.m_A;
//	temp.m_B = p1.m_B + p2.m_B;
//	return temp;
//}

//运算符重载 可以发生函数重载 
Person operator+(const Person&amp; p2, int val)  
{
	Person temp;
	temp.m_A = p2.m_A + val;
	temp.m_B = p2.m_B + val;
	return temp;
}

void test() {

	Person p1(10, 10);
	Person p2(20, 20);

	//成员函数方式
	Person p3 = p2 + p1;  //相当于 p2.operaor+(p1)
	cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl;


	Person p4 = p3 + 10; //相当于 operator+(p3,10)
	cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;

}

int main() {

	test();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>
</blockquote>
<blockquote>
<p>总结2：不要滥用运算符重载</p>
</blockquote>
<h4 id="452-左移运算符重载">4.5.2 左移运算符重载</h4>
<p>作用：可以输出自定义数据类型</p>
<pre><code class="language-C++">class Person {
	friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);

public:

	Person(int a, int b)
	{
		this-&gt;m_A = a;
		this-&gt;m_B = b;
	}

	//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果
	//void operator&lt;&lt;(Person&amp; p){
	//}

private:
	int m_A;
	int m_B;
};

//全局函数实现左移重载
//ostream对象只能有一个
ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) {
	out &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B;
	return out;
}

void test() {

	Person p1(10, 20);

	cout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; //链式编程
}

int main() {

	test();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
</blockquote>
<h4 id="453-递增运算符重载">4.5.3 递增运算符重载</h4>
<p>作用： 通过重载递增运算符，实现自己的整型数据</p>
<pre><code class="language-C++">
class MyInteger {

	friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);

public:
	MyInteger() {
		m_Num = 0;
	}
	//前置++
	MyInteger&amp; operator++() {
		//先++
		m_Num++;
		//再返回
		return *this;
	}

	//后置++
	MyInteger operator++(int) {
		//先返回
		MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；
		m_Num++;
		return temp;
	}

private:
	int m_Num;
};


ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) {
	out &lt;&lt; myint.m_Num;
	return out;
}


//前置++ 先++ 再返回
void test01() {
	MyInteger myInt;
	cout &lt;&lt; ++myInt &lt;&lt; endl;
	cout &lt;&lt; myInt &lt;&lt; endl;
}

//后置++ 先返回 再++
void test02() {

	MyInteger myInt;
	cout &lt;&lt; myInt++ &lt;&lt; endl;
	cout &lt;&lt; myInt &lt;&lt; endl;
}

int main() {

	test01();
	//test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结： 前置递增返回引用，后置递增返回值</p>
</blockquote>
<h4 id="454-赋值运算符重载">4.5.4 赋值运算符重载</h4>
<p>c++编译器至少给一个类添加4个函数</p>
<ol>
<li>默认构造函数(无参，函数体为空)</li>
<li>默认析构函数(无参，函数体为空)</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
<li>赋值运算符 operator=, 对属性进行值拷贝</li>
</ol>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Person
{
public:

	Person(int age)
	{
		//将年龄数据开辟到堆区
		m_Age = new int(age);
	}

	//重载赋值运算符 
	Person&amp; operator=(Person &amp;p)
	{
		if (m_Age != NULL)
		{
			delete m_Age;
			m_Age = NULL;
		}
		//编译器提供的代码是浅拷贝
		//m_Age = p.m_Age;

		//提供深拷贝 解决浅拷贝的问题
		m_Age = new int(*p.m_Age);

		//返回自身
		return *this;
	}


	~Person()
	{
		if (m_Age != NULL)
		{
			delete m_Age;
			m_Age = NULL;
		}
	}

	//年龄的指针
	int *m_Age;

};


void test01()
{
	Person p1(18);

	Person p2(20);

	Person p3(30);

	p3 = p2 = p1; //赋值操作

	cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl;

	cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl;

	cout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;
}

int main() {

	test01();

	//int a = 10;
	//int b = 20;
	//int c = 30;

	//c = b = a;
	//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
	//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;
	//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="455-关系运算符重载">4.5.5 关系运算符重载</h4>
<p>**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Person
{
public:
	Person(string name, int age)
	{
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	};

	bool operator==(Person &amp; p)
	{
		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	bool operator!=(Person &amp; p)
	{
		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)
		{
			return false;
		}
		else
		{
			return true;
		}
	}

	string m_Name;
	int m_Age;
};

void test01()
{
	//int a = 0;
	//int b = 0;

	Person a(&quot;孙悟空&quot;, 18);
	Person b(&quot;孙悟空&quot;, 18);

	if (a == b)
	{
		cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;
	}

	if (a != b)
	{
		cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;
	}
}


int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="456-函数调用运算符重载">4.5.6 函数调用运算符重载</h4>
<ul>
<li>函数调用运算符 ()  也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class MyPrint
{
public:
	void operator()(string text)
	{
		cout &lt;&lt; text &lt;&lt; endl;
	}

};
void test01()
{
	//重载的（）操作符 也称为仿函数
	MyPrint myFunc;
	myFunc(&quot;hello world&quot;);
}


class MyAdd
{
public:
	int operator()(int v1, int v2)
	{
		return v1 + v2;
	}
};

void test02()
{
	MyAdd add;
	int ret = add(10, 10);
	cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl;

	//匿名对象调用  
	cout &lt;&lt; &quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;
}

int main() {

	test01();
	test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h3 id="46-继承">4.6  继承</h3>
<p><strong>继承是面向对象三大特性之一</strong></p>
<p>有些类与类之间存在特殊的关系，例如下图中：</p>
<figure data-type="image" tabindex="4"><img src="assets/1544861202252.png" alt="1544861202252" loading="lazy"></figure>
<p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p>
<p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p>
<h4 id="461-继承的基本语法">4.6.1 继承的基本语法</h4>
<p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>
<p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>
<p><strong>普通实现：</strong></p>
<pre><code class="language-C++">//Java页面
class Java 
{
public:
	void header()
	{
		cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;
	}
	void footer()
	{
		cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;
	}
	void left()
	{
		cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;
	}
	void content()
	{
		cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl;
	}
};
//Python页面
class Python
{
public:
	void header()
	{
		cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;
	}
	void footer()
	{
		cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;
	}
	void left()
	{
		cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;
	}
	void content()
	{
		cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl;
	}
};
//C++页面
class CPP 
{
public:
	void header()
	{
		cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;
	}
	void footer()
	{
		cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;
	}
	void left()
	{
		cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;
	}
	void content()
	{
		cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl;
	}
};

void test01()
{
	//Java页面
	cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl;
	Java ja;
	ja.header();
	ja.footer();
	ja.left();
	ja.content();
	cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;

	//Python页面
	cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;
	Python py;
	py.header();
	py.footer();
	py.left();
	py.content();
	cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;

	//C++页面
	cout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;
	CPP cp;
	cp.header();
	cp.footer();
	cp.left();
	cp.content();

}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>继承实现：</strong></p>
<pre><code class="language-C++">//公共页面
class BasePage
{
public:
	void header()
	{
		cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;
	}

	void footer()
	{
		cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;
	}
	void left()
	{
		cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;
	}

};

//Java页面
class Java : public BasePage
{
public:
	void content()
	{
		cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl;
	}
};
//Python页面
class Python : public BasePage
{
public:
	void content()
	{
		cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl;
	}
};
//C++页面
class CPP : public BasePage
{
public:
	void content()
	{
		cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl;
	}
};

void test01()
{
	//Java页面
	cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl;
	Java ja;
	ja.header();
	ja.footer();
	ja.left();
	ja.content();
	cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;

	//Python页面
	cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;
	Python py;
	py.header();
	py.footer();
	py.left();
	py.content();
	cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;

	//C++页面
	cout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;
	CPP cp;
	cp.header();
	cp.footer();
	cp.left();
	cp.content();


}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p><strong>总结：</strong></p>
<p>继承的好处：<mark>可以减少重复的代码</mark></p>
<p>class A : public B;</p>
<p>A 类称为子类 或 派生类</p>
<p>B 类称为父类 或 基类</p>
<p><strong>派生类中的成员，包含两大部分</strong>：</p>
<p>一类是从基类继承过来的，一类是自己增加的成员。</p>
<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>
<h4 id="462-继承方式">4.6.2 继承方式</h4>
<p>继承的语法：<code>class 子类 : 继承方式  父类</code></p>
<p><strong>继承方式一共有三种：</strong></p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<figure data-type="image" tabindex="5"><img src="assets/clip_image002.png" alt="img" loading="lazy"></figure>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Base1
{
public: 
	int m_A;
protected:
	int m_B;
private:
	int m_C;
};

//公共继承
class Son1 :public Base1
{
public:
	void func()
	{
		m_A; //可访问 public权限
		m_B; //可访问 protected权限
		//m_C; //不可访问
	}
};

void myClass()
{
	Son1 s1;
	s1.m_A; //其他类只能访问到公共权限
}

//保护继承
class Base2
{
public:
	int m_A;
protected:
	int m_B;
private:
	int m_C;
};
class Son2:protected Base2
{
public:
	void func()
	{
		m_A; //可访问 protected权限
		m_B; //可访问 protected权限
		//m_C; //不可访问
	}
};
void myClass2()
{
	Son2 s;
	//s.m_A; //不可访问
}

//私有继承
class Base3
{
public:
	int m_A;
protected:
	int m_B;
private:
	int m_C;
};
class Son3:private Base3
{
public:
	void func()
	{
		m_A; //可访问 private权限
		m_B; //可访问 private权限
		//m_C; //不可访问
	}
};
class GrandSon3 :public Son3
{
public:
	void func()
	{
		//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到
		//m_A;
		//m_B;
		//m_C;
	}
};
</code></pre>
<h4 id="463-继承中的对象模型">4.6.3 继承中的对象模型</h4>
<p>**问题：**从父类继承过来的成员，哪些属于子类对象中？</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Base
{
public:
	int m_A;
protected:
	int m_B;
private:
	int m_C; //私有成员只是被隐藏了，但是还是会继承下去
};

//公共继承
class Son :public Base
{
public:
	int m_D;
};

void test01()
{
	cout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(Son) &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>利用工具查看：</p>
<figure data-type="image" tabindex="6"><img src="assets/1545881904150.png" alt="1545881904150" loading="lazy"></figure>
<p>打开工具窗口后，定位到当前CPP文件的盘符</p>
<p>然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名</p>
<p>效果如下图：</p>
<figure data-type="image" tabindex="7"><img src="assets/1545882158050.png" alt="1545882158050" loading="lazy"></figure>
<blockquote>
<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>
</blockquote>
<h4 id="464-继承中构造和析构顺序">4.6.4 继承中构造和析构顺序</h4>
<p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Base 
{
public:
	Base()
	{
		cout &lt;&lt; &quot;Base构造函数!&quot; &lt;&lt; endl;
	}
	~Base()
	{
		cout &lt;&lt; &quot;Base析构函数!&quot; &lt;&lt; endl;
	}
};

class Son : public Base
{
public:
	Son()
	{
		cout &lt;&lt; &quot;Son构造函数!&quot; &lt;&lt; endl;
	}
	~Son()
	{
		cout &lt;&lt; &quot;Son析构函数!&quot; &lt;&lt; endl;
	}

};


void test01()
{
	//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反
	Son s;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
</blockquote>
<h4 id="465-继承同名成员处理方式">4.6.5 继承同名成员处理方式</h4>
<p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>
<ul>
<li>访问子类同名成员   直接访问即可</li>
<li>访问父类同名成员   需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Base {
public:
	Base()
	{
		m_A = 100;
	}

	void func()
	{
		cout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl;
	}

	void func(int a)
	{
		cout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl;
	}

public:
	int m_A;
};


class Son : public Base {
public:
	Son()
	{
		m_A = 200;
	}

	//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数
	//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域
	void func()
	{
		cout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl;
	}
public:
	int m_A;
};

void test01()
{
	Son s;

	cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;
	cout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;

	s.func();
	s.Base::func();
	s.Base::func(10);

}
int main() {

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
}
</code></pre>
<p>总结：</p>
<ol>
<li>子类对象可以直接访问到子类中同名成员</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li>
</ol>
<h4 id="466-继承同名静态成员处理方式">4.6.6 继承同名静态成员处理方式</h4>
<p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>
<p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员   直接访问即可</li>
<li>访问父类同名成员   需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Base {
public:
	static void func()
	{
		cout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl;
	}
	static void func(int a)
	{
		cout &lt;&lt; &quot;Base - static void func(int a)&quot; &lt;&lt; endl;
	}

	static int m_A;
};

int Base::m_A = 100;

class Son : public Base {
public:
	static void func()
	{
		cout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl;
	}
	static int m_A;
};

int Son::m_A = 200;

//同名成员属性
void test01()
{
	//通过对象访问
	cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;
	Son s;
	cout &lt;&lt; &quot;Son  下 m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;
	cout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;

	//通过类名访问
	cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;Son  下 m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl;
	cout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;
}

//同名成员函数
void test02()
{
	//通过对象访问
	cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;
	Son s;
	s.func();
	s.Base::func();

	cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;
	Son::func();
	Son::Base::func();
	//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问
	Son::Base::func(100);
}
int main() {

	//test01();
	test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p>
</blockquote>
<h4 id="467-多继承语法">4.6.7 多继承语法</h4>
<p>C++允许<strong>一个类继承多个类</strong></p>
<p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p><strong>C++实际开发中不建议用多继承</strong></p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Base1 {
public:
	Base1()
	{
		m_A = 100;
	}
public:
	int m_A;
};

class Base2 {
public:
	Base2()
	{
		m_A = 200;  //开始是m_B 不会出问题，但是改为mA就会出现不明确
	}
public:
	int m_A;
};

//语法：class 子类：继承方式 父类1 ，继承方式 父类2 
class Son : public Base2, public Base1 
{
public:
	Son()
	{
		m_C = 300;
		m_D = 400;
	}
public:
	int m_C;
	int m_D;
};


//多继承容易产生成员同名的情况
//通过使用类名作用域可以区分调用哪一个基类的成员
void test01()
{
	Son s;
	cout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(s) &lt;&lt; endl;
	cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;
	cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>
</blockquote>
<h4 id="468-菱形继承">4.6.8 菱形继承</h4>
<p><strong>菱形继承概念：</strong></p>
<p>​	两个派生类继承同一个基类</p>
<p>​	又有某个类同时继承者两个派生类</p>
<p>​	这种继承被称为菱形继承，或者钻石继承</p>
<p><strong>典型的菱形继承案例：</strong></p>
<figure data-type="image" tabindex="8"><img src="assets/clip_image002.jpg" alt="IMG_256" loading="lazy"></figure>
<p><strong>菱形继承问题：</strong></p>
<ol>
<li>
<pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。
</code></pre>
</li>
<li>
<pre><code>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。
</code></pre>
</li>
</ol>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Animal
{
public:
	int m_Age;
};

//继承前加virtual关键字后，变为虚继承
//此时公共的父类Animal称为虚基类
class Sheep : virtual public Animal {};
class Tuo   : virtual public Animal {};
class SheepTuo : public Sheep, public Tuo {};

void test01()
{
	SheepTuo st;
	st.Sheep::m_Age = 100;
	st.Tuo::m_Age = 200;

	cout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;
	cout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;
	cout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl;
}


int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li>
<li>利用虚继承可以解决菱形继承问题</li>
</ul>
<h3 id="47-多态">4.7  多态</h3>
<h4 id="471-多态的基本概念">4.7.1 多态的基本概念</h4>
<p><strong>多态是C++面向对象三大特性之一</strong></p>
<p>多态分为两类</p>
<ul>
<li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li>
<li>动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li>
</ul>
<p>下面通过案例进行讲解多态</p>
<pre><code class="language-C++">class Animal
{
public:
	//Speak函数就是虚函数
	//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。
	virtual void speak()
	{
		cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;
	}
};

class Cat :public Animal
{
public:
	void speak()
	{
		cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl;
	}
};

class Dog :public Animal
{
public:

	void speak()
	{
		cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl;
	}

};
//我们希望传入什么对象，那么就调用什么对象的函数
//如果函数地址在编译阶段就能确定，那么静态联编
//如果函数地址在运行阶段才能确定，就是动态联编

void DoSpeak(Animal &amp; animal)
{
	animal.speak();
}
//
//多态满足条件： 
//1、有继承关系
//2、子类重写父类中的虚函数
//多态使用：
//父类指针或引用指向子类对象

void test01()
{
	Cat cat;
	DoSpeak(cat);


	Dog dog;
	DoSpeak(dog);
}


int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<p>多态满足条件</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p>多态使用条件</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p>
<h4 id="472-多态案例一-计算器类">4.7.2 多态案例一-计算器类</h4>
<p>案例描述：</p>
<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>
<p>多态的优点：</p>
<ul>
<li>代码组织结构清晰</li>
<li>可读性强</li>
<li>利于前期和后期的扩展以及维护</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//普通实现
class Calculator {
public:
	int getResult(string oper)
	{
		if (oper == &quot;+&quot;) {
			return m_Num1 + m_Num2;
		}
		else if (oper == &quot;-&quot;) {
			return m_Num1 - m_Num2;
		}
		else if (oper == &quot;*&quot;) {
			return m_Num1 * m_Num2;
		}
		//如果要提供新的运算，需要修改源码
	}
public:
	int m_Num1;
	int m_Num2;
};

void test01()
{
	//普通实现测试
	Calculator c;
	c.m_Num1 = 10;
	c.m_Num2 = 10;
	cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl;

	cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl;

	cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;
}



//多态实现
//抽象计算器类
//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护
class AbstractCalculator
{
public :

	virtual int getResult()
	{
		return 0;
	}

	int m_Num1;
	int m_Num2;
};

//加法计算器
class AddCalculator :public AbstractCalculator
{
public:
	int getResult()
	{
		return m_Num1 + m_Num2;
	}
};

//减法计算器
class SubCalculator :public AbstractCalculator
{
public:
	int getResult()
	{
		return m_Num1 - m_Num2;
	}
};

//乘法计算器
class MulCalculator :public AbstractCalculator
{
public:
	int getResult()
	{
		return m_Num1 * m_Num2;
	}
};


void test02()
{
	//创建加法计算器
	AbstractCalculator *abc = new AddCalculator;
	abc-&gt;m_Num1 = 10;
	abc-&gt;m_Num2 = 10;
	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;
	delete abc;  //用完了记得销毁

	//创建减法计算器
	abc = new SubCalculator;
	abc-&gt;m_Num1 = 10;
	abc-&gt;m_Num2 = 10;
	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;
	delete abc;  

	//创建乘法计算器
	abc = new MulCalculator;
	abc-&gt;m_Num1 = 10;
	abc-&gt;m_Num2 = 10;
	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;
	delete abc;
}

int main() {

	//test01();

	test02();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<blockquote>
<p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p>
</blockquote>
<h4 id="473-纯虚函数和抽象类">4.7.3 纯虚函数和抽象类</h4>
<p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为<strong>纯虚函数</strong></p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p>
<p>当类中有了纯虚函数，这个类也称为<mark>抽象类</mark></p>
<p><strong>抽象类特点</strong>：</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Base
{
public:
	//纯虚函数
	//类中只要有一个纯虚函数就称为抽象类
	//抽象类无法实例化对象
	//子类必须重写父类中的纯虚函数，否则也属于抽象类
	virtual void func() = 0;
};

class Son :public Base
{
public:
	virtual void func() 
	{
		cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;
	};
};

void test01()
{
	Base * base = NULL;
	//base = new Base; // 错误，抽象类无法实例化对象
	base = new Son;
	base-&gt;func();
	delete base;//记得销毁
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="474-多态案例二-制作饮品">4.7.4 多态案例二-制作饮品</h4>
<p><strong>案例描述：</strong></p>
<p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p>
<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>
<figure data-type="image" tabindex="9"><img src="assets/1545985945198.png" alt="1545985945198" loading="lazy"></figure>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">//抽象制作饮品
class AbstractDrinking {
public:
	//烧水
	virtual void Boil() = 0;
	//冲泡
	virtual void Brew() = 0;
	//倒入杯中
	virtual void PourInCup() = 0;
	//加入辅料
	virtual void PutSomething() = 0;
	//规定流程
	void MakeDrink() {
		Boil();
		Brew();
		PourInCup();
		PutSomething();
	}
};

//制作咖啡
class Coffee : public AbstractDrinking {
public:
	//烧水
	virtual void Boil() {
		cout &lt;&lt; &quot;煮农夫山泉!&quot; &lt;&lt; endl;
	}
	//冲泡
	virtual void Brew() {
		cout &lt;&lt; &quot;冲泡咖啡!&quot; &lt;&lt; endl;
	}
	//倒入杯中
	virtual void PourInCup() {
		cout &lt;&lt; &quot;将咖啡倒入杯中!&quot; &lt;&lt; endl;
	}
	//加入辅料
	virtual void PutSomething() {
		cout &lt;&lt; &quot;加入牛奶!&quot; &lt;&lt; endl;
	}
};

//制作茶水
class Tea : public AbstractDrinking {
public:
	//烧水
	virtual void Boil() {
		cout &lt;&lt; &quot;煮自来水!&quot; &lt;&lt; endl;
	}
	//冲泡
	virtual void Brew() {
		cout &lt;&lt; &quot;冲泡茶叶!&quot; &lt;&lt; endl;
	}
	//倒入杯中
	virtual void PourInCup() {
		cout &lt;&lt; &quot;将茶水倒入杯中!&quot; &lt;&lt; endl;
	}
	//加入辅料
	virtual void PutSomething() {
		cout &lt;&lt; &quot;加入枸杞!&quot; &lt;&lt; endl;
	}
};

//业务函数
void DoWork(AbstractDrinking* drink) {
	drink-&gt;MakeDrink();
	delete drink;
}

void test01() {
	DoWork(new Coffee);
	cout &lt;&lt; &quot;--------------&quot; &lt;&lt; endl;
	DoWork(new Tea);
}


int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h4 id="475-虚析构和纯虚析构">4.7.5 虚析构和纯虚析构</h4>
<p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：</p>
<p><code>virtual ~类名(){}</code></p>
<p>纯虚析构语法：</p>
<p><code> virtual ~类名() = 0;</code></p>
<p><code>类名::~类名(){}</code></p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">class Animal {
public:

	Animal()
	{
		cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl;
	}
	virtual void Speak() = 0;

	//析构函数加上virtual关键字，变成虚析构函数
	//virtual ~Animal()
	//{
	//	cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;
	//}


	virtual ~Animal() = 0;
};

Animal::~Animal()
{
	cout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl;
}

//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。

class Cat : public Animal {
public:
	Cat(string name)
	{
		cout &lt;&lt; &quot;Cat构造函数调用！&quot; &lt;&lt; endl;
		m_Name = new string(name);
	}
	virtual void Speak()
	{
		cout &lt;&lt; *m_Name &lt;&lt;  &quot;小猫在说话!&quot; &lt;&lt; endl;
	}
	~Cat()
	{
		cout &lt;&lt; &quot;Cat析构函数调用!&quot; &lt;&lt; endl;
		if (this-&gt;m_Name != NULL) {
			delete m_Name;
			m_Name = NULL;
		}
	}

public:
	string *m_Name;
};

void test01()
{
	Animal *animal = new Cat(&quot;Tom&quot;);
	animal-&gt;Speak();

	//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏
	//怎么解决？给基类增加一个虚析构函数
	//虚析构函数就是用来解决通过父类指针释放子类对象
	delete animal;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<p>​	1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p>
<p>​	2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>
<p>​	3. 拥有纯虚析构函数的类也属于抽象类</p>
<h4 id="476-多态案例三-电脑组装">4.7.6 多态案例三-电脑组装</h4>
<p><strong>案例描述：</strong></p>
<p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>
<p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p>
<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p>
<p>测试时组装三台不同的电脑进行工作</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include&lt;iostream&gt;
using namespace std;

//抽象CPU类
class CPU
{
public:
	//抽象的计算函数
	virtual void calculate() = 0;
};

//抽象显卡类
class VideoCard
{
public:
	//抽象的显示函数
	virtual void display() = 0;
};

//抽象内存条类
class Memory
{
public:
	//抽象的存储函数
	virtual void storage() = 0;
};

//电脑类
class Computer
{
public:
	Computer(CPU * cpu, VideoCard * vc, Memory * mem)
	{
		m_cpu = cpu;
		m_vc = vc;
		m_mem = mem;
	}

	//提供工作的函数
	void work()
	{
		//让零件工作起来，调用接口
		m_cpu-&gt;calculate();

		m_vc-&gt;display();

		m_mem-&gt;storage();
	}

	//提供析构函数 释放3个电脑零件
	~Computer()
	{

		//释放CPU零件
		if (m_cpu != NULL)
		{
			delete m_cpu;
			m_cpu = NULL;
		}

		//释放显卡零件
		if (m_vc != NULL)
		{
			delete m_vc;
			m_vc = NULL;
		}

		//释放内存条零件
		if (m_mem != NULL)
		{
			delete m_mem;
			m_mem = NULL;
		}
	}

private:

	CPU * m_cpu; //CPU的零件指针
	VideoCard * m_vc; //显卡零件指针
	Memory * m_mem; //内存条零件指针
};

//具体厂商
//Intel厂商
class IntelCPU :public CPU
{
public:
	virtual void calculate()
	{
		cout &lt;&lt; &quot;Intel的CPU开始计算了！&quot; &lt;&lt; endl;
	}
};

class IntelVideoCard :public VideoCard
{
public:
	virtual void display()
	{
		cout &lt;&lt; &quot;Intel的显卡开始显示了！&quot; &lt;&lt; endl;
	}
};

class IntelMemory :public Memory
{
public:
	virtual void storage()
	{
		cout &lt;&lt; &quot;Intel的内存条开始存储了！&quot; &lt;&lt; endl;
	}
};

//Lenovo厂商
class LenovoCPU :public CPU
{
public:
	virtual void calculate()
	{
		cout &lt;&lt; &quot;Lenovo的CPU开始计算了！&quot; &lt;&lt; endl;
	}
};

class LenovoVideoCard :public VideoCard
{
public:
	virtual void display()
	{
		cout &lt;&lt; &quot;Lenovo的显卡开始显示了！&quot; &lt;&lt; endl;
	}
};

class LenovoMemory :public Memory
{
public:
	virtual void storage()
	{
		cout &lt;&lt; &quot;Lenovo的内存条开始存储了！&quot; &lt;&lt; endl;
	}
};


void test01()
{
	//第一台电脑零件
	CPU * intelCpu = new IntelCPU;
	VideoCard * intelCard = new IntelVideoCard;
	Memory * intelMem = new IntelMemory;

	cout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl;
	//创建第一台电脑
	Computer * computer1 = new Computer(intelCpu, intelCard, intelMem);
	computer1-&gt;work();
	delete computer1;

	cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl;
	//第二台电脑组装
	Computer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;
	computer2-&gt;work();
	delete computer2;

	cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl;
	//第三台电脑组装
	Computer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;
	computer3-&gt;work();
	delete computer3;

}
</code></pre>
<h2 id="5-文件操作">5 文件操作</h2>
<p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>
<p>通过<strong>文件可以将数据持久化</strong></p>
<p>C++中对文件操作需要包含头文件 <mark>&lt; fstream &gt;</mark></p>
<p>文件类型分为两种：</p>
<ol>
<li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li>
<li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li>
</ol>
<p>操作文件的三大类:</p>
<ol>
<li>ofstream：写操作</li>
<li>ifstream： 读操作</li>
<li>fstream ： 读写操作</li>
</ol>
<h3 id="51文本文件">5.1文本文件</h3>
<h4 id="511写文件">5.1.1写文件</h4>
<p>写文件步骤如下：</p>
<ol>
<li>
<p>包含头文件</p>
<p>#include &lt;fstream&gt;</p>
</li>
<li>
<p>创建流对象</p>
<p>ofstream ofs;</p>
</li>
<li>
<p>打开文件</p>
<p>ofs.open(&quot;文件路径&quot;,打开方式);</p>
</li>
<li>
<p>写数据</p>
<p>ofs &lt;&lt; &quot;写入的数据&quot;;</p>
</li>
<li>
<p>关闭文件</p>
<p>ofs.close();</p>
<p>​</p>
</li>
</ol>
<p>文件打开方式：</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>ios::in</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置：文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p>
<p>**例如：**用二进制方式写文件 <code>ios::binary |  ios:: out</code></p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;fstream&gt;

void test01()
{
	ofstream ofs;
	ofs.open(&quot;test.txt&quot;, ios::out);

	ofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl;
	ofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl;
	ofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl;

	ofs.close();
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>文件操作必须包含头文件 fstream</li>
<li>读文件可以利用 ofstream  ，或者fstream类</li>
<li>打开文件时候需要指定操作文件的路径，以及打开方式</li>
<li>利用&lt;&lt;可以向文件中写数据</li>
<li>操作完毕，要关闭文件</li>
</ul>
<h4 id="512读文件">5.1.2读文件</h4>
<p>读文件与写文件步骤相似，但是读取方式相对于比较多</p>
<p>读文件步骤如下：</p>
<ol>
<li>
<p>包含头文件</p>
<p>#include &lt;fstream&gt;</p>
</li>
<li>
<p>创建流对象</p>
<p>ifstream ifs;</p>
</li>
<li>
<p>打开文件并判断文件是否打开成功</p>
<p>ifs.open(&quot;文件路径&quot;,打开方式);</p>
</li>
<li>
<p>读数据</p>
<p>四种方式读取</p>
</li>
<li>
<p>关闭文件</p>
<p>ifs.close();</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;fstream&gt;
#include &lt;string&gt;
void test01()
{
	ifstream ifs;
	ifs.open(&quot;test.txt&quot;, ios::in);

	if (!ifs.is_open())
	{
		cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;
		return;
	}

	//第一种方式
	//char buf[1024] = { 0 };
	//while (ifs &gt;&gt; buf)
	//{
	//	cout &lt;&lt; buf &lt;&lt; endl;
	//}

	//第二种
	//char buf[1024] = { 0 };
	//while (ifs.getline(buf,sizeof(buf)))
	//{
	//	cout &lt;&lt; buf &lt;&lt; endl;
	//}

	//第三种
	//string buf;
	//while (getline(ifs, buf))
	//{
	//	cout &lt;&lt; buf &lt;&lt; endl;
	//}

	char c;
	while ((c = ifs.get()) != EOF)
	{
		cout &lt;&lt; c;
	}

	ifs.close();


}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>读文件可以利用 ifstream  ，或者fstream类</li>
<li>利用is_open函数可以判断文件是否打开成功</li>
<li>close 关闭文件</li>
</ul>
<h3 id="52-二进制文件">5.2 二进制文件</h3>
<p>以二进制的方式对文件进行读写操作</p>
<p>打开方式要指定为 <mark>ios::binary</mark></p>
<h4 id="521-写文件">5.2.1 写文件</h4>
<p>二进制方式写文件主要利用流对象调用成员函数write</p>
<p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p><strong>示例：</strong></p>
<pre><code class="language-C++">#include &lt;fstream&gt;
#include &lt;string&gt;

class Person
{
public:
	char m_Name[64];
	int m_Age;
};

//二进制文件  写文件
void test01()
{
	//1、包含头文件

	//2、创建输出流对象
	ofstream ofs(&quot;person.txt&quot;, ios::out | ios::binary);
	
	//3、打开文件
	//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);

	Person p = {&quot;张三&quot;  , 18};

	//4、写文件
	ofs.write((const char *)&amp;p, sizeof(p));

	//5、关闭文件
	ofs.close();
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<p>总结：</p>
<ul>
<li>文件输出流对象 可以通过write函数，以二进制方式写数据</li>
</ul>
<h4 id="522-读文件">5.2.2 读文件</h4>
<p>二进制方式读文件主要利用流对象调用成员函数read</p>
<p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p>示例：</p>
<pre><code class="language-C++">#include &lt;fstream&gt;
#include &lt;string&gt;

class Person
{
public:
	char m_Name[64];
	int m_Age;
};

void test01()
{
	ifstream ifs(&quot;person.txt&quot;, ios::in | ios::binary);
	if (!ifs.is_open())
	{
		cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;
	}

	Person p;
	ifs.read((char *)&amp;p, sizeof(p));

	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl;
}

int main() {

	test01();

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<ul>
<li>文件输入流对象 可以通过read函数，以二进制方式读数据</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[西边阅读教材综合教程3翻译]]></title>
        <id>https://Ilosyi.github.io/post/xi-bian-yue-du-jiao-cai-zong-he-jiao-cheng-3-fan-yi/</id>
        <link href="https://Ilosyi.github.io/post/xi-bian-yue-du-jiao-cai-zong-he-jiao-cheng-3-fan-yi/">
        </link>
        <updated>2024-06-21T05:46:12.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#unit-1">Unit 1</a>
<ul>
<li><a href="#part-1-%E6%B3%B0%E6%88%88%E5%B0%94%E6%B8%85%E5%8D%8E%E6%BC%94%E8%AE%B2">Part 1 泰戈尔清华演讲</a></li>
<li><a href="#part-2-%E5%85%A8%E7%90%83%E5%8C%96%E4%B8%AD%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%97%AE%E9%A2%98">Part 2 全球化中的身份问题</a></li>
</ul>
</li>
<li><a href="#unit-3">Unit 3</a>
<ul>
<li><a href="#part-2-%E5%85%A8%E7%90%83%E8%83%9C%E4%BB%BB%E5%8A%9B%E5%AD%A6%E7%94%9F%E9%9C%80%E8%A6%81%E7%9A%84%E7%9F%A5%E8%AF%86%E5%92%8C%E6%8A%80%E8%83%BD">Part 2 全球胜任力：学生需要的知识和技能</a></li>
</ul>
</li>
<li><a href="#unit-6">Unit 6</a>
<ul>
<li><a href="#part-2-%E5%BD%93%E6%88%91%E4%BB%AC%E8%99%90%E5%BE%85%E5%8A%A8%E7%89%A9%E6%97%B6%E6%88%91%E4%BB%AC%E4%B9%9F%E8%B4%AC%E4%BD%8E%E4%BA%86%E8%87%AA%E5%B7%B1">Part 2 当我们虐待动物时，我们也贬低了自己</a></li>
</ul>
</li>
<li><a href="#unit-7">Unit 7</a>
<ul>
<li><a href="#part-2-%E5%90%91%E8%87%AA%E7%84%B6%E5%AD%A6%E4%B9%A0">Part 2 向自然学习</a></li>
<li><a href="#part-1-%E5%BD%93%E6%88%91%E4%BB%AC%E4%B8%8E%E8%87%AA%E7%84%B6%E5%86%8D%E8%BF%9E%E6%8E%A5%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">Part 1 当我们与自然再连接时会发生什么</a></li>
</ul>
</li>
</ul>
<br>
Book 3  译文</p>
<h1 id="unit-1">Unit 1</h1>
<h2 id="part-1-泰戈尔清华演讲">Part 1 泰戈尔清华演讲</h2>
<p> 我的青年朋友，我眼看着你们年轻的面目，闪亮着聪明与诚恳的志趣，但我们的中间却是间隔着年岁的距离，我已经到了黄昏的海边；你们远远的站在那日出的家乡。我的心伸展到你们的心，你们有我的祝福。<br>
你们正可以自负，同时也应得知道你们的责任，如今你们生长在人类历史上最伟大的一个时期里，我们从我们的的苦恼与痛楚的火焰里隐隐地辩论出这时代的伟大。这苦痛是普遍的，我们还不十分知道前途是何等的光景。保持着生命的全部的种子，并不知道他包含着的完全的真理，就在那茎箨豁裂的俄顷我们也不能断定这里面生命将会滋长成什么方式，更无从知道他将来结成什么果实。<br>
 什么是这时期里伟大的事实？那就是我们的门户已经开豁，一个广博的未来的使者已经来到，他已经敲打我们的大门，我们门上的阻拦都已经让路。人类的种族都已经从他们的篱樊内出现，他们已经聚在一处。他们再不在他们隐秘的居处藏匿。我们现在应得在全世界的面前辩护我们的价值，不仅在我们容庞的家人前卖弄能耐，我们必得明证我们的存在的理由，我们必得从我们各家独有的文明里展览普遍的公认的成分。<br>
现在我是在中国。我问你们，我也问我自己，我们有的是什么，有什么东西可以从家里拿出来算是你们给这新时期的敬意。你们必须回答这个问题。你明白自己的心吗？你知道你自己的文化吗？你们史乘里最完善最永久的是什么？你们必得知道，如其你们想要自免于最大的侮辱，遭受蔑视，遭受弃却的侮辱。拿出你们的光亮来，加入这伟大的灯会，你们要来参与这世界文化的展览。<br>
 单这爱就使你们的生活美好。不是贪心与实利；他们只能产生做买卖的公事房，不是人住的家。<br>
能爱实体的事物却不过分的沾恋，而且能给他们一种优美的意致，这是一桩伟大的服务。<br>
上天的意思是要我们把这个世界化作我们自己的家，不是要我们存在这世界里像是住店似的。我们只能从一种服务里把这世界化成我们自己的家，那服务就在给他我们真心的爱，又从这爱里使他加美。<br>
你们看见在天然的事物里都有那表现的灵异，看园里的花，看天上的星，看地上的草叶子。你不能在试验室里分析那个美，你放不到你的口袋里去。（那美的表现是不可捉摸的。）<br>
 我是倦了，我年纪也大了。我也许再不能会见你们了。这也许是我们最后的一次集会。<br>
因此我竭我的至诚恳求你们不要错走路，不要惶惑，不要忘记你们的天职，千万不要理会那恶俗的力量的引诱，诞妄的巨体的叫唤，拥积的时尚与无意识，无目的的营利的诱惑。<br>
保持那凡事必求美满的理想，你们一切的工作，一切的行动都应得折中于那唯一的标准。<br>
如此你们虽则眷爱地上实体的事物，你们的精神还是无伤的，你们的使命是在拿天堂来给人间，拿灵魂来给一切的事物。</p>
<h2 id="part-2-全球化中的身份问题">Part 2 全球化中的身份问题</h2>
<p> 尽管全球化本质上是一个经济现象，但它只有在不同文化相互作用这个大背景下才有可能实现。相对经济而言，全球化过程中显现出来的文化渗出可以说被视为更大的威胁。反对全球化进程的声音与日俱增，人们担心全球化的过程会吞噬民族文化和个体特征。那些独特的文化特征将面临消失的危险，或者至少会被大大弱化。国际贸易以及在文化和其他领域里的外国直接投资使标准产品的大规模消费成为可能，这种消费有其负面影响，因为标准产品排挤了自产的、传统的和当地生产的商品及服务，或者逐渐把在本土被认同的文化价值简化为所谓的“纯”市场价值。<br>
 经济学是全球化中最重要的维度，它对政治施加影响，政治又反过来对其产生影响，这两者都对全球化的文化层面产生影响。国家之间的文化产品和服务的贸易是在全球的经济体系框架下进行的。“2013年，文化产品的贸易总量达到2128亿美元，几乎是2004年的两倍。这也进一步证明了在当今全球经济中文化产业的重要地位，”联合国教科文组织统计研究所的负责人西尔维亚·蒙托亚说。信息社会最重要的组成部分就是文化产业，目前它正以难以置信的速度在发展。文化产业的发展既可以创造文化价值，也可以改变文化价值，或者强化文化特性，但也能促使文化快速消亡。根据联合国开发计划署 1999 年的《人类发展报告》来看，世界上三分之二的人口并不能从基于国际贸易和技术发展的全球经济增长中获益，也没有机会成为当前信息社会的一份子。这种情况到目前为止依旧不乐观。这就有必要讨论一下文化是否能被当作全球化经济体系中的一个经济过程。<br>
 为了更好地理解这个问题的重要性，让我们看看文化产品及服务在我们生活中所占的比例：文化产品囊括众多，如书籍、杂志、多媒体产品等。文化服务业包括图书馆、档案与文件中心、博物馆等。据联合国教科文组织统计研究所数据，在2004到2013年期间，主要的消费产品从影视和音乐转到网络服务。截至2016年，世界十大文化输出国为中国、美国、英国、瑞士、印度、德国、意大利、法国、新加坡和土耳其。虽然近几年，像土耳其和印度这样的新兴市场正在加强文化产品输出，发达国家依然主导全球市场。自20世纪90年代以来，在全球范围内，大公司的聚集建立了文化市场的寡头垄断。大多数文化产业集中在美国与欧洲，其余分布在亚洲。<br>
 富国、强国所生产的文化产品和服务已经渗透了世界市场，置其他国家的人民和文化于不利的境地，因为它们缺乏竞争力。这些国家无法针对国际市场提升自己的文化产品和服务，也就无法参与国际竞争。其自然的结果就是没法进入被发达国家的跨国公司独占的领地发挥其影响。<br>
全球化挑战着各国的政府，甚至改变着人们的国家意识，事实上，社会和文化特性的根源也有可能被迫改变。但值得注意的是人们对地方文化的认同也日益增长。谁愿意为了成为世界公民而脱离自己的文化纽带呢？当今世界在对全球化的讨论中，越来越多的人认识到全球化带来的同质性会摧毁被简称为文化的国家身份。西雅图、达沃斯和日内瓦的抗议游行提醒人们全球化以及文化特性的问题需要我们进行更加严肃的思考。<br>
 下一个世纪这个世界将没有我们刚告别的旧世纪那么多姿多彩，别具一格。地方节日、服饰、习俗、庆典、宗教信仰和仪式是人类文化和民族多样性中浓妆艳抹的一笔，而现在这一切正在慢慢褪色殆尽，或只能成为少数民族或远离现代社会人群的保留物。我们社会中大多数人正抛弃这些文化特征，转向更为实用、更能适应当代生活的方式。世界上所有的国家都在或多或少地经历着这个过程，不是因为全球化，而是因为最终导致全球化的现代化。我们会对此感到遗憾的，在我们享受现代生活的舒适时，我们会思念那些消失的传统和过去的生活。在我们眼中，它们是那么迷人，那么新奇，那么多彩。</p>
<h1 id="unit-3">Unit 3</h1>
<h2 id="part-2-全球胜任力学生需要的知识和技能">Part 2 全球胜任力：学生需要的知识和技能</h2>
<p> 就国家安全、环境的可持续性以及经济发展而言，无论是国家所为还是日常生活都与其他国家政府，商业团体以及个人有着千丝万缕、错综复杂的联系。<br>
这个新现实帮助我们更加清晰地定义教育的功能和作用：如何为学生在互联世界获得成功做准备，把他们培养成21世纪国家需要的公民、劳动者以及领导者。学校的迫切任务就是要培养真正了解世界的人才——了解文化、语言以及经济、环境和社会体系的运行方式。<br>
经过仔细推敲和斟酌，我们对全球胜任力给出定义：全球胜任力是一种能够理解问题的全球性意义并采取行动的能力和素养。此概念清晰地诠释了21世纪学生需要的知识和技能。<br>
<strong>探究世界</strong><br>
 全球胜任力首先须具有探究世界的意识，对世界充满好奇，有兴趣去认知世界并了解其运行方式。具有全球胜任力的学生能够提出具有挑战性和“可探究的” 问题——这些问题可能没有唯一的正确答案，但它却需要人们在智力和情感上全面投入。他们提出的问题具有全球意义，所涉及的重要现象和重大事件，无论是在当地社区还是来世界各地，都全球相关。<br>
具有全球胜任力的学生能够表明他们所提出问题的重要性，知道如何判断、收集和分析可靠信息对这些问题进行回应。这些信息来源丰富，可能来自当地、国内和国外，语种也具多样性。他们具备把本地事务与和国际事务联系起来的能力，例如，当讲解学校开展的垃圾回收项目时，他们能从一种全球大趋势的角度对此举进行分析，而不仅仅限于自己所处的环境。<br>
<strong>识别观点</strong><br>
 具有全球胜任力的学生需要意识到他们的独特见解，其他人或认可或不认可。他们要能够表达和解释其他人、其他团体和不同思想流派的观点，并能发现影响这些观点的各种因素，包括知识、科技以及资源的不同获取途径是如何影响人们的观点的。对他人观点的理解植根于他们对其他文化历史知识以及当今事件的谙熟。他们能分析比较自己和别人观点的异同，当需要时他们能整合自己和别人的观点形成新的见解。<br>
<strong>交流观点</strong><br>
 具有全球胜任力的学生明白，文化背景、地理环境、宗教信仰、意识形态、财富状况和其他因素的不同，会导致交流对象的千差万别，基于相同的信息会有不同的理解。这些学生能够和不同的人群进行有效交流，不管是通过语言或者非语言的形式。由于英语已经日益成为贸易和交流的通用语言，具有全球胜任力的学生必须具备较高的英语水平，除此之外至少还需掌握一门其他世界语言。<br>
观点的交流发生在众多文化迥异的场合中，在相互合作的团队中更显重要。<br>
具有全球胜任力的学生能够把自己置于不同的文化环境，组织和加入不同的群体，协同目标有效工作。<br>
具有全球胜任力的学生还需在媒体和艺术方面有智慧。他们知道如何选择以及有效使用恰当的技术和媒介来和不同的受众交流，包括通过各种在线社交网络。简言之，他们有足够的技术和媒体知识应用于国际交际场景。<br>
<strong>采取行动</strong><br>
 从了解世界到改变世界需要使用什么样的知识和技能？首先要相信自己有改变世界的能力。具有全球胜任力的学生把自己当作参与者而不是旁观者。无论什么情况，他们都能够敏锐地意识到机会的存在，如针对性的人权宣传，或是创造那些人们现在不知道而未来需要的必备产品。不管是独自一人还是和他人合作，具有全球胜任力的学生总是能基于事实和洞察来拟想和权衡选择，既符合道德伦理，又具有创造性。他们能综合多方意见和对他人可能产生的结果来评估这些行为的潜在影响；他们显示出行动的勇气，同时又能不断反思自己的行为。<br>
<strong>运用学科以及交叉学科的专业知识</strong><br>
 全球胜任力难道只包含技能没有知识吗？答案是否定的。学习的内容很重要，以前如此，现在也如此。全球胜任力要求既要在学科范畴内应用上述能力，同时也能结合具体情况应用各门学科研究和创造知识的方法。具有全球胜任力的学生要学会使用探究学科知识的工具和方法，像历史学家、科学家以及艺术家那样去思考。<br>
 全球胜任力还要求具有通过交叉学科的视角去解读当今世界形势、问题以及趋势的能力，这样才能更好地理解问题的内在关联性，既要看到大主题，又要注意小细节。如果学生能阐释环境、金融、社会以及其他体系的内在关系，理解社会与文化之间的相对平衡会产生怎样的短期和长期影响，那么他们就具备了竞争优势。培养有全球胜任力的学生需要让他们感受到世界的复杂性，在受教育过程中参与到实质性的、适合他们成长的活动中。<br>
 在这个变化的世界中，全球胜任力是我们理解教育目的变化的关键所在。全球各地的学生都应该得到在全球经济中获得成功的机会，并作为世界公民为世界贡献力量。我们须为全球化的21世纪打造更具创造力、更具远见的教育体系。现在就行动起来吧！</p>
<h1 id="unit-6">Unit 6</h1>
<h2 id="part-2-当我们虐待动物时我们也贬低了自己">Part 2 当我们虐待动物时，我们也贬低了自己</h2>
<p> 把一头牛捆在拖拉机上，然后拖着它的腿来回搬动，这样的行为足以说明我们是如何看待动物和判断其价值的。几周前，动物保护协会发布的视频揭露了这样一幕以及屠宰场如何残忍地对待动物的其他行为。该视频在互联网上广为流传，公众震惊，同时也引起了联邦政府的调查。这里有一个更加深刻的教训我们应该铭记:无论我们是否吃肉，如果我们贬低动物，我们同时也贬低了自己的人格。<br>
仗势欺人者会因为控制、欺凌那些温顺、脆弱和毫无防备能力的人或动物而糟践自己。同样的，很显然，行不义之道也会降低人类的品格。<br>
多年来，人们一直就对动物应负有什么样的责任而争论不休。但是这个争论随着人们渐渐意识到一个事实而得到了升华——除非人类变得更加富有同情心、善良、仁慈和自制，不管是人类文明还是这个地球都不可能得以生存。<br>
 但是,为了搭建一个平台来反对残忍而痛苦的动物实验和屠宰技术，人们时常要求动物权利保护者证实动物也有伦理道德，也能够感受到身体和心理的疼痛。<br>
 然而，即使证明动物是无道德感的，对疼痛也不敏感，人类也没有理由粗暴地对待他们。我们绝大部分人从小接受的教育就是要爱护那些无生命的物体，即使他们不能感受到疼痛，也没有道德观念。我们被教导好书有尊严，要好好爱护。如果我们肆意破坏建筑物、汽车或其他一些物体,那就违反了法律。<br>
且不说人类因自己的一些残酷行为而被贬低，不断有研究表明动物也有道德准则和感知能力。大量的研究文献揭示动物界也有规范各自群体以防“犯罪”的行为准则。与我们的认识相反,我们看到了他们照顾同类以及其他种族成员时所表现出来的睿智、无私、勇敢和温柔。<br>
 动物界也有道德规范这一事实告诉我们人类和其他生物种类是密切相连的，并不存在共存的独立世界。我们之间的联系不是靠长鼻和长牙，也不是靠翅膀和喙，而是一种动物未能表达的、却比人类更完美的优秀品质，比如忠诚、诚实、聪慧、大度等。<br>
 人与动物的不同似乎更多地体现在我们能复杂地表达出这些品质。事实上，对动物仔细、深人的观察教会我们如何更好地认清自我和我们可能取得的成就，而这种教育还在持续。<br>
比如说，从大象身上，我们知道了力量和柔情可以并存。从羚羊身上，我们了解了什么是天性优雅。从猫和狗身上，我们认识到幸福不是来自于外界，不是来自于获取，而是来自于我们对任何一件小事或经历的付出。从鸟儿身上，我们学会了飞行的概念。从动物身上我们知道即使我们成年了，也不应该丢失童真，因为童真不取决于年龄而取决于我们的思维。<br>
 事实上，当我们利用了动物们对我们的信任、快乐、天真、纯洁这些孩子般的天性去虐待动物时，我们就离虐待孩子不远了。几十年来，研究者、儿童和动物保护主义者以及教育家们都指出了人们在对待动物和对待孩子上的表现具有相关性。<br>
但是，可能正是这种难以解释的、深切的爱，使我们可以和其他物种共同谱写美妙的交响乐。交响乐不是以重要或者不重要的音符和篇章构成，它们的美丽存在于简单和复杂的统一， 张扬和含蓄的统一，狂放和端庄的统一。在音乐领域里，最重要的是要让每一个音符和章节都能够发挥其最大价值，不管这个价值是多么的渺小。<br>
 同样，我们对动物的道义责任也不是一个高等动物对低等动物的责任。无私的爱接受了创造过程中的简单和复杂，狂野和温顺，充分展示每一个物种的价值，从而结合成一章交响乐。给动物以最高的尊严和尊敬是我们所有物种行为的“黄金准则”。</p>
<h1 id="unit-7">Unit 7</h1>
<h2 id="part-2-向自然学习">Part 2 向自然学习</h2>
<p> 我们的传统教育大多是“了解”自然。我们把自然作为与人类分离的东西和对我们有用的对象来研究。我们似乎认为自己要么是自然的主人，要么(从更文明的角度来讲)是自然的管家。我们研究自然，因为我们希望了解我们的仆人或我们的领地，以便更长久地充分利用自然。<br>
 当人类认为自己是地球的主人，拥有对地球的统治权时，他们就更有可能滥用和开发地球。因此，环保主义者认为自己是地球的管家，这是朝着正确的方向迈出的一步。而管理工作是需要负责的。只有在这样的环境观下，人们才更有可能去保护和关爱。然而，这两种观点都是以人类为中心的。从这两个角度来看，人类都是具有更高地位的高级物种。挪威哲学家阿恩·奈斯将这种以人为中心的自然环境关系称为“浅层生态”。<br>
阿恩·奈斯认为，人类和其他物种一样，都是自然界不可分割的一部分。毫无疑问，人类有自己杰出的才能和品质。他们有自己高度发达的感官、智力、意识和交流能力。但是，其他物种也有它们自己特别的、独一无二的的品质，而这些品质是人类不具备的。地球上的每一个物种， 无论是人类还是人类以外的物种，都以自己独特的方式为物种的进化、发展和延续做出贡献，而这些构成了物种存在的整体性。<br>
 因此，所有的生命，无论是人类还是非人类，不论其特质，都具有内在的价值。正如不论其阶层、地位、教育和财富，人人生来平等，又如不论其对社会有何作用，人人有权生存一样，所有物种不论其对人类的作用如何，都同样具有内在价值。阿恩·奈斯称之为“深层生态”。<br>
 从这个角度看，人类不是自然的主人或管家，而是自然的朋友。友谊这个词有两种含义。首先，我们认为那些我们认识的人是朋友，因为我们认识他们，我们和他们一起外出，我们一起共度时光，需要时，我们相互支持。但是，友谊还有另一层含义。当我们感受到无条件的同理心，并愿意付出我们的感情而不期待任何回报时，我们就成了朋友。可见，这个词的第二层意思告诉我们，友谊从某种意义上讲是一种相互关联和互惠关系。当我们能够不带任何优越感或自卑感地认同对方时，我们就创造了友谊的状态。这就是环保组织“地球之友”创始人的愿景。<br>
 当我们接受所有生命都有内在价值的那一刻，我们就能体会对所有生命的深刻敬畏之情，并开始体验将整个生命之网交织在一起的美丽、完整、丰富、慷慨和经济。<br>
 我们不再控制、拥有或占有，而是开始参与错综复杂的生命之网的编织过程。我们不再是地球的主人或管家，而是地球的参与者和共同创造者。当然，人类在宇宙中有其特殊的地位，但花朵、水果、真菌、蠕虫、蝴蝶、海洋、山脉以及所有的微观和宏观生物也有同样的地位。<br>
 我们不需要走很远就可以向大自然学习。无论我们在哪里，只要我们睁大眼睛，胸怀宽广，自然就是我们的老师。看看蜜蜂，我们可以从谦卑的蜜蜂身上学习转化的奥义。蜜蜂从这里采一点花蜜，从那里采一点花蜜，但在任何地方都不会采太多。从来没有一朵花抱怨蜜蜂采走了太多的花蜜。事实上，花很感激蜜蜂帮它们授粉。蜜蜂采了花蜜就不会浪费，它能将花蜜转化为甘甜、美味、有益健康的蜂蜜。如果人类学会像蜜蜂那样重构我们的社会运行体系，就不会有耗竭、浪费和污染。<br>
 科学作家珍妮·班亚斯称之为“仿生学”。在观察到蜘蛛丝和贝壳的美丽、弹性和复杂性后，她说:“我们人类为什么不观察自然，像自然那样设计我们的技术和工具呢?”如果我们遵循自然的模式，任何东西都不会短缺或匮乏，而是永远富足。观察大自然设计的种子有如此大的潜力是多么地美妙。小小的苹果籽长出苹果幼苗，苹果幼苗长成小苹果树，最后成长为一棵成熟的苹果树。苹果树结果，就会有更多苹果籽，然后就是更多苹果树，一直持续很多年。树叶落在地上，分解，成为树木和土壤的营养物质。到处都是物质的充裕。大自然永不知道匮乏，因为它从不知道浪费。<br>
 要想获得对自然运作的深刻见解，这种深入的观察和深刻的体验是必不可少的。在这里，伟大的科学、艺术和精神汇聚在一起。科学家、艺术家和诗人都从与自然的密切联系中找到了深刻的灵感。只有当我们能够不与自然割裂时，认同自然才有可能。要向自然学习，我们就需要置身于自然之中。</p>
<p>#Unit 8</p>
<h2 id="part-1-当我们与自然再连接时会发生什么">Part 1 当我们与自然再连接时会发生什么</h2>
<p> 人们长久以来直觉地认为置身自然之中对身心有益。从土著青少年在野外完成成人仪式到现代东亚文化中的“森林浴”，许多人都把自然看作治愈和个人成长之地。为什么是“自然”？没人知道确切的答案。但源于进化生物学家E. Q. 威尔森“亲生命”理论的一个假设表明，人们寻求自然体验是有进化原因的。我们更倾向于置身于美丽自然的空间里，因为这样的环境资源丰富 -- 它能提供最佳食物、住所和舒适性。这些进化需求也许可以解释为什么孩子们被自然环境吸引，我们为什么更乐于把自然融入建筑之中。<br>
现在，大量的文献证明自然对人类繁荣--我们的社会、心里和情感生活有积极影响。超过100多项研究表明，身处大自然、生活在大自然附近、甚至在绘画和视频中观看大自然，都能对我们的大脑、身体、感觉、思维过程和社会交往产生积极影响。特别是，观赏大自然似乎是一种内在回报，产生一连串正面情绪，平复神经系统。这些又反过来帮助我们更'好地培养开放性、创造性、联系性、慷慨度和适应性。<br>
话句话说，科学表明，我们寻求大自然不仅为了自身生存，也是为了社会和个人福祉。</p>
<p><strong>我们为什么需要大自然</strong><br><br>
 许多研究结果都得出同一结论：亲近自然或观赏自然会提升我们的幸福感。问题是-- 怎么做？<br>
毫无疑问，置身于大自然--甚至观看自然的图片，都能减少我们体内压力带来的生理症状，这意味着在大自然中我们不太焦虑和恐惧，因此我们可以对其他人和创造性思维模式更加开放。<br>
此外，大自然常常令人产生敬畏、惊奇和崇敬之情。各种情绪会带来不同的益处，可以促进从幸福到利他主义到谦虚到健康的一切。还有一些证据表明，接触大自然会影响大脑。观赏自然美景（至少是山水画或视频的形式）会激活大脑中与多巴胺释放相关的特定奖励回路，这给了我们一种使命感、喜悦感和追求目标的能量。<br>
 但是遗憾的是，人们花在户外的和沉浸在自然中的时间比以前少了。同样明显的是，在过去的30年里，人们的压力水平和忙碌感急剧上升。这些交汇的作用引得环境作家理查德∙洛夫造出了“自然缺失失调症”这一术语--一种与自然及其力量脱节所带来的痛苦症状。<br>
 也许我们应该注意并尝试修正，19世纪哲学家拉尔夫∙沃尔多∙艾默生曾这样描写大自然，“在那里我觉得生活中没有什么是大自然无法修复的 -- 没有耻辱，没有灾难（留下我们的眼睛）”。科学证实了艾默生的直觉。是时候认识到大自然不仅是自然资源，它也是通往人类健康和幸福的途径。</p>
<p><strong>东边教材链接https://www.kdocs.cn/l/cmRWYG5npilZ</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[中国近现代史纲要课程作业]]></title>
        <id>https://Ilosyi.github.io/post/zhong-guo-jin-xian-dai-shi-gang-yao-ke-cheng-zuo-ye/</id>
        <link href="https://Ilosyi.github.io/post/zhong-guo-jin-xian-dai-shi-gang-yao-ke-cheng-zuo-ye/">
        </link>
        <updated>2024-06-18T09:49:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="center红色文化探访武汉革命历史博物馆参观有感center"><center>红色文化探访——武汉革命历史博物馆参观有感</center></h2>
<center>姓名:xxx    &emsp;   班级xxx  &emsp; 学号:U2023xxxxx</center>  <br>
<font color=Crimson>仅供参考 请勿照抄</font><br>
&emsp;天地英雄气，千秋尚凛然。坐落于武昌红巷的武汉革命历史博物馆，是武汉知名的红色文化圣地，下辖武昌农讲所、毛泽东旧居、中共五大会址、起义门、中国共产党纪律建设历史陈列馆等五处革命旧址和红色场馆，青砖灰瓦，石板铺地，街旁大树参天，竹影摇曳，仿佛都诉说着那百年的峥嵘岁月，跌宕起伏。2023年11月，我有幸在学院党支部的组织下，参观了该博物馆。<br>
&emsp;走进大门，首先来到的是武昌农讲所。“农讲所”全名为“农民运动讲习所”，其目的是培养学生，使他们有能力领导和参与农民的武装斗争，为革命积蓄力量。农讲所分为教室、教务处、寝室、操场等部分。其中，教务处墙上的展板记录的校规，包含了学习任务，要求，惩罚等内容，其严格和严厉性令我震惊。三个月的时间内，大多来自农村的青年学生不仅要学习农民运动的有关基本知识，理论，现况，还要学习军事知识，进行军事训练，而他们住宿的地方呢，狭窄到一间房里放几十张床。这让我感受到革命胜利的来之不易。革命先辈们之所以能在如此艰苦的条件下努力学习，是因为他们有明确而崇高的理想信念，他们将民族的希望和未来背负于身。新时代的青年人，也应从历史中汲取营养，切实做到学史明理、学史增信、学史崇德、学史力行，肩负起实现中华民族伟大复兴的时代使命，而不是等着别人来实现。<br>
&emsp;从农讲所出来后，我们来到毛泽东旧居，这里真实地还原了当年的陈设，除了毛泽东和杨开慧，住在这里的还有儿子毛岸英、毛岸青、毛岸龙。蔡和森、彭湃、郭亮、夏明翰、毛泽民、毛泽覃、罗哲等共产党人，短短几行文字，几张照片，记录了老一辈共产党人波澜壮阔的一生，更让我们看到了中国共产党历史以来”甘将热血沃中华“的精神信念，看到了他们顽强不屈的意志品质，看到了中国人民团结一心，坚持不懈的精神。<br>
&emsp;由于时间原因，我们没有参观剩下三个旧址，而是来到了中国共产党成立一百周年的专题展，感受英雄城市的百年荣光，武汉是中国共产党的发祥地之一，是大革命中心和第一次国共合作的重要舞台。土地革命战争中，无数共产党人在武汉严酷的白色恐怖下坚持浴血斗争，谱写了气壮山河的理想信念之歌。全民族抗战初期，武汉成为全国抗日救亡运动中心，从历史到现实，从开天辟地到经天纬地，社会在变，制度在变，历经无数挫折与磨难，不变的是中国共产党人的初心和使命，现实的我们，也将继承这份理想信念，为中国人民谋幸福，为中华民族谋复兴。<br>
&emsp;“今日之责任，不在他人，而全在我青年。”梁启超的话语激励着毛泽东，亦激励着我们。前有周总理为中华崛起而读书，后有干万青少年奋发向上，为中华强大富强而努力。且看锦绣山河，屹立于东方的那一抹红。立于山巅，热泪盈眶。吾辈青少年，应绘新中国蓝图，铸造中华魂魄，展望美好未来。<br>
<p>附录 参观时拍摄的照片</p>
]]></content>
    </entry>
</feed>