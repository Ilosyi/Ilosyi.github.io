<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Ilosyi.github.io</id>
    <title>losyi的博客</title>
    <updated>2023-11-19T09:33:11.301Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Ilosyi.github.io"/>
    <link rel="self" href="https://Ilosyi.github.io/atom.xml"/>
    <logo>https://Ilosyi.github.io/images/avatar.png</logo>
    <icon>https://Ilosyi.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, losyi的博客</rights>
    <entry>
        <title type="html"><![CDATA[二维数组：八皇后 幻方 迷宫问题]]></title>
        <id>https://Ilosyi.github.io/post/er-wei-shu-zu-ba-huang-hou-yu-mi-gong-wen-ti/</id>
        <link href="https://Ilosyi.github.io/post/er-wei-shu-zu-ba-huang-hou-yu-mi-gong-wen-ti/">
        </link>
        <updated>2023-11-15T03:02:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-数组知识回顾">一、数组知识回顾</h1>
<h2 id="一维数组"><strong>一维数组</strong></h2>
<figure data-type="image" tabindex="1"><img src="https://Ilosyi.github.io/post-images/1700017396788.png" alt="" loading="lazy"></figure>
<h2 id="二维数组"><strong>二维数组</strong></h2>
<figure data-type="image" tabindex="2"><img src="https://Ilosyi.github.io/post-images/1700017554841.png" alt="" loading="lazy"></figure>
<h1 id="二-八皇后问题">二、八皇后问题</h1>
<p>八皇后问题是国际西洋棋棋手马克 斯·贝瑟尔于1848年提出： 在8×8格的国际象棋上摆放八个皇 后，使其不能互相攻击，即任意两个皇 后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。<br>
高斯认为有76种方案。1854年在柏林的 象棋杂志上不同的作者发表了40种不同的解 ，后来有人用图论的方法解出92种结果。 计算机发明后，有多种计算机语言可以 解决此问题。</p>
<h4 id="数据结构二维数组一维数组"><strong>数据结构：二维数组？一维数组？</strong></h4>
<h3 id="方案一二维数组"><strong>方案一：二维数组</strong></h3>
<p><img src="https://Ilosyi.github.io/post-images/1700018201814.png" alt="" loading="lazy"><br>
用一个8行8列的二维数组存储8*8的国际 象棋棋盘，数组元素初值为0；0-代表没有放皇后 1-代表放置了皇后。<br>
<code>int board[MAX_N][MAX_N];</code><br>
例如：<br>
chess[0][5]=1;//在第0行第5列放一个皇后<br>
chess[1][1]=1;//在第1行第1列放一个皇后</p>
<h3 id="方案二一维数组"><strong>方案二：一维数组</strong></h3>
<p>用下标代表行，值代表列。只要数组每个值各不相同，就说明不在同一行和列，从而简化了冲突的判断，只需要考虑是否<strong>对角线冲突</strong>。<br>
<img src="https://Ilosyi.github.io/post-images/1700050927644.png" alt="" loading="lazy"><br>
实际上等价于行号差与列号差的绝对值相同。因此可这样进行冲突检测：<br>
<code>if (queen[i] == col || abs(queen[i] - col) == abs(i - row))</code><br>
那么如何摆放呢？</p>
<h1 id="三-枚举方法">三、枚举方法</h1>
<p>最适合计算机也一定不会遗漏任何一种摆放的方法！摆放方式共有：8×8 ×8 ×8 ×8 ×8 ×8 ×8 = 8^8<br>
用八层for循环枚举。<br>
分析：同一列没有必要再摆放，若第n个皇后与前面冲突，则不用进行n+1个皇后的摆放，而应回到上一步。（回溯思想）</p>
<pre><code>void queen() {
int chess[8], i; // chess数组存放皇后的摆放，i用于输出皇后的循环变量

for (chess[0] = 0; chess[0] &lt;= 7; chess[0]++) // 对应第0行的8种摆放
    for (chess[1] = 0; chess[1] &lt;= 7; chess[1]++)
        for (chess[2] = 0; chess[2] &lt;= 7; chess[2]++)
            for (chess[3] = 0; chess[3] &lt;= 7; chess[3]++)
                for (chess[4] = 0; chess[4] &lt;= 7; chess[4]++)
                    for (chess[5] = 0; chess[5] &lt;= 7; chess[5]++)
                        for (chess[6] = 0; chess[6] &lt;= 7; chess[6]++)
                            for (chess[7] = 0; chess[7] &lt;= 7; chess[7]++)
                                if (check(chess, 8) == 1) // 如果不存在冲突则输出这种摆放方案
                                    for (i = 0; i &lt; 8; i++) // 输出每一行皇后的位置
                                        printf(&quot;%d &quot;, chess[i]);}
</code></pre>
<p>这段代码通过嵌套的循环尝试所有可能的皇后摆放方式。对于每种摆放方式，它调用名为 check 的函数，检查是否存在皇后之间的冲突（即是否存在在同一行、同一列或对角线上）。如果没有冲突，它就打印出每一行皇后的位置。</p>
<h1 id="四-回溯方法"><strong>四、回溯方法</strong></h1>
<pre><code>void queen() {
int chess[8], i; // chess存放皇后的摆放 i用于输出皇后的循环变量

// 循环尝试每一行的摆放方式
for (chess[0] = 0; chess[0] &lt;= 7; chess[0]++) {
    // 对应第0行的8种摆放
    for (chess[1] = 0; chess[1] &lt;= 7; chess[1]++) {
        // 如果存在冲突，则看下一种摆放
        if (check(chess, 2) == 0)
            continue;
        else
            // 循环尝试第2行的摆放方式
            for (chess[2] = 0; chess[2] &lt;= 7; chess[2]++) {
                // 如果存在冲突，则看下一种摆放
                if (check(chess, 3) == 0)
                    continue;
                else
                    // 循环尝试第3行的摆放方式
                    // ... （以此类推，一直到第7行）
                    for (chess[7] = 0; chess[7] &lt;= 7; chess[7]++) {
                        // 如果第8个皇后和前面7个冲突则看下一种摆放，否则输出这种摆放方式
                        if (check(chess, 8) == 0)
                            continue;
                        else
                            // 输出当前的摆放方式
                            for (i = 0; i &lt;= 7; i++)
                                print(chess[i]);
                    }
            }
    }
}
}
// 函数check用于检查当前皇后的摆放是否与前面的皇后有冲突
int check(int a[], int n) {
// 实现检查的逻辑，如果有冲突返回0，否则返回1}

// 函数print用于输出当前皇后的摆放
void print(int queenPosition) {
// 输出当前皇后的位置}
</code></pre>
<p>八重for循环 只能解决8皇后，如果变成N皇后呢？<br>
有一种思路：<br>
放下第1个皇后，还需要放下N-1个皇后；<br>
放下第2个皇后，还需要放下N-2个皇后；<br>
放下了第N个皇后，结束了(递归出口)<br>
递归的回溯算法分析：实际上是一个DFS算法<br>
<img src="https://Ilosyi.github.io/post-images/1700052099457.png" alt="" loading="lazy"><br>
最终代码（一维数组实现）:</p>
<pre><code>#include &lt;stdio.h&gt;
#include&lt;math.h&gt;
#define N 4
int queen[N];
bool isSafe(int row, int col) {
// 检查同一列是否有皇后
for (int i = 0; i &lt; row; i++) {
    if (queen[i] == col || abs(queen[i] - col) == abs(i - row)) {
        return false;
    }
}
return true;}

int placeQueen(int row) {
int count = 0;
if (row == N) {
    // 所有皇后都已经放置，找到一个解法       
    return 1;
}

for (int col = 0; col &lt; N; col++) {
    if (isSafe(row, col)) {
        // 在当前位置放置皇后
        queen[row] = col;
        // 递归放置下一行的皇后
        count+=placeQueen(row + 1);
        
    }
}
return count;}
int main()
{
int count=placeQueen(0);
printf(&quot;%d&quot;, count);
return 0;
}
</code></pre>
<h1 id="五-幻方问题"><strong>五、幻方问题</strong></h1>
<p>幻方是指将若干个自然数排成纵横各为若干个数的正方形，使在同一行、同一列和同一对角线上的几个数的和都相等。此时我们只考虑奇幻方问题。可见：https://www.luogu.com.cn/problem/P2615<br>
简单来说就是将1放在第一行的中间，下一个数放在上一个数“右上角”，若已被占，放在正下方。<br>
例如，三阶幻方为：<br>
8 1 6<br>
3 5 7<br>
4 9 2</p>
<pre><code>#include&lt;stdio.h&gt;
int n, a[40][40], x, y;
int main() {
scanf(&quot;%d&quot;, &amp;n);
x = 1, y = (n + 1) / 2;
for (int i = 1; i &lt;= n * n; i++) {
	a[x][y] = i;
	if (!a[(x - 2 + n) % n + 1][y % n + 1])
	{
		x = (x - 2 + n) % n + 1, y = y % n + 1;
	}
	else x = x % n + 1;//数学运算
}
for (int i = 1; i &lt;= n; i++) {
	for (int j = 1; j &lt;= n; j++) {
		printf(&quot;%d &quot;, a[i][j]);
	}
	printf(&quot;\n&quot;);
}
}
</code></pre>
<p>以下是if法题解，采用了动态内存分配。</p>
<pre><code>#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;

int main()
{
int n;
scanf(&quot;%d&quot;, &amp;n);

if (n &lt;= 0)
{
    printf(&quot;错误的输入。请输入一个正整数。&quot;);
    return 1;
}

int** a = (int**)malloc(sizeof(int*) * n);
if (a == NULL)
{
    printf(&quot;内存分配失败&quot;);
    return 1;
}

for (int i = 0; i &lt; n; i++)
{
    a[i] = (int*)malloc(sizeof(int) * n);
    if (a[i] == NULL)
    {
        printf(&quot;内存分配失败&quot;);
        return 1;
    }
}
int i = 0;
int j = (n - 1) / 2;
a[i][j] = 1;
for (int k = 2; k &lt;= n * n; k++)
{
    if (i == 0 &amp;&amp; j != n - 1)
    {
        i = n - 1;
        j++;
    }
    else if (i != 0 &amp;&amp; j == n - 1)
    {
        i--;
        j = 0;
    }
    else if (i == 0 &amp;&amp; j == n - 1)
    {
        i++;
    }
    else if (i != 0 &amp;&amp; j != n - 1)
    {
        if (i-1&gt;=0&amp;&amp;i-1&lt;n&amp;&amp;j+1&gt;=0&amp;&amp;j&lt;n&amp;&amp;(!(a[i - 1][j + 1] &gt;= 1 &amp;&amp; a[i - 1][j + 1] &lt;= n * n)))
        {
            i--;
            j++;
        }
        else
        {
            i++;
        }
    }
    a[i][j] = k;
}

for (int i = 0; i &lt; n; i++)
{
    for (int j = 0; j &lt; n; j++)
    {
        printf(&quot;%d &quot;, a[i][j]);
    }
    printf(&quot;\n&quot;);
}

for (int i = 0; i &lt; n; i++)
{
    free(a[i]);
}
free(a);

return 0;}
</code></pre>
<h1 id="六-迷宫问题"><strong>六、迷宫问题</strong></h1>
<p>迷宫问题显然无法用一维数组解决，因为同一行不只有一个“皇后”。采用DFS思想，先试探一个方向，若走不通，再返回上一步试探其它方向。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[信息技术导论实验课内容及程序代码]]></title>
        <id>https://Ilosyi.github.io/post/xin-xi-ji-zhu-dao-lun-shi-yan-ke-nei-rong-ji-cheng-xu-dai-ma/</id>
        <link href="https://Ilosyi.github.io/post/xin-xi-ji-zhu-dao-lun-shi-yan-ke-nei-rong-ji-cheng-xu-dai-ma/">
        </link>
        <updated>2023-11-08T08:42:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="实验一">实验一</h1>
<h2 id="1-开机进入固件查看bios">1 开机进入固件查看（BIOS）</h2>
<h2 id="2-键盘指法练习">2 键盘指法练习</h2>
<p>金山打字通，启动！<br>
测试时会从书上找一句话让你打字。</p>
<h1 id="实验二">实验二</h1>
<h2 id="1-windos常用命令操作">1 windos常用命令操作</h2>
<h2 id="2-网络的兴起视频">2 网络的兴起（视频）</h2>
<h2 id="3-程序作业">3 程序作业</h2>
<h3 id="1-简述">1 简述</h3>
<p>用某种编程语言，实现一段程序，实现进制转换。</p>
<h3 id="2-程序功能需求说明">2 程序功能需求说明</h3>
<h4 id="21-基本功能要求">2.1 基本功能要求</h4>
<p>输入：一串字符 功能：将字符串转为十六进制整数；并根据用户要求，分别将输入转为 3~12 进 制数，并输出转换结果。 输出范例： 输入（十六进制）：0x1234 输出（十进制）：4660</p>
<h4 id="22-补充说明">2.2 补充说明</h4>
<p>其他补充说明如下：</p>
<p>（1）应根据进制转换的 原理自行编写对应代码，严禁直接调用高级语言已有的库函数来实现进制转换功能；</p>
<p>（2）程序应具备基本的有效性校验功能，应能识别不合理的十六进制数，并给出错误提示，例如，0xG 是个错误的输入；</p>
<p>（3）字母不区分大小写；</p>
<p>（4）输出结果中的“十进制”字样，应根据不同进制转换，对应显示数制，如</p>
<p>“三”、“八”、“十二”； （5）程序应能自动识别输入中多余的空格，例如，0x 6 应视为 0x6，即程序自动删除输入中多余的空格；</p>
<p>（6）编程语言不限（可优先考虑 C 语言），其他常用编程语言包括：C++、Java、Python 。 （7）不要求实现图形用户界面，控制台程序即可；</p>
<p>（8）要求用户从键盘输入，不应将输入直接写死在程序中 。</p>
<p>（9）没有本地开发环境的，可使用如下的在线开发环境，支持 C/C++/Java/Python 等开发语言： https://lightly.teamcode.com/c?bd_vid=11680563935503538366</p>
<h4 id="3-现场检查要求">3 现场检查要求</h4>
<p>现场检查内容包括：</p>
<p>（1）现场运行程序，观察运行结果；</p>
<p>（2）针对教师提问进行回答，讲解程序实现主要思路；（并不会）</p>
<p>（3）根据教师要求，改变输入条件，重新运行程序，观察运行结果(并不会)</p>
<h4 id="解">解：</h4>
<p>/<em>代码</em>/</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// 函数声明，将十六进制数转换为指定进制并打印
void convertAndPrint(char* hexadecimal, int Base);
int main() {
char input[20];
int Base;

// 用户输入十六进制数
printf(&quot;输入(16进制)：&quot;);
if (scanf_s(&quot;%19s&quot;, input, sizeof(input)) != 1) {
printf(&quot;输入错误\n&quot;);
return 1;
}

char input2[30]; // 删除空格后的字符串
for (int i = 0; input[i] != '\0'; i++) {
if (input[i] != ' ') {
        input2[i] = input[i];
    }
    else {
        i--;
    }
}

// 用户输入目标进制
printf(&quot;输入目标进制（2-12）：&quot;);
if (scanf_s(&quot;%d&quot;, &amp;Base) != 1 || Base &lt; 2 || Base &gt; 12) {
    printf(&quot;目标进制不在范围内\n&quot;);
    return 1;
}

// 调用函数进行转换并打印结果
convertAndPrint(input, Base);

return 0;
}

// 十六进制数转换为指定进制并打印
void convertAndPrint(char* hexadecimal, int Base) {
long int d;
// 将十六进制数转换为十进制数字
if (sscanf_s(hexadecimal, &quot;%lx&quot;, &amp;d) == 1) {
printf(&quot;输出(%d进制): &quot;, Base);

if (Base == 10) {
        printf(&quot;%ld\n&quot;, d);
    }
    else if (Base &gt;= 2 &amp;&amp; Base &lt;= 12) {
        long int quo = d;
        int i = 0;
        char result[100];

        // 反复相除，将余数保存在result数组中
        while (quo &gt; 0) {
            int r = quo % Base;
            result[i] = (r &lt; 10) ? ('0' + r) : ('A' + r - 10);
            i++;
            quo /= Base;
        }

        // 打印结果
        for (int j = i - 1; j &gt;= 0; j--) {
            printf(&quot;%c&quot;, result[j]);
        }
        printf(&quot;\n&quot;);
    }
}
else {
    printf(&quot;输入错误\n&quot;);
}
}
</code></pre>
<p>注：助教测试时考虑到大家水平，可以不考虑输入有效性检查，可使用一些已有的库函数。❤️</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[信息技术导论课程论文]]></title>
        <id>https://Ilosyi.github.io/post/xin-xi-ji-zhu-dao-lun-ke-cheng-lun-wen/</id>
        <link href="https://Ilosyi.github.io/post/xin-xi-ji-zhu-dao-lun-ke-cheng-lun-wen/">
        </link>
        <updated>2023-11-08T02:27:50.000Z</updated>
        <content type="html"><![CDATA[<p>课程介绍：每节课会有不同老师来开一个主题讲座（实际上没什么用），最后会布置一个论文作业作为课程成绩（根据学号尾数确定题目）。以下是尾号为0的论文。</p>
<h1 id="课程论文-10">课程论文 10</h1>
<h2 id="摘要">摘要：</h2>
<p>本论文将介绍计算机科学和信息技术领域中的三个重要概念：指令集、中间件和虚拟化技术。指令集是计算机硬件的核心组成部分，它定义了机器语言指令的集合，使软件能够与硬件交互。中间件是位于应用程序和操作系统之间的软件层，用于简化分布式系统的开发和管理。虚拟化技术通过抽象和隔离物理资源，允许一个物理计算机同时运行多个虚拟操作系统和应用程序，提高资源利用率和灵活性。本文将详细解释这些概念，以便更好地理解它们在计算机科学领域的重要性和应用。 Java是一种流行的编程语言，以其跨平台能力而著称。本论文还将探讨Java的跨平台技术框架和工作原理。Java的跨平台性是通过Java虚拟机（JVM）和字节码实现的。本文介绍了Java的关键组件，包括Java编译器、JVM、字节码、类加载器和Java标准库。通过编写Java应用程序并将其编译成字节码，开发人员可以实现在不同操作系统上运行的可移植性。JVM负责加载字节码并将其翻译成本地机器代码，从而实现了跨平台性。Java的跨平台技术使其成为一种广泛应用于各种平台和设备的编程语言。</p>
<h2 id="正文">正文：</h2>
<h3 id="指令集中间件与虚拟化技术">指令集，中间件与虚拟化技术</h3>
<h4 id="指令集">指令集</h4>
<p>指令集，就是CPU中用来计算和控制计算机系统的一套指令的集合，这些指令包括 运算、逻辑运算、数据传输等操作，用于控制计算机的各个方面。 从指令集的特点上可以分为两类:</p>
<p>复杂指令集CISC<br>
（Complex Instruction Set Computer）包含了大量复杂的指令，可以执行多个低级操作。这使得CISC处理器可以更快地执行某些任务，因为每一项简单或复杂的任务都有一条对应的指令，但也使其硬件复杂。 指令集的复杂性使得CPU和控制单元的电路非常复杂。CISC体系结构的设计者已经提出减少这种中复杂性的解决方案：程序在两个层面上运行。CPU不直接执行机器语言指令，而只执行被称为微操作的简单操作。复杂指令被转化为一系列简单操作然后由CPU执行。这种中执行机制需要一个被称为微内存的特殊内存，它负责保存指令集中的每个复杂指令的一系列操作。使用微操作的程序设计被称为微程序设计。</p>
<p>精简指令集RISC<br>
（Reduced Instruction Set Computing）是一种指令长度较短的计算机，其运行速度比CISC要快。RISC的指令系统相对简单，它只要求硬件执行很有限且最常用的那部分指令，大部分复杂的操作则使用成熟的编译技术，由简单指令合成。 RISC体系结构以其高效性和适用于各种应用而闻名，特别是在对速度和效率至关重要的情况下。然而，值得注意的是，现代处理器通常在RISC和CISC设计之间融合了一些特征，在某些情况下模糊了这两种体系结构方法之间的界限。</p>
<h4 id="中间件">中间件</h4>
<p>中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源，中间件位于客户机服务器的操作系统之上，管理计算资源和网络通信。中间件的功能通常包括以下方面：</p>
<p>1.通信和消息传递： 中间件允许不同的应用程序或系统之间通过消息传递进行通信。</p>
<p>2.事务处理： 中间件支持事务处理，确保在分布式系统中的多个操作中维护一致性和可靠性。</p>
<p>3.安全性和身份验证： 中间件提供安全性层，可以进行身份验证和授权，以确保只有经过授权的用户或系统可以访问数据和服务。</p>
<p>4.负载均衡： 在分布式系统中，中间件可以分发请求以均衡负载，确保各个组件或服务器的工作负荷分布均匀。</p>
<p>5.数据转换和格式转换： 中间件可以执行数据格式的转换，以确保不同系统之间的数据可以正确解释和处理。</p>
<p>6.容错和容纳性： 中间件可以具备容错机制，使系统能够在部分组件失败时继续工作，从而提高可用性和可靠性。</p>
<p>7.性能优化： 中间件可以通过缓存、请求重排等技术来提高系统性能，减少通信延迟。</p>
<p>总之，中间件是在分布式和复杂的计算环境中促进应用程序和系统协作的关键组成部分。它提供了一种抽象层，使开发人员能够更容易地构建和维护分布式系统，同时提高了系统的可扩展性、可靠性和性能。中间件在企业应用、云计算、大数据处理等各种领域都发挥着重要作用。</p>
<h4 id="虚拟化技术">虚拟化技术</h4>
<p>虚拟化技术（Virtualization）是一种将计算机资源进行抽象和隔离的方法，以便在一台物理计算机上同时运行多个虚拟操作系统和应用程序。虚拟化技术可以应用于多个领域，主要分为几大类： 计算虚拟化，针对CPU和内存资源虚拟化技术。</p>
<p>网络虚拟化，针对网络链路资源虚拟化技术。</p>
<p>IO虚拟化，针对IO资源虚拟化技术。</p>
<p>存储虚拟化，针对磁盘存储资源虚拟化技术。</p>
<p>服务器虚拟化允许多个虚拟服务器在同一台物理服务器上运行，提高了硬件资源的利用率。</p>
<p>桌面虚拟化使用户能够在单一计算机上运行多个虚拟桌面。网络虚拟化通过创建虚拟网络层次，提供了网络资源的共享和隔离。存储虚拟化将多个存储设备抽象为一个虚拟存储池，简化了数据管理。 虚拟化技术为企业提供了灵活性、可扩展性和资源利用率的提升，降低了硬件成本和管理复杂性。</p>
<h3 id="java语言的跨平台技术的技术框架和工作原理">java语言的跨平台技术的技术框架和工作原理</h3>
<p>Java是一种高度流行的编程语言，其成功的一个关键特性是跨平台能力。跨平台性意味着Java应用程序可以在不同操作系统和硬件架构上运行，而无需对代码进行重写。这一特性是通过Java虚拟机（JVM）和字节码实现的。接下来我将介绍java的技术框架和工作原理</p>
<h4 id="一技术框架-java的跨平台技术框架包括以下关键组件">一.技术框架 Java的跨平台技术框架包括以下关键组件：</h4>
<p>1.Java编译器 开发人员使用Java编程语言编写应用程序，编译时首先读入java源程序，然后进行语法检查，如果出现问题就终止编译。语法检查通过后，生成中间代码即字节码，这个过程生成了.class文件，其中包含了应用程序的字节码。</p>
<p>2.Java虚拟机（JVM）Java虚拟机是Java平台的核心组成部分之一，它是一个在计算机上运行Java字节码的虚拟机。JVM充当了Java应用程序和底层操作系统之间的中间层，将字节码文件加载到内存中，解释或编译为本地机器代码，并执行应用程序，提供了跨平台的特性，使得Java程序可以在不同的操作系统和硬件上运行。</p>
<p>3.字节码 字节码是一种与特定硬件无关的中间代码。Java编译器将Java源代码编译成字节码，这使得应用程序具有跨平台性。字节码包含一系列操作码（opcodes），这些操作码在JVM上执行。</p>
<p>类加载器 JVM包括类加载器，它负责从文件系统或网络加载字节码文件，并将它们转换为Java类的运行时表示。类加载器还执行类的链接，包括验证、准备和解析。<br>
Java标准库 Java标准库是一组预定义的类和API，提供了许多常见的功能，如文件处理、网络通信、多线程管理等。这些库是跨平台的，因为它们的实现是基于JVM，而不依赖于底层操作系统。</p>
<h4 id="二工作原理">二．工作原理 ：</h4>
<p>开发人员编写Java应用程序并使用Java编译器将其编译成字节码文件。 用户在目标平台上安装了JVM。当用户希望运行Java应用程序时，JVM将字节码文件加载到内存中，然后执行字节码。JVM可以通过解释字节码执行应用程序，也可以使用即时编译器（JIT Compiler）将字节码编译成本地机器代码，提高应用程序的性能。 由于字节码是与特定硬件无关的，因此Java应用程序可以在任何支持Java的操作系统上运行，实现了跨平台性。</p>
<h2 id="总结">总结：</h2>
<p>指令集、中间件和虚拟化技术是计算机科学和信息技术领域中的关键概念。指令集定义了计算机硬件与软件之间的接口，中间件简化了分布式系统的开发，虚拟化技术提供了资源隔离和共享的能力。 这些概念在现代计算领域中具有重要作用。指令集影响着计算机硬件的设计和性能。中间件帮助开发者构建分布式应用程序，实现系统间的协作。虚拟化技术提高了资源利用率，降低了成本，使得计算资源的管理更加高效。</p>
<h2 id="参考文献">参考文献：</h2>
<p>[1]Behrouz Forouzan.《计算机科学导论》[M].吕云翔等译.北京：机械工业出版社,2020</p>
<p>[2]徐悦甡.中间件技术基础[M].西安电子科技大学</p>
<p>[3]孟宪福. 《分布式对象技术及其应用》.[M].北京：清华大学出版社，2015</p>
<p>[4] 精简指令集计算机(RISC)浅析.中国知网[J]. 2017-03-12</p>
<p>[5]Rajkumar Buyya,Christian Vccchiola,S.Thamarai Selvi《深入理解云计算：基本原理和应用程序编程技术》[M].刘丽等译.北京：机械工业出版社,2020</p>
<p>[6]李刚．疯狂Java讲义（第2版）：电子工业出版社，2014：2</p>
<p>[7]李晋.Java的昨天，今天和明天[J].信息与电脑,2011(1).</p>
<p>[8]任哲．JAVA技术应用基础：机械工业出版社，2009：4-6 董云铮，陈千，梅惠平．Java技术应用：清华大学出版社，2007：2</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://Ilosyi.github.io/post/hello-gridea/</id>
        <link href="https://Ilosyi.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>